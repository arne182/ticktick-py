{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ticktick-py \u00b6 Unofficial TickTick API Client for Python 3 \u00b6 Description \u00b6 ticktick-py is an unofficial API library for interacting with TickTick.com . It allows users a way to interact with their TickTick account using Python . Features \u00b6 The library automatically fetches all the tasks, tags, lists, and more linked to your profile and stores them in a dictionary named state . Tasks Create, Update, and Delete Tasks Acquire all your uncompleted tasks Move tasks easily between projects Acquire all completed tasks in a certain date range Tags Batch create, update, and delete tags Create tags with parameters that are not usually allowed: \\\\ / \" # : * ? < > | Space Projects Batch create, update, and delete 'lists' (projects) Batch archive projects Example: Creating A Task \u00b6 Lets create a task in our inbox titled \"Get Groceries\" name = 'Get Groceries' # Task Name local_task = client . task . builder ( name ) # Create a dictionary for the task groceries = client . task . create ( local_task ) # Actually create the task Result \u00b6 A simplified dictionary for the newly created task is returned. print ( groceries ) { 'id' : '60c6a40b8f083f896c9444a0' , 'projectId' : 'inbox115781412' , 'title' : 'Get Groceries' , 'timeZone' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'sortOrder' : - 3298534883328 , 'items' : []} You can retrieve the full dictionary with every parameter by using the get_by_id method. full_task = client . get_by_id ( groceries [ 'id' ]) print ( full_task ) { 'id' : '60c6a40b8f083f896c9444a0' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 3298534883328 , 'title' : 'Get Groceries' , 'timeZone' : '' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-06-14T00:34:19.907+0000' , 'etag' : 't8xnwewi' , 'deleted' : 0 , 'createdTime' : '2021-06-14T00:34:19.907+0000' , 'creator' : 113581412 , 'tags' : [], 'kind' : 'TEXT' } Created Task In TickTick Most methods will return the object that was changed. Consult the usage documentation for more information on specific methods. Installation \u00b6 Note: ticktick-py requires Python 3.6 or above. pip install ticktick-py Get Started \u00b6 Register A New TickTick App \u00b6 The library now uses TickTick's OpenAPI scheme when possible. This requires registering a new app through TickTick's developer documentation. OpenAPI Documentation Click on Manage Apps in the top right corner. You will be prompted to login with your normal TickTick credentials if you are not already logged in. Register a new app by clicking the +App Name button. Name is the only required parameter here. Once created you should see the app and be able to edit it. There should now be a generated Client ID and Client Secret parameters. It is recommended you save these to your environment, and make sure you do not share your actual Client Secret . For OAuth Redirect URL enter any URL you would like to be redirected to upon giving permissions to your account. It does not have to be an actually live URL - this local host URL is fine for most purposes. It is also recommended you save this URL to your environment. Once you have registered the app, you can now proceed with the rest of the setup. Required Imports \u00b6 from ticktick.oauth2 import OAuth2 # OAuth2 Manager from ticktick.api import TickTickClient # Main Interface Setup \u00b6 auth_client = OAuth2 ( client_id = client_id , client_secret = client_secret , redirect_uri = uri ) client = TickTickClient ( username , password , auth_client ) The first time the OAuth2 object runs, you will need to manually accept permissions. A webbrowser will automatically open. The default permissions are to Read and Write tasks (and are the only options right now). You can change the permissions by specifying the scope parameter when creating your OAuth2 instance. More information can be found in the OAuth2 documention . In the console you will be prompted to enter the URL that you were redirected to. It will be your specified OAuth URL with some added parameters. Enter the URL you were redirected to: >? http://127.0.0.1:8080/?code=RK3dSi&state=None That is it! Your token information is cached in a file (default is .token-oauth ) so you will only have to manually allow access the first time, and whenever the token expires. As of now it seems tokens expire after about 6 months. Future Plans \u00b6 General Enhanced Team Support Tasks Get and Restore From Trash Projects Smart List Support Column Creation For Kanban View Pomo and Focus Getting the focus / pomo statistics for your profile Starting and stopping the focus / pomo timer Habits Get, create, archive, delete, and complete habits","title":"Overview"},{"location":"#ticktick-py","text":"","title":"ticktick-py"},{"location":"#unofficial-ticktick-api-client-for-python-3","text":"","title":"Unofficial TickTick API Client for Python 3"},{"location":"#description","text":"ticktick-py is an unofficial API library for interacting with TickTick.com . It allows users a way to interact with their TickTick account using Python .","title":"Description"},{"location":"#features","text":"The library automatically fetches all the tasks, tags, lists, and more linked to your profile and stores them in a dictionary named state . Tasks Create, Update, and Delete Tasks Acquire all your uncompleted tasks Move tasks easily between projects Acquire all completed tasks in a certain date range Tags Batch create, update, and delete tags Create tags with parameters that are not usually allowed: \\\\ / \" # : * ? < > | Space Projects Batch create, update, and delete 'lists' (projects) Batch archive projects","title":"Features"},{"location":"#example-creating-a-task","text":"Lets create a task in our inbox titled \"Get Groceries\" name = 'Get Groceries' # Task Name local_task = client . task . builder ( name ) # Create a dictionary for the task groceries = client . task . create ( local_task ) # Actually create the task","title":"Example: Creating A Task"},{"location":"#result","text":"A simplified dictionary for the newly created task is returned. print ( groceries ) { 'id' : '60c6a40b8f083f896c9444a0' , 'projectId' : 'inbox115781412' , 'title' : 'Get Groceries' , 'timeZone' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'sortOrder' : - 3298534883328 , 'items' : []} You can retrieve the full dictionary with every parameter by using the get_by_id method. full_task = client . get_by_id ( groceries [ 'id' ]) print ( full_task ) { 'id' : '60c6a40b8f083f896c9444a0' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 3298534883328 , 'title' : 'Get Groceries' , 'timeZone' : '' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-06-14T00:34:19.907+0000' , 'etag' : 't8xnwewi' , 'deleted' : 0 , 'createdTime' : '2021-06-14T00:34:19.907+0000' , 'creator' : 113581412 , 'tags' : [], 'kind' : 'TEXT' } Created Task In TickTick Most methods will return the object that was changed. Consult the usage documentation for more information on specific methods.","title":"Result"},{"location":"#installation","text":"Note: ticktick-py requires Python 3.6 or above. pip install ticktick-py","title":"Installation"},{"location":"#get-started","text":"","title":"Get Started"},{"location":"#register-a-new-ticktick-app","text":"The library now uses TickTick's OpenAPI scheme when possible. This requires registering a new app through TickTick's developer documentation. OpenAPI Documentation Click on Manage Apps in the top right corner. You will be prompted to login with your normal TickTick credentials if you are not already logged in. Register a new app by clicking the +App Name button. Name is the only required parameter here. Once created you should see the app and be able to edit it. There should now be a generated Client ID and Client Secret parameters. It is recommended you save these to your environment, and make sure you do not share your actual Client Secret . For OAuth Redirect URL enter any URL you would like to be redirected to upon giving permissions to your account. It does not have to be an actually live URL - this local host URL is fine for most purposes. It is also recommended you save this URL to your environment. Once you have registered the app, you can now proceed with the rest of the setup.","title":"Register A New TickTick App"},{"location":"#required-imports","text":"from ticktick.oauth2 import OAuth2 # OAuth2 Manager from ticktick.api import TickTickClient # Main Interface","title":"Required Imports"},{"location":"#setup","text":"auth_client = OAuth2 ( client_id = client_id , client_secret = client_secret , redirect_uri = uri ) client = TickTickClient ( username , password , auth_client ) The first time the OAuth2 object runs, you will need to manually accept permissions. A webbrowser will automatically open. The default permissions are to Read and Write tasks (and are the only options right now). You can change the permissions by specifying the scope parameter when creating your OAuth2 instance. More information can be found in the OAuth2 documention . In the console you will be prompted to enter the URL that you were redirected to. It will be your specified OAuth URL with some added parameters. Enter the URL you were redirected to: >? http://127.0.0.1:8080/?code=RK3dSi&state=None That is it! Your token information is cached in a file (default is .token-oauth ) so you will only have to manually allow access the first time, and whenever the token expires. As of now it seems tokens expire after about 6 months.","title":"Setup"},{"location":"#future-plans","text":"General Enhanced Team Support Tasks Get and Restore From Trash Projects Smart List Support Column Creation For Kanban View Pomo and Focus Getting the focus / pomo statistics for your profile Starting and stopping the focus / pomo timer Habits Get, create, archive, delete, and complete habits","title":"Future Plans"},{"location":"changelog/","text":"2.0.1 - 6/24/21 \u00b6 Change Retry class to come from urllib3 library instead of requests 2.0.0 - 6/16/21 \u00b6 Major Change: Implemented TickTick OpenAPI Scheme Tasks \u00b6 create() -> Batch Task Creation No Longer Supported update() -> Batch Task Update No Longer Supported delete() -> Now Takes Full Task Dictionaries Instead Of Just Task ID's Added dates() method Under The Hood Changes \u00b6 Major Test Refactoring -> Separate Unit and Integration Tests Cache Handler For Open API Scheme Minimizing Type Checks For Task Methods 1.0.2 - 1/18/21 \u00b6 First Stable Release 1.0.0 - 1/18/21 \u00b6 Initial Release","title":"Changelog"},{"location":"changelog/#201-62421","text":"Change Retry class to come from urllib3 library instead of requests","title":"2.0.1 - 6/24/21"},{"location":"changelog/#200-61621","text":"Major Change: Implemented TickTick OpenAPI Scheme","title":"2.0.0 - 6/16/21"},{"location":"changelog/#tasks","text":"create() -> Batch Task Creation No Longer Supported update() -> Batch Task Update No Longer Supported delete() -> Now Takes Full Task Dictionaries Instead Of Just Task ID's Added dates() method","title":"Tasks"},{"location":"changelog/#under-the-hood-changes","text":"Major Test Refactoring -> Separate Unit and Integration Tests Cache Handler For Open API Scheme Minimizing Type Checks For Task Methods","title":"Under The Hood Changes"},{"location":"changelog/#102-11821","text":"First Stable Release","title":"1.0.2 - 1/18/21"},{"location":"changelog/#100-11821","text":"Initial Release","title":"1.0.0 - 1/18/21"},{"location":"license/","text":"MIT License Copyright (c) 2021 Michael Lazeroff Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"usage/api/","text":"The TickTickClient class is the origin for interactions with the API. It is important to understand how the local data for your profile is stored and the names that you will interact with in order to access the different features. State \u00b6 The state public member is a dictionary that contains objects linked to your TickTick profile. The dictionary is automatically updated and synced when changes are made through the API. state Members The lists are comprised of dictionaries that contain all the fields for each type of TickTick object: tasks, tags, etc. Member Type Contains tasks list All uncompleted task objects tags list All tag objects projects list All project objects project_folders list All project folder objects Accessing Members can be accessed by normal dictionary indexing using the member strings. # Assumes that 'client' is the name that references the TickTickClient class. uncompleted_tasks = client . state [ 'tasks' ] all_tags = client . state [ 'tags' ] Example Task Object { 'id' : '5ff24e4b8f08904035b304d9' , 'projectId' : 'inbox416323287' , 'sortOrder' : - 1099511627776 , 'title' : 'Get Groceries' , 'content' : '' , 'startDate' : '2021-05-06T21:30:00.000+0000' , 'dueDate' : '2021-05-06T21:30:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : False , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-03T23:07:55.004+0000' , 'etag' : 'ol2zesef' , 'deleted' : 0 , 'createdTime' : '2021-01-03T23:07:55.011+0000' , 'creator' : 359368200 , 'kind' : 'TEXT' } Functionality \u00b6 Different functionality can be accessed through different public members of the TickTickClient instance: Functionality Method Managers Accessing the methods for each type of member is easy. It is in this format: client (or whatever name references the TickTickClient instance). manager (members in table below). method() Member Functionality task Task Methods tag Tag Methods project List Methods Example Usage # Assumes that 'client' is the name that references the TickTickClient instance. created_task = client . task . create ( 'My Created Task' ) deleted_project = client . project . delete ( project_id ) Make sure to check the individual documentation for the different method managers. Other Public Members Useful Members Member Type Description profile_id str ID assigned to your profile inbox_id str Inbox ID assigned to your profile time_zone str Timezone string linked to your TickTick profile state dict Holds all the item objects in your profile (described above) Members That Shouldn't Be Messed With Messing with these values could produce unwanted effects. Member Type Description access_token str Instance token generated by TickTick for your session. cookies dict Cookies required for your session. Useful Methods \u00b6 TickTickClient has a lot of helper functions in its documentation...however these should be the only of use methods to you: Tip It's recommended that you look at the documentation for these three methods to see how to obtain / delete objects from the local state dictionary - an important feature that will be useful when updating / deleting TickTick objects remotely. delete_from_local_state get_by_fields get_by_id get_by_etag That's It! \u00b6 That's all the required information for how to get started with the library! To see how to use individual features, check these out next: Tasks Projects Tags TickTickClient Documentation \u00b6 TickTickClient \u00b6 __init__ ( self , username , password , oauth ) special \u00b6 Initializes a client session. In order to interact with the API a successful login must occur. Parameters: Name Type Description Default username str TickTick Username required password str TickTick Password required oauth OAuth2 OAuth2 manager required Exceptions: Type Description RunTimeError If the login was not successful. Source code in ticktick/api.py def __init__ ( self , username : str , password : str , oauth : OAuth2 ) -> None : \"\"\" Initializes a client session. In order to interact with the API a successful login must occur. Arguments: username: TickTick Username password: TickTick Password oauth: OAuth2 manager Raises: RunTimeError: If the login was not successful. \"\"\" # Class members self . access_token = None self . cookies = {} self . time_zone = '' self . profile_id = '' self . inbox_id = '' self . state = {} self . reset_local_state () self . oauth_manager = oauth self . _session = self . oauth_manager . session self . _prepare_session ( username , password ) # Mangers for the different operations self . focus = FocusTimeManager ( self ) self . habit = HabitManager ( self ) self . project = ProjectManager ( self ) self . pomo = PomoManager ( self ) self . settings = SettingsManager ( self ) self . tag = TagsManager ( self ) self . task = TaskManager ( self ) check_status_code ( response , error_message ) staticmethod \u00b6 Verifies the http response was status code 200. Parameters: Name Type Description Default response httpx Httpx response required error_message str Error message to be included with the exception required Exceptions: Type Description RuntimeError If the status code of the response was not 200. Source code in ticktick/api.py @staticmethod def check_status_code ( response , error_message : str ) -> None : \"\"\" Verifies the http response was status code 200. Arguments: response (httpx): Httpx response error_message: Error message to be included with the exception Raises: RuntimeError: If the status code of the response was not 200. \"\"\" if response . status_code != 200 : raise RuntimeError ( error_message ) delete_from_local_state ( self , search = None , ** kwargs ) \u00b6 Deletes a single object from the local state dictionary. Does not delete any items remotely. If search is specified, it will only search the specific state list, else the entire state dictionary will be searched. Example Since each TickTick object like tasks, lists, and tags are just dictionaries of fields, we can find an object by comparing the fields. For example: Lets say that we wanted to find and delete an existing task object from our local state with the name 'Get Groceries'. To do this, we can specify the field(s) that we want to compare for in the task objects -> in this case the title 'Get Groceries'. The call to the function would look like this: # Assumes that `client` is the name referencing the TickTickClient instance. deleted_task = client . delete_from_local_state ( title = 'Get Groceries' ) deleted_task would now hold the object that was deleted from the state dictionary if it was found. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the state dictionary. # Assumes that `client` is the name referencing the TickTickClient instance. deleted_task = client . delete_from_local_state ( title = 'Get Groceries' , search = 'tasks' ) The search will now only look through tasks in state . Parameters: Name Type Description Default search str A specific item to look through in the state dictionary. When not specified the None **kwargs Matching fields in the object to look for. {} Returns: Type Description dict The dictionary of the object that was deleted. Exceptions: Type Description ValueError If no key word arguments are provided. KeyError If the search key provided is not a key in state . Source code in ticktick/api.py def delete_from_local_state ( self , search : str = None , ** kwargs ) -> dict : \"\"\" Deletes a single object from the local `state` dictionary. **Does not delete any items remotely.** If search is specified, it will only search the specific [`state`](api.md#state) list, else the entire [`state`](api.md#state) dictionary will be searched. !!! example Since each TickTick object like tasks, lists, and tags are just dictionaries of fields, we can find an object by comparing the fields. For example: Lets say that we wanted to find and delete an existing task object from our local state with the name 'Get Groceries'. To do this, we can specify the field(s) that we want to compare for in the task objects -> in this case the `title` 'Get Groceries'. The call to the function would look like this: ```python # Assumes that `client` is the name referencing the TickTickClient instance. deleted_task = client.delete_from_local_state(title='Get Groceries') ``` `deleted_task` would now hold the object that was deleted from the [`state`](api.md#state) dictionary if it was found. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the [`state`](api.md#state) dictionary. ```python # Assumes that `client` is the name referencing the TickTickClient instance. deleted_task = client.delete_from_local_state(title='Get Groceries', search='tasks') ``` The search will now only look through `tasks` in `state`. Arguments: search: A specific item to look through in the [`state`](api.md#state) dictionary. When not specified the entire [`state`](api.md#state) dictionary will be searched. **kwargs: Matching fields in the object to look for. Returns: The dictionary of the object that was deleted. Raises: ValueError: If no key word arguments are provided. KeyError: If the search key provided is not a key in [`state`](api.md#state). \"\"\" # Check that kwargs is not empty if kwargs == {}: raise ValueError ( 'Must Include Field(s) To Be Searched For' ) if search is not None and search not in self . state : raise KeyError ( f \"' { search } ' Is Not Present In self.state Dictionary\" ) # Search just in the desired list if search is not None : # Go through the state dictionary list and delete the object that matches the fields for item in range ( len ( self . state [ search ])): all_match = True for field in kwargs : if kwargs [ field ] != self . state [ search ][ item ][ field ]: all_match = False break if all_match : deleted = self . state [ search ][ item ] # Delete the item del self . state [ search ][ item ] return deleted else : # No key passed, search entire self.state dictionary # Search the first level of the state dictionary for primary_key in self . state : skip_primary_key = False all_match = True middle_key = 0 # Search the individual lists of the dictionary for middle_key in range ( len ( self . state [ primary_key ])): if skip_primary_key : break # Match the fields in the kwargs dictionary to the specific object -> if all match add index for fields in kwargs : # if the field doesn't exist, we can assume every other item in the list doesn't have the # field either -> so skip this primary_key entirely if fields not in self . state [ primary_key ][ middle_key ]: all_match = False skip_primary_key = True break if kwargs [ fields ] == self . state [ primary_key ][ middle_key ][ fields ]: all_match = True else : all_match = False if all_match : deleted = self . state [ primary_key ][ middle_key ] del self . state [ primary_key ][ middle_key ] return deleted get_by_etag ( self , etag , search = None ) \u00b6 Returns the dictionary object of the item with the matching etag. If search is specified, it will only search the specific state list, else the entire state dictionary will be searched. Example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing the etag fields. For example: Lets get the object that corresponds to an etag referenced by my_etag . The call to the function would look like this: # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_etag ( my_etag ) found_obj would now reference the object if it was found, else it would reference an empty dictionary. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the state dictionary. # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_etag ( my_etag , search = 'projects' ) The search will now only look through projects in state . Parameters: Name Type Description Default etag str The etag of the object that you are looking for. required search str Key in state that the search should take place in. If empty the None Returns: Type Description dict The dictionary object of the item if found, or an empty dictionary if not found. Exceptions: Type Description KeyError If the search key provided is not a key in state . Source code in ticktick/api.py def get_by_etag ( self , etag : str , search : str = None ) -> dict : \"\"\" Returns the dictionary object of the item with the matching etag. If search is specified, it will only search the specific [`state`](api.md#state) list, else the entire [`state`](api.md#state) dictionary will be searched. !!! example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing the etag fields. For example: Lets get the object that corresponds to an etag referenced by `my_etag`. The call to the function would look like this: ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_etag(my_etag) ``` `found_obj` would now reference the object if it was found, else it would reference an empty dictionary. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the [`state`](api.md#state) dictionary. ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_etag(my_etag, search='projects') ``` The search will now only look through `projects` in [`state`](api.md#state). Arguments: etag: The etag of the object that you are looking for. search: Key in [`state`](#state) that the search should take place in. If empty the entire [`state`](api.md#state) dictionary will be searched. Returns: The dictionary object of the item if found, or an empty dictionary if not found. Raises: KeyError: If the search key provided is not a key in [`state`](api.md#state). \"\"\" if search is not None and search not in self . state : raise KeyError ( f \"' { search } ' Is Not Present In self.state Dictionary\" ) # Search just in the desired list if search is not None : for index in self . state [ search ]: if index [ 'etag' ] == etag : return index else : # Search all items in self.state for prim_key in self . state : for our_object in self . state [ prim_key ]: if 'etag' not in our_object : break if our_object [ 'etag' ] == etag : return our_object # Return empty dictionary if not found return {} get_by_fields ( self , search = None , ** kwargs ) \u00b6 Finds and returns the objects in state that match the inputted fields. If search is specified, it will only search the specific state list, else the entire state dictionary will be searched. Example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing any fields contained in those objects. For example: Lets say we have 3 task objects that are titled 'Hello', and we want to obtain all of them. The call to the function would look like this: # Assumes that `client` is the name referencing the TickTickClient instance. found_objs = client . get_by_fields ( title = 'Hello' ) found_objs would now reference a list containing the 3 objects with titles 'Hello'. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the state dictionary. # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_fields ( title = 'Hello' , search = 'tasks' ) The search will now only look through tasks in state . Parameters: Name Type Description Default search str Key in state that the search should take place in. If empty the None **kwargs Matching fields in the object to look for. {} Returns: Type Description dict or list Single Object (dict) : The dictionary of the object. Multiple Objects (list) : A list of dictionary objects. Nothing Found (list) : Empty List Exceptions: Type Description ValueError If no key word arguments are provided. KeyError If the search key provided is not a key in state . Source code in ticktick/api.py def get_by_fields ( self , search : str = None , ** kwargs ): \"\"\" Finds and returns the objects in `state` that match the inputted fields. If search is specified, it will only search the specific [`state`](api.md#state) list, else the entire [`state`](api.md#state) dictionary will be searched. !!! example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing any fields contained in those objects. For example: Lets say we have 3 task objects that are titled 'Hello', and we want to obtain all of them. The call to the function would look like this: ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_objs = client.get_by_fields(title='Hello') ``` `found_objs` would now reference a list containing the 3 objects with titles 'Hello'. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the [`state`](#state) dictionary. ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_fields(title='Hello', search='tasks') ``` The search will now only look through `tasks` in [`state`](api.md#state). Arguments: search: Key in [`state`](api.md#state) that the search should take place in. If empty the entire [`state`](api.md#state) dictionary will be searched. **kwargs: Matching fields in the object to look for. Returns: dict or list: **Single Object (dict)**: The dictionary of the object. **Multiple Objects (list)**: A list of dictionary objects. **Nothing Found (list)**: Empty List Raises: ValueError: If no key word arguments are provided. KeyError: If the search key provided is not a key in `state`. \"\"\" if kwargs == {}: raise ValueError ( 'Must Include Field(s) To Be Searched For' ) if search is not None and search not in self . state : raise KeyError ( f \"' { search } ' Is Not Present In self.state Dictionary\" ) objects = [] if search is not None : # If a specific key was passed for self.state # Go through self.state[key_name] and see if all the fields in kwargs match # If all don't match return empty list for index in self . state [ search ]: all_match = True for field in kwargs : if kwargs [ field ] != index [ field ]: all_match = False break if all_match : objects . append ( index ) else : # No key passed, search entire self.state dictionary # Search the first level of the state dictionary for primarykey in self . state : skip_primary_key = False all_match = True middle_key = 0 # Search the individual lists of the dictionary for middle_key in range ( len ( self . state [ primarykey ])): if skip_primary_key : break # Match the fields in the kwargs dictionary to the specific object -> if all match add index for fields in kwargs : # if the field doesn't exist, we can assume every other item in the list doesn't have the # field either -> so skip this primary_key entirely if fields not in self . state [ primarykey ][ middle_key ]: all_match = False skip_primary_key = True break if kwargs [ fields ] == self . state [ primarykey ][ middle_key ][ fields ]: all_match = True else : all_match = False if all_match : objects . append ( self . state [ primarykey ][ middle_key ]) if len ( objects ) == 1 : return objects [ 0 ] else : return objects get_by_id ( self , obj_id , search = None ) \u00b6 Returns the dictionary of the object corresponding to the passed id. If search is specified, it will only search the specific state list, else the entire state dictionary will be searched. Example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing the id fields. For example: Lets get the object that corresponds to an id referenced by my_id . The call to the function would look like this: # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_id ( my_id ) found_obj would now reference the object if it was found, else it would reference an empty dictionary. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the state dictionary. # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_id ( my_id , search = 'projects' ) The search will now only look through projects in state . Parameters: Name Type Description Default obj_id str Id of the item. required search str Key in state that the search should take place in. If empty the None Returns: Type Description dict The dictionary object of the item if found, or an empty dictionary if not found. Exceptions: Type Description KeyError If the search key provided is not a key in state . Source code in ticktick/api.py def get_by_id ( self , obj_id : str , search : str = None ) -> dict : \"\"\" Returns the dictionary of the object corresponding to the passed id. If search is specified, it will only search the specific [`state`](api.md#state) list, else the entire [`state`](api.md#state) dictionary will be searched. !!! example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing the id fields. For example: Lets get the object that corresponds to an id referenced by `my_id`. The call to the function would look like this: ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_id(my_id) ``` `found_obj` would now reference the object if it was found, else it would reference an empty dictionary. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the [`state`](api.md#state) dictionary. ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_id(my_id, search='projects') ``` The search will now only look through `projects` in [`state`](api.md#state). Arguments: obj_id: Id of the item. search: Key in [`state`](api.md#state) that the search should take place in. If empty the entire [`state`](api.md#state) dictionary will be searched. Returns: The dictionary object of the item if found, or an empty dictionary if not found. Raises: KeyError: If the search key provided is not a key in [`state`](api.md#state). \"\"\" if search is not None and search not in self . state : raise KeyError ( f \"' { search } ' Is Not Present In self.state Dictionary\" ) # Search just in the desired list if search is not None : for index in self . state [ search ]: if index [ 'id' ] == obj_id : return index else : # Search all items in self.state for prim_key in self . state : for our_object in self . state [ prim_key ]: if 'id' not in our_object : break if our_object [ 'id' ] == obj_id : return our_object # Return empty dictionary if not found return {} http_delete ( self , url , ** kwargs ) \u00b6 Sends an http delete request with the specified url and keyword arguments. Parameters: Name Type Description Default url str Url to send the request. required **kwargs Arguments to send with the request. {} Returns: Type Description dict The json parsed response if possible or just a string of the response text if not. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def http_delete ( self , url , ** kwargs ): \"\"\" Sends an http delete request with the specified url and keyword arguments. Arguments: url (str): Url to send the request. **kwargs: Arguments to send with the request. Returns: dict: The json parsed response if possible or just a string of the response text if not. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . _session . delete ( url , ** kwargs ) self . check_status_code ( response , 'Could Not Complete Request' ) try : return response . json () except ValueError : return response . text http_get ( self , url , ** kwargs ) \u00b6 Sends an http get request with the specified url and keyword arguments. Parameters: Name Type Description Default url str Url to send the request. required **kwargs Arguments to send with the request. {} Returns: Type Description dict The json parsed response if possible or just a string of the response text if not. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def http_get ( self , url , ** kwargs ): \"\"\" Sends an http get request with the specified url and keyword arguments. Arguments: url (str): Url to send the request. **kwargs: Arguments to send with the request. Returns: dict: The json parsed response if possible or just a string of the response text if not. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . _session . get ( url , ** kwargs ) self . check_status_code ( response , 'Could Not Complete Request' ) try : return response . json () except ValueError : return response . text http_post ( self , url , ** kwargs ) \u00b6 Sends an http post request with the specified url and keyword arguments. Parameters: Name Type Description Default url str Url to send the request. required **kwargs Arguments to send with the request. {} Returns: Type Description dict The json parsed response if possible or just a string of the response text if not. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def http_post ( self , url , ** kwargs ): \"\"\" Sends an http post request with the specified url and keyword arguments. Arguments: url (str): Url to send the request. **kwargs: Arguments to send with the request. Returns: dict: The json parsed response if possible or just a string of the response text if not. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . _session . post ( url , ** kwargs ) self . check_status_code ( response , 'Could Not Complete Request' ) try : return response . json () except ValueError : return response . text http_put ( self , url , ** kwargs ) \u00b6 Sends an http put request with the specified url and keyword arguments. Parameters: Name Type Description Default url str Url to send the request. required **kwargs Arguments to send with the request. {} Returns: Type Description dict The json parsed response if possible or just a string of the response text if not. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def http_put ( self , url , ** kwargs ): \"\"\" Sends an http put request with the specified url and keyword arguments. Arguments: url (str): Url to send the request. **kwargs: Arguments to send with the request. Returns: dict: The json parsed response if possible or just a string of the response text if not. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . _session . put ( url , ** kwargs ) self . check_status_code ( response , 'Could Not Complete Request' ) try : return response . json () except ValueError : return response . text parse_etag ( response , multiple = False ) staticmethod \u00b6 Parses the etag of a successful creation of a tag object. Info The response from TickTick upon a successful tag creation is in this form: {\"id2etag\":{\"MyTag\":\"vxzpwo38\"},\"id2error\":{}} We want to obtain \"vxzpwo38\" in this example - the etag of the object. Parameters: Name Type Description Default response dict Dictionary from the successful creation of a tag object required multiple bool Specifies whether there are multiple etags to return. False Returns: Type Description str A single etag string if not multiple, or a list of etag strings if multiple. Source code in ticktick/api.py @staticmethod def parse_etag ( response : dict , multiple : bool = False ) -> str : \"\"\" Parses the etag of a successful creation of a tag object. !!! info The response from TickTick upon a successful tag creation is in this form: ```md {\"id2etag\":{\"MyTag\":\"vxzpwo38\"},\"id2error\":{}} ``` We want to obtain \"vxzpwo38\" in this example - the etag of the object. Arguments: response: Dictionary from the successful creation of a tag object multiple: Specifies whether there are multiple etags to return. Return: A single etag string if not multiple, or a list of etag strings if multiple. \"\"\" etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) if not multiple : return etag [ etag2 [ 0 ]] else : etags = [] for key in range ( len ( etag2 )): etags . append ( etag [ etag2 [ key ]]) return etags parse_id ( response ) staticmethod \u00b6 Parses the Id of a successful creation of a TickTick object. Info The response from the TickTick servers is in this form: {'id2etag': {'5ff2bcf68f08093e5b745a30': '3okkc2xm'}, 'id2error': {}} We want to obtain '5ff2bcf68f08093e5b745a30' in this example - the id of the object. Parameters: Name Type Description Default response dict Dictionary containing the Dd from the TickTick servers. required Returns: Type Description str Id string of the object. Source code in ticktick/api.py @staticmethod def parse_id ( response : dict ) -> str : \"\"\" Parses the Id of a successful creation of a TickTick object. !!! info The response from the TickTick servers is in this form: ```md {'id2etag': {'5ff2bcf68f08093e5b745a30': '3okkc2xm'}, 'id2error': {}} ``` We want to obtain '5ff2bcf68f08093e5b745a30' in this example - the id of the object. Arguments: response: Dictionary containing the Dd from the TickTick servers. Returns: Id string of the object. \"\"\" id_tag = response [ 'id2etag' ] id_tag = list ( id_tag . keys ()) return id_tag [ 0 ] reset_local_state ( self ) \u00b6 Resets the contents of the items in the state dictionary. Source code in ticktick/api.py def reset_local_state ( self ): \"\"\" Resets the contents of the items in the [`state`](api.md#state) dictionary. \"\"\" self . state = { 'projects' : [], 'project_folders' : [], 'tags' : [], 'tasks' : [], 'user_settings' : {}, 'profile' : {} } sync ( self ) \u00b6 Populates the TickTickClient state dictionary with the contents of your account. This method is called when necessary by other methods and does not need to be explicitly called. Returns: Type Description httpx The response from the get request. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def sync ( self ): \"\"\" Populates the `TickTickClient` [`state`](api.md#state) dictionary with the contents of your account. **This method is called when necessary by other methods and does not need to be explicitly called.** Returns: httpx: The response from the get request. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . http_get ( self . INITIAL_BATCH_URL , cookies = self . cookies , headers = self . HEADERS ) # Inbox Id self . inbox_id = response [ 'inboxId' ] # Set list groups self . state [ 'project_folders' ] = response [ 'projectGroups' ] # Set lists self . state [ 'projects' ] = response [ 'projectProfiles' ] # Set Uncompleted Tasks self . state [ 'tasks' ] = response [ 'syncTaskBean' ][ 'update' ] # Set tags self . state [ 'tags' ] = response [ 'tags' ] return response","title":"API and Important Information"},{"location":"usage/api/#state","text":"The state public member is a dictionary that contains objects linked to your TickTick profile. The dictionary is automatically updated and synced when changes are made through the API. state Members The lists are comprised of dictionaries that contain all the fields for each type of TickTick object: tasks, tags, etc. Member Type Contains tasks list All uncompleted task objects tags list All tag objects projects list All project objects project_folders list All project folder objects Accessing Members can be accessed by normal dictionary indexing using the member strings. # Assumes that 'client' is the name that references the TickTickClient class. uncompleted_tasks = client . state [ 'tasks' ] all_tags = client . state [ 'tags' ] Example Task Object { 'id' : '5ff24e4b8f08904035b304d9' , 'projectId' : 'inbox416323287' , 'sortOrder' : - 1099511627776 , 'title' : 'Get Groceries' , 'content' : '' , 'startDate' : '2021-05-06T21:30:00.000+0000' , 'dueDate' : '2021-05-06T21:30:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : False , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-03T23:07:55.004+0000' , 'etag' : 'ol2zesef' , 'deleted' : 0 , 'createdTime' : '2021-01-03T23:07:55.011+0000' , 'creator' : 359368200 , 'kind' : 'TEXT' }","title":"State"},{"location":"usage/api/#functionality","text":"Different functionality can be accessed through different public members of the TickTickClient instance: Functionality Method Managers Accessing the methods for each type of member is easy. It is in this format: client (or whatever name references the TickTickClient instance). manager (members in table below). method() Member Functionality task Task Methods tag Tag Methods project List Methods Example Usage # Assumes that 'client' is the name that references the TickTickClient instance. created_task = client . task . create ( 'My Created Task' ) deleted_project = client . project . delete ( project_id ) Make sure to check the individual documentation for the different method managers. Other Public Members Useful Members Member Type Description profile_id str ID assigned to your profile inbox_id str Inbox ID assigned to your profile time_zone str Timezone string linked to your TickTick profile state dict Holds all the item objects in your profile (described above) Members That Shouldn't Be Messed With Messing with these values could produce unwanted effects. Member Type Description access_token str Instance token generated by TickTick for your session. cookies dict Cookies required for your session.","title":"Functionality"},{"location":"usage/api/#useful-methods","text":"TickTickClient has a lot of helper functions in its documentation...however these should be the only of use methods to you: Tip It's recommended that you look at the documentation for these three methods to see how to obtain / delete objects from the local state dictionary - an important feature that will be useful when updating / deleting TickTick objects remotely. delete_from_local_state get_by_fields get_by_id get_by_etag","title":"Useful Methods"},{"location":"usage/api/#thats-it","text":"That's all the required information for how to get started with the library! To see how to use individual features, check these out next: Tasks Projects Tags","title":"That's It!"},{"location":"usage/api/#ticktickclient-documentation","text":"","title":"TickTickClient Documentation"},{"location":"usage/api/#api.TickTickClient","text":"","title":"TickTickClient"},{"location":"usage/api/#api.TickTickClient.__init__","text":"Initializes a client session. In order to interact with the API a successful login must occur. Parameters: Name Type Description Default username str TickTick Username required password str TickTick Password required oauth OAuth2 OAuth2 manager required Exceptions: Type Description RunTimeError If the login was not successful. Source code in ticktick/api.py def __init__ ( self , username : str , password : str , oauth : OAuth2 ) -> None : \"\"\" Initializes a client session. In order to interact with the API a successful login must occur. Arguments: username: TickTick Username password: TickTick Password oauth: OAuth2 manager Raises: RunTimeError: If the login was not successful. \"\"\" # Class members self . access_token = None self . cookies = {} self . time_zone = '' self . profile_id = '' self . inbox_id = '' self . state = {} self . reset_local_state () self . oauth_manager = oauth self . _session = self . oauth_manager . session self . _prepare_session ( username , password ) # Mangers for the different operations self . focus = FocusTimeManager ( self ) self . habit = HabitManager ( self ) self . project = ProjectManager ( self ) self . pomo = PomoManager ( self ) self . settings = SettingsManager ( self ) self . tag = TagsManager ( self ) self . task = TaskManager ( self )","title":"__init__()"},{"location":"usage/api/#api.TickTickClient.check_status_code","text":"Verifies the http response was status code 200. Parameters: Name Type Description Default response httpx Httpx response required error_message str Error message to be included with the exception required Exceptions: Type Description RuntimeError If the status code of the response was not 200. Source code in ticktick/api.py @staticmethod def check_status_code ( response , error_message : str ) -> None : \"\"\" Verifies the http response was status code 200. Arguments: response (httpx): Httpx response error_message: Error message to be included with the exception Raises: RuntimeError: If the status code of the response was not 200. \"\"\" if response . status_code != 200 : raise RuntimeError ( error_message )","title":"check_status_code()"},{"location":"usage/api/#api.TickTickClient.delete_from_local_state","text":"Deletes a single object from the local state dictionary. Does not delete any items remotely. If search is specified, it will only search the specific state list, else the entire state dictionary will be searched. Example Since each TickTick object like tasks, lists, and tags are just dictionaries of fields, we can find an object by comparing the fields. For example: Lets say that we wanted to find and delete an existing task object from our local state with the name 'Get Groceries'. To do this, we can specify the field(s) that we want to compare for in the task objects -> in this case the title 'Get Groceries'. The call to the function would look like this: # Assumes that `client` is the name referencing the TickTickClient instance. deleted_task = client . delete_from_local_state ( title = 'Get Groceries' ) deleted_task would now hold the object that was deleted from the state dictionary if it was found. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the state dictionary. # Assumes that `client` is the name referencing the TickTickClient instance. deleted_task = client . delete_from_local_state ( title = 'Get Groceries' , search = 'tasks' ) The search will now only look through tasks in state . Parameters: Name Type Description Default search str A specific item to look through in the state dictionary. When not specified the None **kwargs Matching fields in the object to look for. {} Returns: Type Description dict The dictionary of the object that was deleted. Exceptions: Type Description ValueError If no key word arguments are provided. KeyError If the search key provided is not a key in state . Source code in ticktick/api.py def delete_from_local_state ( self , search : str = None , ** kwargs ) -> dict : \"\"\" Deletes a single object from the local `state` dictionary. **Does not delete any items remotely.** If search is specified, it will only search the specific [`state`](api.md#state) list, else the entire [`state`](api.md#state) dictionary will be searched. !!! example Since each TickTick object like tasks, lists, and tags are just dictionaries of fields, we can find an object by comparing the fields. For example: Lets say that we wanted to find and delete an existing task object from our local state with the name 'Get Groceries'. To do this, we can specify the field(s) that we want to compare for in the task objects -> in this case the `title` 'Get Groceries'. The call to the function would look like this: ```python # Assumes that `client` is the name referencing the TickTickClient instance. deleted_task = client.delete_from_local_state(title='Get Groceries') ``` `deleted_task` would now hold the object that was deleted from the [`state`](api.md#state) dictionary if it was found. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the [`state`](api.md#state) dictionary. ```python # Assumes that `client` is the name referencing the TickTickClient instance. deleted_task = client.delete_from_local_state(title='Get Groceries', search='tasks') ``` The search will now only look through `tasks` in `state`. Arguments: search: A specific item to look through in the [`state`](api.md#state) dictionary. When not specified the entire [`state`](api.md#state) dictionary will be searched. **kwargs: Matching fields in the object to look for. Returns: The dictionary of the object that was deleted. Raises: ValueError: If no key word arguments are provided. KeyError: If the search key provided is not a key in [`state`](api.md#state). \"\"\" # Check that kwargs is not empty if kwargs == {}: raise ValueError ( 'Must Include Field(s) To Be Searched For' ) if search is not None and search not in self . state : raise KeyError ( f \"' { search } ' Is Not Present In self.state Dictionary\" ) # Search just in the desired list if search is not None : # Go through the state dictionary list and delete the object that matches the fields for item in range ( len ( self . state [ search ])): all_match = True for field in kwargs : if kwargs [ field ] != self . state [ search ][ item ][ field ]: all_match = False break if all_match : deleted = self . state [ search ][ item ] # Delete the item del self . state [ search ][ item ] return deleted else : # No key passed, search entire self.state dictionary # Search the first level of the state dictionary for primary_key in self . state : skip_primary_key = False all_match = True middle_key = 0 # Search the individual lists of the dictionary for middle_key in range ( len ( self . state [ primary_key ])): if skip_primary_key : break # Match the fields in the kwargs dictionary to the specific object -> if all match add index for fields in kwargs : # if the field doesn't exist, we can assume every other item in the list doesn't have the # field either -> so skip this primary_key entirely if fields not in self . state [ primary_key ][ middle_key ]: all_match = False skip_primary_key = True break if kwargs [ fields ] == self . state [ primary_key ][ middle_key ][ fields ]: all_match = True else : all_match = False if all_match : deleted = self . state [ primary_key ][ middle_key ] del self . state [ primary_key ][ middle_key ] return deleted","title":"delete_from_local_state()"},{"location":"usage/api/#api.TickTickClient.get_by_etag","text":"Returns the dictionary object of the item with the matching etag. If search is specified, it will only search the specific state list, else the entire state dictionary will be searched. Example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing the etag fields. For example: Lets get the object that corresponds to an etag referenced by my_etag . The call to the function would look like this: # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_etag ( my_etag ) found_obj would now reference the object if it was found, else it would reference an empty dictionary. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the state dictionary. # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_etag ( my_etag , search = 'projects' ) The search will now only look through projects in state . Parameters: Name Type Description Default etag str The etag of the object that you are looking for. required search str Key in state that the search should take place in. If empty the None Returns: Type Description dict The dictionary object of the item if found, or an empty dictionary if not found. Exceptions: Type Description KeyError If the search key provided is not a key in state . Source code in ticktick/api.py def get_by_etag ( self , etag : str , search : str = None ) -> dict : \"\"\" Returns the dictionary object of the item with the matching etag. If search is specified, it will only search the specific [`state`](api.md#state) list, else the entire [`state`](api.md#state) dictionary will be searched. !!! example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing the etag fields. For example: Lets get the object that corresponds to an etag referenced by `my_etag`. The call to the function would look like this: ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_etag(my_etag) ``` `found_obj` would now reference the object if it was found, else it would reference an empty dictionary. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the [`state`](api.md#state) dictionary. ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_etag(my_etag, search='projects') ``` The search will now only look through `projects` in [`state`](api.md#state). Arguments: etag: The etag of the object that you are looking for. search: Key in [`state`](#state) that the search should take place in. If empty the entire [`state`](api.md#state) dictionary will be searched. Returns: The dictionary object of the item if found, or an empty dictionary if not found. Raises: KeyError: If the search key provided is not a key in [`state`](api.md#state). \"\"\" if search is not None and search not in self . state : raise KeyError ( f \"' { search } ' Is Not Present In self.state Dictionary\" ) # Search just in the desired list if search is not None : for index in self . state [ search ]: if index [ 'etag' ] == etag : return index else : # Search all items in self.state for prim_key in self . state : for our_object in self . state [ prim_key ]: if 'etag' not in our_object : break if our_object [ 'etag' ] == etag : return our_object # Return empty dictionary if not found return {}","title":"get_by_etag()"},{"location":"usage/api/#api.TickTickClient.get_by_fields","text":"Finds and returns the objects in state that match the inputted fields. If search is specified, it will only search the specific state list, else the entire state dictionary will be searched. Example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing any fields contained in those objects. For example: Lets say we have 3 task objects that are titled 'Hello', and we want to obtain all of them. The call to the function would look like this: # Assumes that `client` is the name referencing the TickTickClient instance. found_objs = client . get_by_fields ( title = 'Hello' ) found_objs would now reference a list containing the 3 objects with titles 'Hello'. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the state dictionary. # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_fields ( title = 'Hello' , search = 'tasks' ) The search will now only look through tasks in state . Parameters: Name Type Description Default search str Key in state that the search should take place in. If empty the None **kwargs Matching fields in the object to look for. {} Returns: Type Description dict or list Single Object (dict) : The dictionary of the object. Multiple Objects (list) : A list of dictionary objects. Nothing Found (list) : Empty List Exceptions: Type Description ValueError If no key word arguments are provided. KeyError If the search key provided is not a key in state . Source code in ticktick/api.py def get_by_fields ( self , search : str = None , ** kwargs ): \"\"\" Finds and returns the objects in `state` that match the inputted fields. If search is specified, it will only search the specific [`state`](api.md#state) list, else the entire [`state`](api.md#state) dictionary will be searched. !!! example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing any fields contained in those objects. For example: Lets say we have 3 task objects that are titled 'Hello', and we want to obtain all of them. The call to the function would look like this: ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_objs = client.get_by_fields(title='Hello') ``` `found_objs` would now reference a list containing the 3 objects with titles 'Hello'. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the [`state`](#state) dictionary. ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_fields(title='Hello', search='tasks') ``` The search will now only look through `tasks` in [`state`](api.md#state). Arguments: search: Key in [`state`](api.md#state) that the search should take place in. If empty the entire [`state`](api.md#state) dictionary will be searched. **kwargs: Matching fields in the object to look for. Returns: dict or list: **Single Object (dict)**: The dictionary of the object. **Multiple Objects (list)**: A list of dictionary objects. **Nothing Found (list)**: Empty List Raises: ValueError: If no key word arguments are provided. KeyError: If the search key provided is not a key in `state`. \"\"\" if kwargs == {}: raise ValueError ( 'Must Include Field(s) To Be Searched For' ) if search is not None and search not in self . state : raise KeyError ( f \"' { search } ' Is Not Present In self.state Dictionary\" ) objects = [] if search is not None : # If a specific key was passed for self.state # Go through self.state[key_name] and see if all the fields in kwargs match # If all don't match return empty list for index in self . state [ search ]: all_match = True for field in kwargs : if kwargs [ field ] != index [ field ]: all_match = False break if all_match : objects . append ( index ) else : # No key passed, search entire self.state dictionary # Search the first level of the state dictionary for primarykey in self . state : skip_primary_key = False all_match = True middle_key = 0 # Search the individual lists of the dictionary for middle_key in range ( len ( self . state [ primarykey ])): if skip_primary_key : break # Match the fields in the kwargs dictionary to the specific object -> if all match add index for fields in kwargs : # if the field doesn't exist, we can assume every other item in the list doesn't have the # field either -> so skip this primary_key entirely if fields not in self . state [ primarykey ][ middle_key ]: all_match = False skip_primary_key = True break if kwargs [ fields ] == self . state [ primarykey ][ middle_key ][ fields ]: all_match = True else : all_match = False if all_match : objects . append ( self . state [ primarykey ][ middle_key ]) if len ( objects ) == 1 : return objects [ 0 ] else : return objects","title":"get_by_fields()"},{"location":"usage/api/#api.TickTickClient.get_by_id","text":"Returns the dictionary of the object corresponding to the passed id. If search is specified, it will only search the specific state list, else the entire state dictionary will be searched. Example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing the id fields. For example: Lets get the object that corresponds to an id referenced by my_id . The call to the function would look like this: # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_id ( my_id ) found_obj would now reference the object if it was found, else it would reference an empty dictionary. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the state dictionary. # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_id ( my_id , search = 'projects' ) The search will now only look through projects in state . Parameters: Name Type Description Default obj_id str Id of the item. required search str Key in state that the search should take place in. If empty the None Returns: Type Description dict The dictionary object of the item if found, or an empty dictionary if not found. Exceptions: Type Description KeyError If the search key provided is not a key in state . Source code in ticktick/api.py def get_by_id ( self , obj_id : str , search : str = None ) -> dict : \"\"\" Returns the dictionary of the object corresponding to the passed id. If search is specified, it will only search the specific [`state`](api.md#state) list, else the entire [`state`](api.md#state) dictionary will be searched. !!! example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing the id fields. For example: Lets get the object that corresponds to an id referenced by `my_id`. The call to the function would look like this: ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_id(my_id) ``` `found_obj` would now reference the object if it was found, else it would reference an empty dictionary. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the [`state`](api.md#state) dictionary. ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_id(my_id, search='projects') ``` The search will now only look through `projects` in [`state`](api.md#state). Arguments: obj_id: Id of the item. search: Key in [`state`](api.md#state) that the search should take place in. If empty the entire [`state`](api.md#state) dictionary will be searched. Returns: The dictionary object of the item if found, or an empty dictionary if not found. Raises: KeyError: If the search key provided is not a key in [`state`](api.md#state). \"\"\" if search is not None and search not in self . state : raise KeyError ( f \"' { search } ' Is Not Present In self.state Dictionary\" ) # Search just in the desired list if search is not None : for index in self . state [ search ]: if index [ 'id' ] == obj_id : return index else : # Search all items in self.state for prim_key in self . state : for our_object in self . state [ prim_key ]: if 'id' not in our_object : break if our_object [ 'id' ] == obj_id : return our_object # Return empty dictionary if not found return {}","title":"get_by_id()"},{"location":"usage/api/#api.TickTickClient.http_delete","text":"Sends an http delete request with the specified url and keyword arguments. Parameters: Name Type Description Default url str Url to send the request. required **kwargs Arguments to send with the request. {} Returns: Type Description dict The json parsed response if possible or just a string of the response text if not. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def http_delete ( self , url , ** kwargs ): \"\"\" Sends an http delete request with the specified url and keyword arguments. Arguments: url (str): Url to send the request. **kwargs: Arguments to send with the request. Returns: dict: The json parsed response if possible or just a string of the response text if not. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . _session . delete ( url , ** kwargs ) self . check_status_code ( response , 'Could Not Complete Request' ) try : return response . json () except ValueError : return response . text","title":"http_delete()"},{"location":"usage/api/#api.TickTickClient.http_get","text":"Sends an http get request with the specified url and keyword arguments. Parameters: Name Type Description Default url str Url to send the request. required **kwargs Arguments to send with the request. {} Returns: Type Description dict The json parsed response if possible or just a string of the response text if not. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def http_get ( self , url , ** kwargs ): \"\"\" Sends an http get request with the specified url and keyword arguments. Arguments: url (str): Url to send the request. **kwargs: Arguments to send with the request. Returns: dict: The json parsed response if possible or just a string of the response text if not. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . _session . get ( url , ** kwargs ) self . check_status_code ( response , 'Could Not Complete Request' ) try : return response . json () except ValueError : return response . text","title":"http_get()"},{"location":"usage/api/#api.TickTickClient.http_post","text":"Sends an http post request with the specified url and keyword arguments. Parameters: Name Type Description Default url str Url to send the request. required **kwargs Arguments to send with the request. {} Returns: Type Description dict The json parsed response if possible or just a string of the response text if not. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def http_post ( self , url , ** kwargs ): \"\"\" Sends an http post request with the specified url and keyword arguments. Arguments: url (str): Url to send the request. **kwargs: Arguments to send with the request. Returns: dict: The json parsed response if possible or just a string of the response text if not. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . _session . post ( url , ** kwargs ) self . check_status_code ( response , 'Could Not Complete Request' ) try : return response . json () except ValueError : return response . text","title":"http_post()"},{"location":"usage/api/#api.TickTickClient.http_put","text":"Sends an http put request with the specified url and keyword arguments. Parameters: Name Type Description Default url str Url to send the request. required **kwargs Arguments to send with the request. {} Returns: Type Description dict The json parsed response if possible or just a string of the response text if not. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def http_put ( self , url , ** kwargs ): \"\"\" Sends an http put request with the specified url and keyword arguments. Arguments: url (str): Url to send the request. **kwargs: Arguments to send with the request. Returns: dict: The json parsed response if possible or just a string of the response text if not. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . _session . put ( url , ** kwargs ) self . check_status_code ( response , 'Could Not Complete Request' ) try : return response . json () except ValueError : return response . text","title":"http_put()"},{"location":"usage/api/#api.TickTickClient.parse_etag","text":"Parses the etag of a successful creation of a tag object. Info The response from TickTick upon a successful tag creation is in this form: {\"id2etag\":{\"MyTag\":\"vxzpwo38\"},\"id2error\":{}} We want to obtain \"vxzpwo38\" in this example - the etag of the object. Parameters: Name Type Description Default response dict Dictionary from the successful creation of a tag object required multiple bool Specifies whether there are multiple etags to return. False Returns: Type Description str A single etag string if not multiple, or a list of etag strings if multiple. Source code in ticktick/api.py @staticmethod def parse_etag ( response : dict , multiple : bool = False ) -> str : \"\"\" Parses the etag of a successful creation of a tag object. !!! info The response from TickTick upon a successful tag creation is in this form: ```md {\"id2etag\":{\"MyTag\":\"vxzpwo38\"},\"id2error\":{}} ``` We want to obtain \"vxzpwo38\" in this example - the etag of the object. Arguments: response: Dictionary from the successful creation of a tag object multiple: Specifies whether there are multiple etags to return. Return: A single etag string if not multiple, or a list of etag strings if multiple. \"\"\" etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) if not multiple : return etag [ etag2 [ 0 ]] else : etags = [] for key in range ( len ( etag2 )): etags . append ( etag [ etag2 [ key ]]) return etags","title":"parse_etag()"},{"location":"usage/api/#api.TickTickClient.parse_id","text":"Parses the Id of a successful creation of a TickTick object. Info The response from the TickTick servers is in this form: {'id2etag': {'5ff2bcf68f08093e5b745a30': '3okkc2xm'}, 'id2error': {}} We want to obtain '5ff2bcf68f08093e5b745a30' in this example - the id of the object. Parameters: Name Type Description Default response dict Dictionary containing the Dd from the TickTick servers. required Returns: Type Description str Id string of the object. Source code in ticktick/api.py @staticmethod def parse_id ( response : dict ) -> str : \"\"\" Parses the Id of a successful creation of a TickTick object. !!! info The response from the TickTick servers is in this form: ```md {'id2etag': {'5ff2bcf68f08093e5b745a30': '3okkc2xm'}, 'id2error': {}} ``` We want to obtain '5ff2bcf68f08093e5b745a30' in this example - the id of the object. Arguments: response: Dictionary containing the Dd from the TickTick servers. Returns: Id string of the object. \"\"\" id_tag = response [ 'id2etag' ] id_tag = list ( id_tag . keys ()) return id_tag [ 0 ]","title":"parse_id()"},{"location":"usage/api/#api.TickTickClient.reset_local_state","text":"Resets the contents of the items in the state dictionary. Source code in ticktick/api.py def reset_local_state ( self ): \"\"\" Resets the contents of the items in the [`state`](api.md#state) dictionary. \"\"\" self . state = { 'projects' : [], 'project_folders' : [], 'tags' : [], 'tasks' : [], 'user_settings' : {}, 'profile' : {} }","title":"reset_local_state()"},{"location":"usage/api/#api.TickTickClient.sync","text":"Populates the TickTickClient state dictionary with the contents of your account. This method is called when necessary by other methods and does not need to be explicitly called. Returns: Type Description httpx The response from the get request. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def sync ( self ): \"\"\" Populates the `TickTickClient` [`state`](api.md#state) dictionary with the contents of your account. **This method is called when necessary by other methods and does not need to be explicitly called.** Returns: httpx: The response from the get request. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . http_get ( self . INITIAL_BATCH_URL , cookies = self . cookies , headers = self . HEADERS ) # Inbox Id self . inbox_id = response [ 'inboxId' ] # Set list groups self . state [ 'project_folders' ] = response [ 'projectGroups' ] # Set lists self . state [ 'projects' ] = response [ 'projectProfiles' ] # Set Uncompleted Tasks self . state [ 'tasks' ] = response [ 'syncTaskBean' ][ 'update' ] # Set tags self . state [ 'tags' ] = response [ 'tags' ] return response","title":"sync()"},{"location":"usage/helpers/","text":"Other Useful Methods and Info \u00b6 Time Zones \u00b6 Source For a list of timezone strings, see List of tz database time zones Acceptable Time Zone names are found under the 'TZ database name' column. time_methods \u00b6 Useful time conversion methods. convert_date_to_tick_tick_format ( datetime_obj , tz ) \u00b6 Parses ISO 8601 Format to Tick Tick Date Format It first converts the datetime object to UTC time based off the passed time zone, and then returns a string with the TickTick required date format. Info ISO 8601 Format Example: 2020-12-23T01:56:07+00:00 TickTick Required Format: 2020-12-23T01:56:07+0000 -> Where the last colon is removed for timezone Parameters: Name Type Description Default datetime_obj datetime Datetime object to be parsed. required tz str Time zone string. required Returns: Type Description str The TickTick accepted date string. Import Help from ticktick.helpers.time_methods import convert_iso_to_tick_tick_format Example date = datetime ( 2022 , 12 , 31 , 14 , 30 , 45 ) converted_date = convert_iso_to_tick_tick_format ( date , 'US/Pacific' ) Result The proper format for a date string to be used with TickTick dates. '2022-12-31T22:30:45+0000' Source code in helpers/time_methods.py def convert_date_to_tick_tick_format ( datetime_obj , tz : str ): \"\"\" Parses ISO 8601 Format to Tick Tick Date Format It first converts the datetime object to UTC time based off the passed time zone, and then returns a string with the TickTick required date format. !!! info Required Format ISO 8601 Format Example: 2020-12-23T01:56:07+00:00 TickTick Required Format: 2020-12-23T01:56:07+0000 -> Where the last colon is removed for timezone Arguments: datetime_obj (datetime): Datetime object to be parsed. tz: Time zone string. Returns: str: The TickTick accepted date string. ??? info \"Import Help\" ```python from ticktick.helpers.time_methods import convert_iso_to_tick_tick_format ``` ??? example ```python date = datetime(2022, 12, 31, 14, 30, 45) converted_date = convert_iso_to_tick_tick_format(date, 'US/Pacific') ``` ??? success \"Result\" The proper format for a date string to be used with TickTick dates. ```python '2022-12-31T22:30:45+0000' ``` \"\"\" date = convert_local_time_to_utc ( datetime_obj , tz ) date = date . replace ( tzinfo = datetime . timezone . utc ) . isoformat () date = date [:: - 1 ] . replace ( \":\" , \"\" , 1 )[:: - 1 ] return date convert_local_time_to_utc ( original_time , time_zone ) \u00b6 Converts the datetime object to UTC time. Utilizes the time_zone string for proper conversion. Parameters: Name Type Description Default original_time datetime Datetime object required time_zone str Time zone of original_time required Returns: Type Description datetime Datetime object with the converted UTC time - with no timezone information attached. Import Help from ticktick.helpers.time_methods import convert_local_time_to_utc Example pst = datetime ( 2020 , 12 , 11 , 23 , 59 ) converted = convert_local_time_to_utc ( pst , 'US/Pacific' ) Result A datetime object that is the UTC equivalent of the original date. datetime ( 2020 , 12 , 12 , 7 , 59 ) Source code in helpers/time_methods.py def convert_local_time_to_utc ( original_time , time_zone : str ): \"\"\" Converts the datetime object to UTC time. Utilizes the time_zone string for proper conversion. Arguments: original_time (datetime): Datetime object time_zone: Time zone of `original_time` Returns: datetime: Datetime object with the converted UTC time - with no timezone information attached. ??? info \"Import Help\" ```python from ticktick.helpers.time_methods import convert_local_time_to_utc ``` ??? Example ```python pst = datetime(2020, 12, 11, 23, 59) converted = convert_local_time_to_utc(pst, 'US/Pacific') ``` ??? success \"Result\" A datetime object that is the UTC equivalent of the original date. ```python datetime(2020, 12, 12, 7, 59) ``` \"\"\" utc = pytz . utc time_zone = pytz . timezone ( time_zone ) original_time = original_time . strftime ( DATE_FORMAT ) time_object = datetime . datetime . strptime ( original_time , DATE_FORMAT ) time_zone_dt = time_zone . localize ( time_object ) return time_zone_dt . astimezone ( utc ) . replace ( tzinfo = None ) hex_color \u00b6 Provides some methods for dealing with hex color code strings. check_hex_color ( color ) \u00b6 Verifies if the passed in color string is a valid hexadecimal color string Parameters: Name Type Description Default color str String to check. required Returns: Type Description bool True if the string is a valid hex code, else False. Import Help from ticktick.helpers.hex_color import check_hex_color Source code in helpers/hex_color.py def check_hex_color ( color : str ) -> bool : \"\"\" Verifies if the passed in color string is a valid hexadecimal color string Arguments: color: String to check. Returns: True if the string is a valid hex code, else False. ??? info \"Import Help\" ```python from ticktick.helpers.hex_color import check_hex_color ``` \"\"\" check_color = re . search ( VALID_HEX_VALUES , color ) if not check_color : return False else : return True generate_hex_color () \u00b6 Generates a random hexadecimal color string to be used for rgb color schemes. Returns: Type Description str '#' followed by 6 hexadecimal digits. Import Help from ticktick.helpers.hex_color import generate_hex_color Source code in helpers/hex_color.py def generate_hex_color () -> str : \"\"\" Generates a random hexadecimal color string to be used for rgb color schemes. Returns: '#' followed by 6 hexadecimal digits. ??? info \"Import Help\" ```python from ticktick.helpers.hex_color import generate_hex_color ``` \"\"\" num = random . randint ( 1118481 , 16777215 ) hex_num = format ( num , 'x' ) return '#' + hex_num","title":"Helpers"},{"location":"usage/helpers/#other-useful-methods-and-info","text":"","title":"Other Useful Methods and Info"},{"location":"usage/helpers/#time-zones","text":"Source For a list of timezone strings, see List of tz database time zones Acceptable Time Zone names are found under the 'TZ database name' column.","title":"Time Zones"},{"location":"usage/helpers/#time_methods","text":"Useful time conversion methods.","title":"time_methods"},{"location":"usage/helpers/#helpers.time_methods.convert_date_to_tick_tick_format","text":"Parses ISO 8601 Format to Tick Tick Date Format It first converts the datetime object to UTC time based off the passed time zone, and then returns a string with the TickTick required date format. Info ISO 8601 Format Example: 2020-12-23T01:56:07+00:00 TickTick Required Format: 2020-12-23T01:56:07+0000 -> Where the last colon is removed for timezone Parameters: Name Type Description Default datetime_obj datetime Datetime object to be parsed. required tz str Time zone string. required Returns: Type Description str The TickTick accepted date string. Import Help from ticktick.helpers.time_methods import convert_iso_to_tick_tick_format Example date = datetime ( 2022 , 12 , 31 , 14 , 30 , 45 ) converted_date = convert_iso_to_tick_tick_format ( date , 'US/Pacific' ) Result The proper format for a date string to be used with TickTick dates. '2022-12-31T22:30:45+0000' Source code in helpers/time_methods.py def convert_date_to_tick_tick_format ( datetime_obj , tz : str ): \"\"\" Parses ISO 8601 Format to Tick Tick Date Format It first converts the datetime object to UTC time based off the passed time zone, and then returns a string with the TickTick required date format. !!! info Required Format ISO 8601 Format Example: 2020-12-23T01:56:07+00:00 TickTick Required Format: 2020-12-23T01:56:07+0000 -> Where the last colon is removed for timezone Arguments: datetime_obj (datetime): Datetime object to be parsed. tz: Time zone string. Returns: str: The TickTick accepted date string. ??? info \"Import Help\" ```python from ticktick.helpers.time_methods import convert_iso_to_tick_tick_format ``` ??? example ```python date = datetime(2022, 12, 31, 14, 30, 45) converted_date = convert_iso_to_tick_tick_format(date, 'US/Pacific') ``` ??? success \"Result\" The proper format for a date string to be used with TickTick dates. ```python '2022-12-31T22:30:45+0000' ``` \"\"\" date = convert_local_time_to_utc ( datetime_obj , tz ) date = date . replace ( tzinfo = datetime . timezone . utc ) . isoformat () date = date [:: - 1 ] . replace ( \":\" , \"\" , 1 )[:: - 1 ] return date","title":"convert_date_to_tick_tick_format()"},{"location":"usage/helpers/#helpers.time_methods.convert_local_time_to_utc","text":"Converts the datetime object to UTC time. Utilizes the time_zone string for proper conversion. Parameters: Name Type Description Default original_time datetime Datetime object required time_zone str Time zone of original_time required Returns: Type Description datetime Datetime object with the converted UTC time - with no timezone information attached. Import Help from ticktick.helpers.time_methods import convert_local_time_to_utc Example pst = datetime ( 2020 , 12 , 11 , 23 , 59 ) converted = convert_local_time_to_utc ( pst , 'US/Pacific' ) Result A datetime object that is the UTC equivalent of the original date. datetime ( 2020 , 12 , 12 , 7 , 59 ) Source code in helpers/time_methods.py def convert_local_time_to_utc ( original_time , time_zone : str ): \"\"\" Converts the datetime object to UTC time. Utilizes the time_zone string for proper conversion. Arguments: original_time (datetime): Datetime object time_zone: Time zone of `original_time` Returns: datetime: Datetime object with the converted UTC time - with no timezone information attached. ??? info \"Import Help\" ```python from ticktick.helpers.time_methods import convert_local_time_to_utc ``` ??? Example ```python pst = datetime(2020, 12, 11, 23, 59) converted = convert_local_time_to_utc(pst, 'US/Pacific') ``` ??? success \"Result\" A datetime object that is the UTC equivalent of the original date. ```python datetime(2020, 12, 12, 7, 59) ``` \"\"\" utc = pytz . utc time_zone = pytz . timezone ( time_zone ) original_time = original_time . strftime ( DATE_FORMAT ) time_object = datetime . datetime . strptime ( original_time , DATE_FORMAT ) time_zone_dt = time_zone . localize ( time_object ) return time_zone_dt . astimezone ( utc ) . replace ( tzinfo = None )","title":"convert_local_time_to_utc()"},{"location":"usage/helpers/#hex_color","text":"Provides some methods for dealing with hex color code strings.","title":"hex_color"},{"location":"usage/helpers/#helpers.hex_color.check_hex_color","text":"Verifies if the passed in color string is a valid hexadecimal color string Parameters: Name Type Description Default color str String to check. required Returns: Type Description bool True if the string is a valid hex code, else False. Import Help from ticktick.helpers.hex_color import check_hex_color Source code in helpers/hex_color.py def check_hex_color ( color : str ) -> bool : \"\"\" Verifies if the passed in color string is a valid hexadecimal color string Arguments: color: String to check. Returns: True if the string is a valid hex code, else False. ??? info \"Import Help\" ```python from ticktick.helpers.hex_color import check_hex_color ``` \"\"\" check_color = re . search ( VALID_HEX_VALUES , color ) if not check_color : return False else : return True","title":"check_hex_color()"},{"location":"usage/helpers/#helpers.hex_color.generate_hex_color","text":"Generates a random hexadecimal color string to be used for rgb color schemes. Returns: Type Description str '#' followed by 6 hexadecimal digits. Import Help from ticktick.helpers.hex_color import generate_hex_color Source code in helpers/hex_color.py def generate_hex_color () -> str : \"\"\" Generates a random hexadecimal color string to be used for rgb color schemes. Returns: '#' followed by 6 hexadecimal digits. ??? info \"Import Help\" ```python from ticktick.helpers.hex_color import generate_hex_color ``` \"\"\" num = random . randint ( 1118481 , 16777215 ) hex_num = format ( num , 'x' ) return '#' + hex_num","title":"generate_hex_color()"},{"location":"usage/oauth2/","text":"Important See Get Started for information on how to register a new app with TickTick OAuth2 \u00b6 Implements the Authorization flow for TickTick's Open API __init__ ( self , client_id , client_secret , redirect_uri , scope = 'tasks:write tasks:read' , state = None , session = None , env_key = None , cache_path = '.token-oauth' , check_cache = True ) special \u00b6 Initialize the object. Parameters: Name Type Description Default client_id str Client ID string required client_secret str Client secret string required redirect_uri str Redirect uri required scope str Scope for the permissions. Current options are only the default. 'tasks:write tasks:read' state str State parameter None session requests session Requests session None env_key str The environment variable name where the access token dictionary is stored as a string literal. None cache_path str The desired path of the file where the access token information will be stored. '.token-oauth' check_cache bool Whether to check the cache file for the access token information True Examples Standard Method This way would instantiate the steps to get a new access token, or just retrieve the cached one. oauth = OAuth2 ( client_id = cliend_id , client_secret = client_secret , redirect_uri = redirect_uri ) Check Environment Method If you are in a situation where you don't want to keep the cached token file, you can save the access token dictionary as a string literal in your environment, and pass the name of the variable to prevent having to request a new access token. auth_client = OAuth2 ( client_id = client_id , client_secret = client_secret , redirect_uri = redirect_uri , env_key = 'ACCESS_TOKEN_DICT' ) Where in the environment you have declared ACCESS_TOKEN_DICT to be the string literal of the token dictionary: '{'access_token': '628ff081-5331-4a37-8ddk-021974c9f43g', 'token_type': 'bearer', 'expires_in': 14772375, 'scope': 'tasks:read tasks:write', 'expire_time': 1637192935, 'readable_expire_time': 'Wed Nov 17 15:48:55 2021'}' Source code in ticktick/oauth2.py def __init__ ( self , client_id : str , client_secret : str , redirect_uri : str , scope : str = \"tasks:write tasks:read\" , # only available options right now state : str = None , session = None , env_key : str = None , cache_path : str = '.token-oauth' , check_cache : bool = True ): \"\"\" Initialize the object. Arguments: client_id: Client ID string client_secret: Client secret string redirect_uri: Redirect uri scope: Scope for the permissions. Current options are only the default. state (str): State parameter session (requests session): Requests session env_key: The environment variable name where the access token dictionary is stored as a string literal. cache_path: The desired path of the file where the access token information will be stored. check_cache: Whether to check the cache file for the access token information !!! examples === \"Standard Method\" This way would instantiate the steps to get a new access token, or just retrieve the cached one. ```python oauth = OAuth2(client_id=cliend_id, client_secret=client_secret, redirect_uri=redirect_uri) ``` === \"Check Environment Method\" If you are in a situation where you don't want to keep the cached token file, you can save the access token dictionary as a string literal in your environment, and pass the name of the variable to prevent having to request a new access token. ``` python auth_client = OAuth2(client_id=client_id, client_secret=client_secret, redirect_uri=redirect_uri, env_key='ACCESS_TOKEN_DICT') ``` Where in the environment you have declared `ACCESS_TOKEN_DICT` to be the string literal of the token dictionary: ``` '{'access_token': '628ff081-5331-4a37-8ddk-021974c9f43g', 'token_type': 'bearer', 'expires_in': 14772375, 'scope': 'tasks:read tasks:write', 'expire_time': 1637192935, 'readable_expire_time': 'Wed Nov 17 15:48:55 2021'}' ``` \"\"\" # If a proper session is passed then we will just use the existing session self . session = session or requests_retry_session () # Set the client_id self . _client_id = client_id # Set the client_secret self . _client_secret = client_secret # Set the redirect_uri self . _redirect_uri = redirect_uri # Set the scope self . _scope = scope # Set the state self . _state = state # Initialize code parameter self . _code = None # Set the cache handler self . cache = CacheHandler ( cache_path ) # Set the access token self . access_token_info = None # get access token self . get_access_token ( check_cache = check_cache , check_env = env_key ) get_access_token ( self , check_cache = True , check_env = None ) \u00b6 Retrieves the authorization token from cache or makes a new request for it. Note This method does not need to be called explicitly. Parameters: Name Type Description Default check_cache bool Boolean on whether to check if the access token is in a cache file. True check_env str The environment variable name where the token dictionary is saved as a string literal. None Priority order for getting the access token: 1) From an already set class member in the current running instance 2) From an environment variable where the token dictionary is in a string literal form, and the name of the environment variable name is the value passed to the \"check_env\" parameter 3) From a cache file that contains the access token dictionary (normal case) 4) From a new token request (which will create a new cache file that contains the access token dictionary) (initial case if never setup) Source code in ticktick/oauth2.py def get_access_token ( self , check_cache : bool = True , check_env : str = None ): \"\"\" Retrieves the authorization token from cache or makes a new request for it. !!! note This method does not need to be called explicitly. Arguments: check_cache (bool): Boolean on whether to check if the access token is in a cache file. check_env (str): The environment variable name where the token dictionary is saved as a string literal. Priority order for getting the access token: 1) From an already set class member in the current running instance 2) From an environment variable where the token dictionary is in a string literal form, and the name of the environment variable name is the value passed to the \"check_env\" parameter 3) From a cache file that contains the access token dictionary (normal case) 4) From a new token request (which will create a new cache file that contains the access token dictionary) (initial case if never setup) \"\"\" # check the local state for if the access token exists if self . access_token_info is not None : token_info = self . validate_token ( self . access_token_info ) if token_info is not None : self . access_token_info = token_info return token_info [ \"access_token\" ] # check if in the environment the access token is set if check_env is not None : # get the access token string token_dict_string = os . getenv ( check_env ) try : converted_token_dict = ast . literal_eval ( token_dict_string ) except : raise ValueError ( \"Access token in the environment must be a python dictionary contained\" \" in a string literal\" ) token_info = self . validate_token ( converted_token_dict ) if token_info is not None : self . cache . write_token_to_cache ( token_info ) self . access_token_info = token_info return token_info [ \"access_token\" ] # check if the cache file exists with the token if check_cache : token_info = self . validate_token ( self . cache . get_cached_token ()) # validate token will always return a valid token if token_info is not None : self . access_token_info = token_info return token_info [ \"access_token\" ] # access token is not stored anywhere, request a new token token_info = self . _request_access_token () self . access_token_info = token_info return token_info [ \"access_token\" ] is_token_expired ( token_dict ) staticmethod \u00b6 Returns a boolean for if the access token is expired Parameters: Name Type Description Default token_dict dict Access token dictionary required Returns: Type Description bool Whether the access token is expired Source code in ticktick/oauth2.py @staticmethod def is_token_expired ( token_dict ): \"\"\" Returns a boolean for if the access token is expired Arguments: token_dict (dict): Access token dictionary Returns: bool: Whether the access token is expired \"\"\" current_time = int ( time . time ()) return token_dict [ \"expire_time\" ] - current_time < 60 validate_token ( self , token_dict ) \u00b6 Validates whether the access token is valid Parameters: Name Type Description Default token_dict dict Access token dictionary required Returns: Type Description None or dict None if the token_dict is not valid, else token_dict Source code in ticktick/oauth2.py def validate_token ( self , token_dict ): \"\"\" Validates whether the access token is valid Arguments: token_dict (dict): Access token dictionary Returns: None or dict: None if the token_dict is not valid, else token_dict \"\"\" # if the token info dictionary does not exist then bounce if token_dict is None : return None # check if the token is expired if self . is_token_expired ( token_dict ): # make a new request for a valid token since there is currently no refresh token new_token_dict = self . _request_access_token () return new_token_dict return token_dict # original token_dict is valid requests_retry_session ( retries = 3 , backoff_factor = 1 , status_forcelist = ( 405 , 500 , 502 , 504 ), session = None , allowed_methods = frozenset ({ 'PUT' , 'DELETE' , 'POST' , 'GET' })) \u00b6 Method for http retries Source code in ticktick/oauth2.py def requests_retry_session ( retries = 3 , backoff_factor = 1 , status_forcelist = ( 405 , 500 , 502 , 504 ), session = None , allowed_methods = frozenset ([ 'GET' , 'POST' , 'PUT' , 'DELETE' ])): \"\"\" Method for http retries \"\"\" session = session or requests . session () retry = Retry ( total = retries , read = retries , connect = retries , backoff_factor = backoff_factor , status_forcelist = status_forcelist , allowed_methods = allowed_methods ) adapter = HTTPAdapter ( max_retries = retry ) session . mount ( 'http://' , adapter ) session . mount ( 'https://' , adapter ) return session","title":"Authorization"},{"location":"usage/oauth2/#oauth2.OAuth2","text":"Implements the Authorization flow for TickTick's Open API","title":"OAuth2"},{"location":"usage/oauth2/#oauth2.OAuth2.__init__","text":"Initialize the object. Parameters: Name Type Description Default client_id str Client ID string required client_secret str Client secret string required redirect_uri str Redirect uri required scope str Scope for the permissions. Current options are only the default. 'tasks:write tasks:read' state str State parameter None session requests session Requests session None env_key str The environment variable name where the access token dictionary is stored as a string literal. None cache_path str The desired path of the file where the access token information will be stored. '.token-oauth' check_cache bool Whether to check the cache file for the access token information True Examples Standard Method This way would instantiate the steps to get a new access token, or just retrieve the cached one. oauth = OAuth2 ( client_id = cliend_id , client_secret = client_secret , redirect_uri = redirect_uri ) Check Environment Method If you are in a situation where you don't want to keep the cached token file, you can save the access token dictionary as a string literal in your environment, and pass the name of the variable to prevent having to request a new access token. auth_client = OAuth2 ( client_id = client_id , client_secret = client_secret , redirect_uri = redirect_uri , env_key = 'ACCESS_TOKEN_DICT' ) Where in the environment you have declared ACCESS_TOKEN_DICT to be the string literal of the token dictionary: '{'access_token': '628ff081-5331-4a37-8ddk-021974c9f43g', 'token_type': 'bearer', 'expires_in': 14772375, 'scope': 'tasks:read tasks:write', 'expire_time': 1637192935, 'readable_expire_time': 'Wed Nov 17 15:48:55 2021'}' Source code in ticktick/oauth2.py def __init__ ( self , client_id : str , client_secret : str , redirect_uri : str , scope : str = \"tasks:write tasks:read\" , # only available options right now state : str = None , session = None , env_key : str = None , cache_path : str = '.token-oauth' , check_cache : bool = True ): \"\"\" Initialize the object. Arguments: client_id: Client ID string client_secret: Client secret string redirect_uri: Redirect uri scope: Scope for the permissions. Current options are only the default. state (str): State parameter session (requests session): Requests session env_key: The environment variable name where the access token dictionary is stored as a string literal. cache_path: The desired path of the file where the access token information will be stored. check_cache: Whether to check the cache file for the access token information !!! examples === \"Standard Method\" This way would instantiate the steps to get a new access token, or just retrieve the cached one. ```python oauth = OAuth2(client_id=cliend_id, client_secret=client_secret, redirect_uri=redirect_uri) ``` === \"Check Environment Method\" If you are in a situation where you don't want to keep the cached token file, you can save the access token dictionary as a string literal in your environment, and pass the name of the variable to prevent having to request a new access token. ``` python auth_client = OAuth2(client_id=client_id, client_secret=client_secret, redirect_uri=redirect_uri, env_key='ACCESS_TOKEN_DICT') ``` Where in the environment you have declared `ACCESS_TOKEN_DICT` to be the string literal of the token dictionary: ``` '{'access_token': '628ff081-5331-4a37-8ddk-021974c9f43g', 'token_type': 'bearer', 'expires_in': 14772375, 'scope': 'tasks:read tasks:write', 'expire_time': 1637192935, 'readable_expire_time': 'Wed Nov 17 15:48:55 2021'}' ``` \"\"\" # If a proper session is passed then we will just use the existing session self . session = session or requests_retry_session () # Set the client_id self . _client_id = client_id # Set the client_secret self . _client_secret = client_secret # Set the redirect_uri self . _redirect_uri = redirect_uri # Set the scope self . _scope = scope # Set the state self . _state = state # Initialize code parameter self . _code = None # Set the cache handler self . cache = CacheHandler ( cache_path ) # Set the access token self . access_token_info = None # get access token self . get_access_token ( check_cache = check_cache , check_env = env_key )","title":"__init__()"},{"location":"usage/oauth2/#oauth2.OAuth2.get_access_token","text":"Retrieves the authorization token from cache or makes a new request for it. Note This method does not need to be called explicitly. Parameters: Name Type Description Default check_cache bool Boolean on whether to check if the access token is in a cache file. True check_env str The environment variable name where the token dictionary is saved as a string literal. None Priority order for getting the access token: 1) From an already set class member in the current running instance 2) From an environment variable where the token dictionary is in a string literal form, and the name of the environment variable name is the value passed to the \"check_env\" parameter 3) From a cache file that contains the access token dictionary (normal case) 4) From a new token request (which will create a new cache file that contains the access token dictionary) (initial case if never setup) Source code in ticktick/oauth2.py def get_access_token ( self , check_cache : bool = True , check_env : str = None ): \"\"\" Retrieves the authorization token from cache or makes a new request for it. !!! note This method does not need to be called explicitly. Arguments: check_cache (bool): Boolean on whether to check if the access token is in a cache file. check_env (str): The environment variable name where the token dictionary is saved as a string literal. Priority order for getting the access token: 1) From an already set class member in the current running instance 2) From an environment variable where the token dictionary is in a string literal form, and the name of the environment variable name is the value passed to the \"check_env\" parameter 3) From a cache file that contains the access token dictionary (normal case) 4) From a new token request (which will create a new cache file that contains the access token dictionary) (initial case if never setup) \"\"\" # check the local state for if the access token exists if self . access_token_info is not None : token_info = self . validate_token ( self . access_token_info ) if token_info is not None : self . access_token_info = token_info return token_info [ \"access_token\" ] # check if in the environment the access token is set if check_env is not None : # get the access token string token_dict_string = os . getenv ( check_env ) try : converted_token_dict = ast . literal_eval ( token_dict_string ) except : raise ValueError ( \"Access token in the environment must be a python dictionary contained\" \" in a string literal\" ) token_info = self . validate_token ( converted_token_dict ) if token_info is not None : self . cache . write_token_to_cache ( token_info ) self . access_token_info = token_info return token_info [ \"access_token\" ] # check if the cache file exists with the token if check_cache : token_info = self . validate_token ( self . cache . get_cached_token ()) # validate token will always return a valid token if token_info is not None : self . access_token_info = token_info return token_info [ \"access_token\" ] # access token is not stored anywhere, request a new token token_info = self . _request_access_token () self . access_token_info = token_info return token_info [ \"access_token\" ]","title":"get_access_token()"},{"location":"usage/oauth2/#oauth2.OAuth2.is_token_expired","text":"Returns a boolean for if the access token is expired Parameters: Name Type Description Default token_dict dict Access token dictionary required Returns: Type Description bool Whether the access token is expired Source code in ticktick/oauth2.py @staticmethod def is_token_expired ( token_dict ): \"\"\" Returns a boolean for if the access token is expired Arguments: token_dict (dict): Access token dictionary Returns: bool: Whether the access token is expired \"\"\" current_time = int ( time . time ()) return token_dict [ \"expire_time\" ] - current_time < 60","title":"is_token_expired()"},{"location":"usage/oauth2/#oauth2.OAuth2.validate_token","text":"Validates whether the access token is valid Parameters: Name Type Description Default token_dict dict Access token dictionary required Returns: Type Description None or dict None if the token_dict is not valid, else token_dict Source code in ticktick/oauth2.py def validate_token ( self , token_dict ): \"\"\" Validates whether the access token is valid Arguments: token_dict (dict): Access token dictionary Returns: None or dict: None if the token_dict is not valid, else token_dict \"\"\" # if the token info dictionary does not exist then bounce if token_dict is None : return None # check if the token is expired if self . is_token_expired ( token_dict ): # make a new request for a valid token since there is currently no refresh token new_token_dict = self . _request_access_token () return new_token_dict return token_dict # original token_dict is valid","title":"validate_token()"},{"location":"usage/oauth2/#oauth2.requests_retry_session","text":"Method for http retries Source code in ticktick/oauth2.py def requests_retry_session ( retries = 3 , backoff_factor = 1 , status_forcelist = ( 405 , 500 , 502 , 504 ), session = None , allowed_methods = frozenset ([ 'GET' , 'POST' , 'PUT' , 'DELETE' ])): \"\"\" Method for http retries \"\"\" session = session or requests . session () retry = Retry ( total = retries , read = retries , connect = retries , backoff_factor = backoff_factor , status_forcelist = status_forcelist , allowed_methods = allowed_methods ) adapter = HTTPAdapter ( max_retries = retry ) session . mount ( 'http://' , adapter ) session . mount ( 'https://' , adapter ) return session","title":"requests_retry_session()"},{"location":"usage/projects/","text":"Important Projects within TickTick are known as Lists . However, in the API Lists are referred to as Projects to limit confusion with the list built in type. Info Project methods are accessed through the project public member of your TickTickClient instance. # Assumes that 'client' is the name that references the TickTickClient instance. project = client . project . method () Question About Logging In or Other Functionality Available? API and Important Information Tip All supported methods are documented below with usage examples, take a look! All usage examples assume that client is the name referencing the TickTickClient instance Example TickTick Project Dictionary \u00b6 Members Descriptions It is possible that not all possible fields are present in the table. Property Description Example Value Type Useful Values id The ID of the project '5ffe93f3b04b35082bbce7b0' str N/A name The name of the project 'Hobbies' str N/A isOwner Whether you are the owner of the project or not. True bool N/A color The hex color code for the project. '#6fcbdf' str N/A inAll N/A True bool N/A sortOrder A sort ID relative to other tasks in the project -1099511627776 int Lower sortOrder == Higher Position sortType Sort type of the project dueDate str dueDate , sortOrder , title , tag , priority userCount How many users have access to the project. 1 int N/A etag Etag identifier. 'ji35exmv' str N/A modifiedTime Time last modified. '2021-01-13T07:18:21.000+0000' str N/A closed Archive status. False bool none and False = Not Archived, True = Archived muted Whether the project is 'hidden' (no notifications) False bool N/A transferred Possibly if the ownership of the project has changed. None bool N/A groupId ID of the project folder if it exists. '5ffe11b7b04b356ce74d49da' str N/A viewMode View mode of the project. 'kanban' str kanban or list notificationOptions N/A None N/A N/A teamId ID of your team. 342537403 int N/A permission N/A None N/A N/A kind If the project is a normal TASK project or NOTE project 'TASK' str 'TASK' or 'NOTE' { 'id' : '5ffe24a18f081003f3294c44' , 'name' : 'Reading' , 'isOwner' : True , 'color' : '#6fcbdf' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'qbj4z0gl' , 'modifiedTime' : '2021-01-12T22:37:21.823+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' } Example TickTick Project Folder (group) Dictionary \u00b6 Members Descriptions It is possible that not all possible fields are present in the table. Property Description Example Value Type Useful Values id The ID of the project folder '5ffe93f3b04b35082bbce7b0' str N/A etag Etag identifier. 'ji35exmv' str N/A name The name of the project folder 'Hobbies' str N/A showAll N/A True bool N/A sortOrder A sort ID relative to other tasks in the project -1099511627776 int Lower sortOrder == Higher Position deleted Whether the project folder is deleted or not. 0 int N/A userId User ID of the creator 586938759 int N/A sortType Sort type of the project folder dueDate str dueDate , project , title , tag , priority teamId ID of your team. 342537403 int N/A { 'id' : '600008f2b04b355792c7a42d' , 'etag' : 'yeozz5v8' , 'name' : 'Test' , 'showAll' : True , 'sortOrder' : - 6786182545408 , 'deleted' : 0 , 'userId' : 586934829 , 'sortType' : 'project' , 'teamId' : None } ProjectManager \u00b6 Handles all interactions for projects. archive ( self , ids ) \u00b6 Moves the project(s) to a project folder created by TickTick called \"Archived Lists\" To unarchive a project, change its 'closed' field to True , then update Parameters: Name Type Description Default ids str or list Single Project (str) : ID string of the project to archive. Multiple Projects (list) : List of ID strings of the projects to archive. required Returns: Type Description dict or list Single Project (dict) : Dictionary of the archived object. Multiple Projects (list) : List of dictionaries of the archived objects. Exceptions: Type Description TypeError If ids is not a string or list. ValueError If the project(s) don't already exist RuntimeError If the project(s) could not be successfully archived. Example Single Project Archive # Lets assume there is a project that exists named \"Reading\" reading_project = client . get_by_fields ( name = \"Reading\" , search = \"projects\" ) reading_project_id = reading_project [ 'id' ] archived = client . project . archive ( reading_project_id ) Result A single dictionary is returned. { 'id' : '5ffe1673e4b062d60dd29dc0' , 'name' : 'Reading' , 'isOwner' : True , 'color' : '#51b9e3' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : 'c9tgze9b' , 'modifiedTime' : '2021-01-13T00:34:50.449+0000' , 'closed' : True , 'muted' : False , 'transferred' : None , 'groupId' : None , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' } Before After Multiple Project Archive # Lets assume there is a project that exists named \"Reading\" reading_project = client . get_by_fields ( name = \"Reading\" , search = \"projects\" ) reading_project_id = reading_project [ 'id' ] # Lets assume another project exists named \"Writing\" writing_project = client . get_by_fields ( name = 'Writing' , search = 'projects' ) writing_project_id = writing_project [ 'id' ] # Archiving multiple requires putting the ID's in a list. archive_list = [ reading_project_id , writing_project_id ] archived = client . project . archive ( archive_list ) Result A list of dictionary objects is returned. [{ 'id' : '5ffe1673e4b062d60dd29dc0' , 'name' : 'Reading' , 'isOwner' : True , 'color' : '#51b9e3' , 'inAll' : True , 'sortOrder' : - 7335938359296 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : 'qrga45as' , 'modifiedTime' : '2021-01-13T00:40:49.839+0000' , 'closed' : True , 'muted' : False , 'transferred' : None , 'groupId' : None , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }, { 'id' : '5ffe41328f08237f3d147e33' , 'name' : 'Writing' , 'isOwner' : True , 'color' : '#F2B04B' , 'inAll' : True , 'sortOrder' : - 7885694173184 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : 'aenkajam' , 'modifiedTime' : '2021-01-13T00:40:49.843+0000' , 'closed' : True , 'muted' : False , 'transferred' : None , 'groupId' : None , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }] Before After Source code in managers/projects.py def archive ( self , ids ): \"\"\" Moves the project(s) to a project folder created by `TickTick` called \"Archived Lists\" To unarchive a project, change its `'closed'` field to `True`, then [update][managers.projects.ProjectManager.update] Arguments: ids (str or list): **Single Project (str)**: ID string of the project to archive. **Multiple Projects (list)**: List of ID strings of the projects to archive. Returns: dict or list: **Single Project (dict)**: Dictionary of the archived object. **Multiple Projects (list)**: List of dictionaries of the archived objects. Raises: TypeError: If `ids` is not a string or list. ValueError: If the project(s) don't already exist RuntimeError: If the project(s) could not be successfully archived. !!! example === \"Single Project Archive\" ```python # Lets assume there is a project that exists named \"Reading\" reading_project = client.get_by_fields(name=\"Reading\", search=\"projects\") reading_project_id = reading_project['id'] archived = client.project.archive(reading_project_id) ``` ??? success \"Result\" A single dictionary is returned. ```python {'id': '5ffe1673e4b062d60dd29dc0', 'name': 'Reading', 'isOwner': True, 'color': '#51b9e3', 'inAll': True, 'sortOrder': 0, 'sortType': 'sortOrder', 'userCount': 1, 'etag': 'c9tgze9b', 'modifiedTime': '2021-01-13T00:34:50.449+0000', 'closed': True, 'muted': False, 'transferred': None, 'groupId': None, 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'} ``` **Before** [![archive-before.png](https://i.postimg.cc/R0jfVt7W/archive-before.png)](https://postimg.cc/B8BtmXw3) **After** [![archived-after.png](https://i.postimg.cc/xjPkBh4J/archived-after.png)](https://postimg.cc/K4RvMqFx) === \"Multiple Project Archive\" ```python # Lets assume there is a project that exists named \"Reading\" reading_project = client.get_by_fields(name=\"Reading\", search=\"projects\") reading_project_id = reading_project['id'] # Lets assume another project exists named \"Writing\" writing_project = client.get_by_fields(name='Writing', search='projects') writing_project_id = writing_project['id'] # Archiving multiple requires putting the ID's in a list. archive_list = [reading_project_id, writing_project_id] archived = client.project.archive(archive_list) ``` ??? success \"Result\" A list of dictionary objects is returned. ```python [{'id': '5ffe1673e4b062d60dd29dc0', 'name': 'Reading', 'isOwner': True, 'color': '#51b9e3', 'inAll': True, 'sortOrder': -7335938359296, 'sortType': 'sortOrder', 'userCount': 1, 'etag': 'qrga45as', 'modifiedTime': '2021-01-13T00:40:49.839+0000', 'closed': True, 'muted': False, 'transferred': None, 'groupId': None, 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}, {'id': '5ffe41328f08237f3d147e33', 'name': 'Writing', 'isOwner': True, 'color': '#F2B04B', 'inAll': True, 'sortOrder': -7885694173184, 'sortType': 'sortOrder', 'userCount': 1, 'etag': 'aenkajam', 'modifiedTime': '2021-01-13T00:40:49.843+0000', 'closed': True, 'muted': False, 'transferred': None, 'groupId': None, 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}] ``` **Before** [![archive-multiple-before.png](https://i.postimg.cc/sgHHmnrb/archive-multiple-before.png)](https://postimg.cc/qNnGMxgG) **After** [![archived-multiple-after.png](https://i.postimg.cc/tg1SMhRJ/archived-multiple-after.png)](https://postimg.cc/rdkNdRr2) \"\"\" if not isinstance ( ids , str ) and not isinstance ( ids , list ): raise TypeError ( 'Ids Must Be A String or List Of Strings' ) objs = [] if isinstance ( ids , str ): proj = self . _client . get_by_fields ( id = ids , search = 'projects' ) if not proj : raise ValueError ( f \"Project ' { ids } ' Does Not Exist To Archive\" ) # Change the list to archived proj [ 'closed' ] = True objs = [ proj ] else : for i in ids : proj = self . _client . get_by_fields ( id = i , search = 'projects' ) if not proj : raise ValueError ( f \"Project ' { i } ' Does Not Exist To Archive\" ) proj [ 'closed' ] = True objs . append ( proj ) return self . update ( objs ) builder ( self , name , color = 'random' , project_type = 'TASK' , folder_id = None ) \u00b6 Creates and returns a local project object. Helper method for create to make batch creating projects easier. Note The project folder must already exist prior to calling this method. Parameters: Name Type Description Default name str Desired name of the project - project names cannot be repeated required color str Hex color string. A random color will be generated if no color is specified. 'random' project_type str 'TASK' or 'NOTE' 'TASK' folder_id str The project folder id that the project should be placed under (if desired) None Returns: Type Description dict A dictionary containing all the fields necessary to create a remote project. Exceptions: Type Description TypeError If any of the types of the arguments are wrong. ValueError Project name already exists ValueError Project Folder corresponding to the ID does not exist. ValueError The hex string color inputted is invalid. Argument rules are shared with create , so for more examples on how to use the arguments see that method. Example project_name = 'Work' # The name of our project # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) productivity_id = productivity_folder [ 'id' ] # Build the object project_object = client . project . builder ( project_name , folder_id = productivity_id ) Result # The fields needed for a successful project creation are set. { 'name' : 'Work' , 'color' : '#665122' , 'kind' : 'TASK' , 'groupId' : '5ffe11b7b04b356ce74d49da' } Source code in managers/projects.py def builder ( self , name : str , color : str = 'random' , project_type : str = 'TASK' , folder_id : str = None ) -> dict : \"\"\" Creates and returns a local project object. Helper method for [create][managers.projects.ProjectManager.create] to make batch creating projects easier. !!! note The project [folder][managers.projects.ProjectManager.create_folder] must already exist prior to calling this method. Arguments: name: Desired name of the project - project names cannot be repeated color: Hex color string. A random color will be generated if no color is specified. project_type: 'TASK' or 'NOTE' folder_id: The project folder id that the project should be placed under (if desired) Returns: A dictionary containing all the fields necessary to create a remote project. Raises: TypeError: If any of the types of the arguments are wrong. ValueError: Project name already exists ValueError: Project Folder corresponding to the ID does not exist. ValueError: The hex string color inputted is invalid. Argument rules are shared with [create][managers.projects.ProjectManager.create], so for more examples on how to use the arguments see that method. !!! example ```python project_name = 'Work' # The name of our project # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') productivity_id = productivity_folder['id'] # Build the object project_object = client.project.builder(project_name, folder_id=productivity_id) ``` ??? success \"Result\" ```python # The fields needed for a successful project creation are set. {'name': 'Work', 'color': '#665122', 'kind': 'TASK', 'groupId': '5ffe11b7b04b356ce74d49da'} ``` \"\"\" if not isinstance ( name , str ): raise TypeError ( \"Name must be a string\" ) if not isinstance ( color , str ) and color is not None : raise TypeError ( \"Color must be a string\" ) if not isinstance ( project_type , str ): raise TypeError ( \"Project type must be a string\" ) if not isinstance ( folder_id , str ) and folder_id is not None : raise TypeError ( \"Folder id must be a string\" ) # Go through self.state['lists'] and determine if the name already exists id_list = self . _client . get_by_fields ( search = 'projects' , name = name ) if id_list : raise ValueError ( f \"Invalid Project Name ' { name } ' -> It Already Exists\" ) # Determine if parent list exists if folder_id is not None : parent = self . _client . get_by_id ( folder_id , search = 'project_folders' ) if not parent : raise ValueError ( f \"Parent Id { folder_id } Does Not Exist\" ) # Make sure project type is valid if project_type != 'TASK' and project_type != 'NOTE' : raise ValueError ( f \"Invalid Project Type ' { project_type } ' -> Should be 'TASK' or 'NOTE'\" ) # Check color_id if color == 'random' : color = generate_hex_color () # Random color will be generated elif color is not None : if not check_hex_color ( color ): raise ValueError ( 'Invalid Hex Color String' ) return { 'name' : name , 'color' : color , 'kind' : project_type , 'groupId' : folder_id } create ( self , name , color = 'random' , project_type = 'TASK' , folder_id = None ) \u00b6 Creates a project remotely. Supports single project creation or batch project creation. Parameters: Name Type Description Default name str or list Single Project (str) : The desired name of the project. Project names cannot be repeated. Multiple Projects (list) : A list of project objects created using the builder method. required color str Hex color string. A random color will be generated if no color is specified. 'random' project_type str 'TASK' or 'NOTE' 'TASK' folder_id str The project folder id that the project should be placed under (if desired) None Returns: Type Description dict or list Single Project : Return the dictionary of the object. Multiple Projects : Return a list of dictionaries containing all the created objects in the same order as created. Exceptions: Type Description TypeError If any of the types of the arguments are wrong. ValueError Project name already exists ValueError Project Folder corresponding to the ID does not exist. ValueError The hex string color inputted is invalid. RuntimeError The project(s) could not be created. Single Project Just A Name project = client . project . create ( 'School' ) Result # The dictionary object of the created project is returned. { 'id' : '5ffe1673e4b062d60dd29dc0' , 'name' : 'School' , 'isOwner' : True , 'color' : '#51b9e3' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'uerkdkcd' , 'modifiedTime' : '2021-01-12T21:36:51.890+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : None , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' } Our project is created. Specify a Color A random color can be generated using generate_hex_color . However, just not specifying a color will automatically generate a random color (as seen in the previous tab). You can always specify the color that you want. project = client . project . create ( 'Work' , color = '#86bb6d' ) Result Our project is created with the color specified. Changing the Project Type The default project type is for Tasks. To change the type to handle Notes, pass in the string 'NOTE' project = client . project . create ( 'Hobbies' , project_type = 'NOTE' ) Result The project type is now for notes. Creating Inside of A Folder Note For folder_id The project folder must already exist prior to calling this method. project_name = 'Day Job' # The name of our project # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) productivity_id = productivity_folder [ 'id' ] # Create the object project_object = client . project . create ( project_name , folder_id = productivity_id ) Result The project was created in the group folder. Multiple Projects (batch) To create multiple projects, you will need to build the projects locally prior to calling the create method. This can be accomplished using the builder method. Pass in a list of the locally created project objects to create them remotely. (Again About Folders) The project folders should already be created prior to calling the create method. # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) productivity_id = productivity_folder [ 'id' ] # Names of our projects name_1 = 'Reading' name_2 = 'Writing' # Build the local projects project1 = client . project . builder ( name_1 , folder_id = productivity_id ) project2 = client . project . builder ( name_2 , folder_id = productivity_id ) project_list = [ project1 , project2 ] # Create the projects project_object = client . project . create ( project_list ) Result When multiple projects are created, the dictionaries will be returned in a list in the same order as the input. [{ 'id' : '5ffe24a18f081003f3294c44' , 'name' : 'Reading' , 'isOwner' : True , 'color' : '#6fcbdf' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'qbj4z0gl' , 'modifiedTime' : '2021-01-12T22:37:21.823+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }, { 'id' : '5ffe24a18f081003f3294c46' , 'name' : 'Writing' , 'isOwner' : True , 'color' : '#9730ce' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'u0loxz2v' , 'modifiedTime' : '2021-01-12T22:37:21.827+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }] Source code in managers/projects.py def create ( self , name , color : str = 'random' , project_type : str = 'TASK' , folder_id : str = None ): \"\"\" Creates a project remotely. Supports single project creation or batch project creation. Arguments: name (str or list): **Single Project** (str) : The desired name of the project. Project names cannot be repeated. **Multiple Projects** (list) : A list of project objects created using the [builder][managers.projects.ProjectManager.builder] method. color: Hex color string. A random color will be generated if no color is specified. project_type: 'TASK' or 'NOTE' folder_id: The project folder id that the project should be placed under (if desired) Returns: dict or list: **Single Project**: Return the dictionary of the object. **Multiple Projects**: Return a list of dictionaries containing all the created objects in the same order as created. Raises: TypeError: If any of the types of the arguments are wrong. ValueError: Project name already exists ValueError: Project Folder corresponding to the ID does not exist. ValueError: The hex string color inputted is invalid. RuntimeError: The project(s) could not be created. !!! example \"Single Project\" === \"Just A Name\" ```python project = client.project.create('School') ``` ??? success \"Result\" ```python # The dictionary object of the created project is returned. {'id': '5ffe1673e4b062d60dd29dc0', 'name': 'School', 'isOwner': True, 'color': '#51b9e3', 'inAll': True, 'sortOrder': 0, 'sortType': None, 'userCount': 1, 'etag': 'uerkdkcd', 'modifiedTime': '2021-01-12T21:36:51.890+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': None, 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'} ``` Our project is created. [![project-create.png](https://i.postimg.cc/d1NNqN7F/project-create.png)](https://postimg.cc/PpZQy4zV) === \"Specify a Color\" A random color can be generated using [generate_hex_color][helpers.hex_color.generate_hex_color]. However, just not specifying a color will automatically generate a random color (as seen in the previous tab). You can always specify the color that you want. ```python project = client.project.create('Work', color='#86bb6d') ``` ??? success \"Result\" Our project is created with the color specified. [![project-color.png](https://i.postimg.cc/K8ppnvrb/project-color.png)](https://postimg.cc/5XvmJJRK) === \"Changing the Project Type\" The default project type is for Tasks. To change the type to handle Notes, pass in the string 'NOTE' ```python project = client.project.create('Hobbies', project_type='NOTE') ``` ??? success \"Result\" The project type is now for notes. [![project-note.png](https://i.postimg.cc/fy0Mhrzt/project-note.png)](https://postimg.cc/rRcB1gtM) === \"Creating Inside of A Folder\" !!! warning \"Note For `folder_id`\" The project [folder][managers.projects.ProjectManager.create_folder] must already exist prior to calling this method. ```python project_name = 'Day Job' # The name of our project # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') productivity_id = productivity_folder['id'] # Create the object project_object = client.project.create(project_name, folder_id=productivity_id) ``` ??? success \"Result\" The project was created in the group folder. [![project-create-with-folder.png](https://i.postimg.cc/mr53rmfN/project-create-with-folder.png)](https://postimg.cc/rd5RnCpK) !!! example \"Multiple Projects (batch)\" To create multiple projects, you will need to build the projects locally prior to calling the `create` method. This can be accomplished using the [builder][managers.projects.ProjectManager.builder] method. Pass in a list of the locally created project objects to create them remotely. !!! warning \"(Again About Folders)\" The project folders should already be created prior to calling the create method. ```python # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') productivity_id = productivity_folder['id'] # Names of our projects name_1 = 'Reading' name_2 = 'Writing' # Build the local projects project1 = client.project.builder(name_1, folder_id=productivity_id) project2 = client.project.builder(name_2, folder_id=productivity_id) project_list = [project1, project2] # Create the projects project_object = client.project.create(project_list) ``` ??? success \"Result\" When multiple projects are created, the dictionaries will be returned in a list in the same order as the input. ```python [{'id': '5ffe24a18f081003f3294c44', 'name': 'Reading', 'isOwner': True, 'color': '#6fcbdf', 'inAll': True, 'sortOrder': 0, 'sortType': None, 'userCount': 1, 'etag': 'qbj4z0gl', 'modifiedTime': '2021-01-12T22:37:21.823+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe11b7b04b356ce74d49da', 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}, {'id': '5ffe24a18f081003f3294c46', 'name': 'Writing', 'isOwner': True, 'color': '#9730ce', 'inAll': True, 'sortOrder': 0, 'sortType': None, 'userCount': 1, 'etag': 'u0loxz2v', 'modifiedTime': '2021-01-12T22:37:21.827+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe11b7b04b356ce74d49da', 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}] ``` [![project-batch-create.png](https://i.postimg.cc/8CHH8xSZ/project-batch-create.png)](https://postimg.cc/d7hdrHDC) \"\"\" if isinstance ( name , list ): # If task name is a list, we will batch create objects obj = name batch = True # Create the single project object elif isinstance ( name , str ): batch = False obj = self . builder ( name = name , color = color , project_type = project_type , folder_id = folder_id ) obj = [ obj ] else : raise TypeError ( f \"Required Positional Argument Must Be A String or List of Project Objects\" ) url = self . _client . BASE_URL + 'batch/project' payload = { 'add' : obj } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () if len ( obj ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'projects' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Get the ids items = [ '' ] * len ( obj ) # Create enough spots for the objects for proj_id in etag2 : found = self . _client . get_by_id ( proj_id , search = 'projects' ) for original in obj : if found [ 'name' ] == original [ 'name' ]: # Get the index of original index = obj . index ( original ) # Place found at the index in return list items [ index ] = found return items create_folder ( self , name ) \u00b6 Creates a project folder to allow for project grouping. Project folder names can be repeated. Parameters: Name Type Description Default name str or list Single Folder (str) : A string for the name of the folder Multiple Folders (list) : A list of strings for names of the folders. required Returns: Type Description dict or list Single Folder (dict) : A dictionary for the created folder. Multiple Folders (list) : A list of dictionaries for the created folders. Exceptions: Type Description TypeError If name is not a string or list RuntimeError If the folder(s) could not be created. Example Creating a Single Folder A single string for the name is the only parameter needed. project_folder = client . project . create_folder ( 'Productivity' ) Result A single dictionary is returned. { 'id' : '5ffe44528f089fb5795c45bf' , 'etag' : '9eun9kyc' , 'name' : 'Productivity' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 115781412 , 'sortType' : 'project' , 'teamId' : None } Creating Multiple Folders The desired names of the folders are passed to create as a list. names = [ 'Productivity' , 'School' , 'Hobbies' ] project_folder = client . project . create_folder ( names ) Result A list of dictionaries containing the foler objects is returned. [{ 'id' : '5ffe45d6e4b062d60dd3ce15' , 'etag' : '4nvnuiw1' , 'name' : 'Productivity' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }, { 'id' : '5ffe45d6e4b062d60dd3ce16' , 'etag' : 's072l3pu' , 'name' : 'School' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }, { 'id' : '5ffe45d6e4b062d60dd3ce17' , 'etag' : '12t1xmt9' , 'name' : 'Hobbies' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }] Source code in managers/projects.py def create_folder ( self , name ): \"\"\" Creates a project folder to allow for project grouping. Project folder names can be repeated. Arguments: name (str or list): **Single Folder (str)**: A string for the name of the folder **Multiple Folders (list)**: A list of strings for names of the folders. Returns: dict or list: **Single Folder (dict)**: A dictionary for the created folder. **Multiple Folders (list)**: A list of dictionaries for the created folders. Raises: TypeError: If `name` is not a string or list RuntimeError: If the folder(s) could not be created. !!! example === \"Creating a Single Folder\" A single string for the name is the only parameter needed. ```python project_folder = client.project.create_folder('Productivity') ``` ??? success \"Result\" A single dictionary is returned. ```python {'id': '5ffe44528f089fb5795c45bf', 'etag': '9eun9kyc', 'name': 'Productivity', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 115781412, 'sortType': 'project', 'teamId': None} ``` [![folder.png](https://i.postimg.cc/HWRTjtRW/folder.png)](https://postimg.cc/c6RpbfdP) === \"Creating Multiple Folders\" The desired names of the folders are passed to create as a list. ```python names = ['Productivity', 'School', 'Hobbies'] project_folder = client.project.create_folder(names) ``` ??? success \"Result\" A list of dictionaries containing the foler objects is returned. ```python [{'id': '5ffe45d6e4b062d60dd3ce15', 'etag': '4nvnuiw1', 'name': 'Productivity', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}, {'id': '5ffe45d6e4b062d60dd3ce16', 'etag': 's072l3pu', 'name': 'School', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}, {'id': '5ffe45d6e4b062d60dd3ce17', 'etag': '12t1xmt9', 'name': 'Hobbies', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}] ``` [![folders-multiple.png](https://i.postimg.cc/2jwXKjds/folders-multiple.png)](https://postimg.cc/0rzf6sBn) \"\"\" if not isinstance ( name , str ) and not isinstance ( name , list ): raise TypeError ( 'Name Must Be A String or List Of Strings' ) objs = [] if isinstance ( name , str ): names = { 'name' : name , 'listType' : 'group' } objs = [ names ] else : for nm in name : objs . append ({ 'name' : nm , 'listType' : 'group' }) url = self . _client . BASE_URL + 'batch/projectGroup' payload = { 'add' : objs } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () if len ( objs ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'project_folders' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Get the ids items = [ '' ] * len ( objs ) # Create enough spots for the objects for proj_id in etag2 : found = self . _client . get_by_id ( proj_id , search = 'project_folders' ) for original in objs : if found [ 'name' ] == original [ 'name' ]: # Get the index of original index = objs . index ( original ) # Place found at the index in return list items [ index ] = found return items delete ( self , ids ) \u00b6 Deletes the project(s) with the passed ID string. Warning Tasks will be deleted from the project. If you want to preserve the tasks before deletion, use move_all Parameters: Name Type Description Default ids str or list Single Deletion (str) : ID string of the project Multiple Deletions (list) : List of ID strings of projects to be deleted. required Returns: Type Description dict or list Single Deletion (dict) : Dictionary of the deleted project. Multiple Deletions (list) : A list of dictionaries of the deleted projects. Exceptions: Type Description TypeError If ids is not a string or list of strings ValueError If ids does not exist. RuntimeError If the deletion was not successful. Example Single Project Deletion # Lets assume that we have a project that exists named 'School' school = client . get_by_fields ( name = 'School' , search = 'projects' ) # Get the project object project_id = school [ 'id' ] # Get the project id delete = client . project . delete ( project_id ) A dictionary of the deleted project object will be returned. Multiple Project Deletion # Lets assume that we have two projects that we want to delete: 'School' and 'Work' school = client . get_by_fields ( name = 'School' , search = 'projects' ) # Get the project object work = client . get_by_fields ( name = 'Work' , search = 'projects' ) delete_ids = [ school [ 'id' ], work [ 'id' ]] # A list of the ID strings of the projects to be deleted delete = client . project . delete ( delete_ids ) A list of the deleted dictionary objects will be returned. Source code in managers/projects.py def delete ( self , ids ): \"\"\" Deletes the project(s) with the passed ID string. !!! warning [Tasks](tasks.md) will be deleted from the project. If you want to preserve the tasks before deletion, use [move_all][managers.tasks.TaskManager.move_all] Arguments: ids (str or list): **Single Deletion (str)**: ID string of the project **Multiple Deletions (list)**: List of ID strings of projects to be deleted. Returns: dict or list: **Single Deletion (dict)**: Dictionary of the deleted project. **Multiple Deletions (list)**: A list of dictionaries of the deleted projects. Raises: TypeError: If `ids` is not a string or list of strings ValueError: If `ids` does not exist. RuntimeError: If the deletion was not successful. !!! example === \"Single Project Deletion\" ```python # Lets assume that we have a project that exists named 'School' school = client.get_by_fields(name='School', search='projects') # Get the project object project_id = school['id'] # Get the project id delete = client.project.delete(project_id) ``` A dictionary of the deleted project object will be returned. === \"Multiple Project Deletion\" ```python # Lets assume that we have two projects that we want to delete: 'School' and 'Work' school = client.get_by_fields(name='School', search='projects') # Get the project object work = client.get_by_fields(name='Work', search='projects') delete_ids = [school['id'], work['id']] # A list of the ID strings of the projects to be deleted delete = client.project.delete(delete_ids) ``` A list of the deleted dictionary objects will be returned. \"\"\" if not isinstance ( ids , str ) and not isinstance ( ids , list ): raise TypeError ( 'Ids Must Be A String or List Of Strings' ) if isinstance ( ids , str ): proj = self . _client . get_by_fields ( id = ids , search = 'projects' ) if not proj : raise ValueError ( f \"Project ' { ids } ' Does Not Exist To Delete\" ) ids = [ ids ] else : for i in ids : proj = self . _client . get_by_fields ( id = i , search = 'projects' ) if not proj : raise ValueError ( f \"Project ' { i } ' Does Not Exist To Delete\" ) # Delete the task url = self . _client . BASE_URL + 'batch/project' payload = { 'delete' : ids } self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) # Delete the list deleted_list = [] for current_id in ids : tasks = self . _client . task . get_from_project ( current_id ) for task in tasks : self . _client . delete_from_local_state ( id = task [ 'id' ], search = 'tasks' ) deleted_list . append ( self . _client . delete_from_local_state ( id = current_id , search = 'projects' )) if len ( deleted_list ) == 1 : return deleted_list [ 0 ] else : return deleted_list delete_folder ( self , ids ) \u00b6 Deletes the folder(s). Tip Any projects inside of the folder will be preserved - they will just not be grouped anymore. Parameters: Name Type Description Default ids str or list Single Folder (str) : The ID of the folder to be deleted. Multiple Folders (list) : A list containing the ID strings of the folders to be deleted. required Returns: Type Description dict or list Single Folder (dict) : The dictionary object for the deleted folder. Multiple Folders (list) : A list of dictionary objects of the deleted folders. Exceptions: Type Description TypeError If ids is not a str or list ValueError If ids does not match an actual folder object. RunTimeError If the folders could not be successfully deleted. Folder Deletion Single Folder Deletion Pass in the ID of the folder object to delete it remotely. # Lets assume we have a folder named \"Productivity\" project_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) # Get the project folder deleted_folder = client . project . delete_folder ( project_folder [ 'id' ]) Result The folder is deleted, and a single dictionary of the deleted folder object is returned. { 'id' : '5ffe75008f089fb5795d544a' , 'etag' : 'e95rdzi7' , 'name' : 'Productivity' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None } Before After The project inside still exists. Multiple Folder Deletion Pass in the list of ID strings of the folders to be deleted. # Lets assume that we have two folders that already exist: \"Productivity\" and \"Hobbies\" productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) hobbies_folder = client . get_by_fields ( name = 'Hobbies' , search = 'project_folders' ) ids = [ productivity_folder [ 'id' ], hobbies_folder [ 'id' ]] deleted_folders = client . project . delete_folder ( ids ) Result The folders are deleted, and a list of dictionaries for the deleted folder objects are returned. [{ 'id' : '5ffe79d78f08237f3d1636ad' , 'etag' : '2o2dn2al' , 'name' : 'Productivity' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }, { 'id' : '5ffe79d78f08237f3d1636ae' , 'etag' : 'mah5a78l' , 'name' : 'Hobbies' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }] Before After All folders deleted and all projects retained. Source code in managers/projects.py def delete_folder ( self , ids ): \"\"\" Deletes the folder(s). !!! tip Any projects inside of the folder will be preserved - they will just not be grouped anymore. Arguments: ids (str or list): **Single Folder (str)**: The ID of the folder to be deleted. **Multiple Folders (list)**: A list containing the ID strings of the folders to be deleted. Returns: dict or list: **Single Folder (dict)**: The dictionary object for the deleted folder. **Multiple Folders (list)**: A list of dictionary objects of the deleted folders. Raises: TypeError: If `ids` is not a str or list ValueError: If `ids` does not match an actual folder object. RunTimeError: If the folders could not be successfully deleted. !!! example \"Folder Deletion\" === \"Single Folder Deletion\" Pass in the ID of the folder object to delete it remotely. ```python # Lets assume we have a folder named \"Productivity\" project_folder = client.get_by_fields(name='Productivity', search='project_folders') # Get the project folder deleted_folder = client.project.delete_folder(project_folder['id']) ``` ??? success \"Result\" The folder is deleted, and a single dictionary of the deleted folder object is returned. ```python {'id': '5ffe75008f089fb5795d544a', 'etag': 'e95rdzi7', 'name': 'Productivity', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104407093-b5573e80-5515-11eb-99dc-16ca4f33d06a.png) **After** The project inside still exists. ![image](https://user-images.githubusercontent.com/56806733/104407123-c607b480-5515-11eb-92ff-15df1d41b404.png) === \"Multiple Folder Deletion\" Pass in the list of ID strings of the folders to be deleted. ```python # Lets assume that we have two folders that already exist: \"Productivity\" and \"Hobbies\" productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') hobbies_folder = client.get_by_fields(name='Hobbies', search='project_folders') ids = [productivity_folder['id'], hobbies_folder['id']] deleted_folders = client.project.delete_folder(ids) ``` ??? success \"Result\" The folders are deleted, and a list of dictionaries for the deleted folder objects are returned. ```python [{'id': '5ffe79d78f08237f3d1636ad', 'etag': '2o2dn2al', 'name': 'Productivity', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}, {'id': '5ffe79d78f08237f3d1636ae', 'etag': 'mah5a78l', 'name': 'Hobbies', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104407469-8097b700-5516-11eb-9919-069e5beb3b8a.png) **After** All folders deleted and all projects retained. ![image](https://user-images.githubusercontent.com/56806733/104407546-a8871a80-5516-11eb-815b-4df41e3d797a.png) \"\"\" if not isinstance ( ids , str ) and not isinstance ( ids , list ): raise TypeError ( 'Ids Must Be A String or List Of Strings' ) if isinstance ( ids , str ): proj = self . _client . get_by_fields ( id = ids , search = 'project_folders' ) if not proj : raise ValueError ( f \"Project Folder ' { ids } ' Does Not Exist To Delete\" ) ids = [ ids ] else : for i in ids : proj = self . _client . get_by_fields ( id = i , search = 'project_folders' ) if not proj : raise ValueError ( f \"Project Folder ' { i } ' Does Not Exist To Delete\" ) url = self . _client . BASE_URL + 'batch/projectGroup' payload = { 'delete' : ids } self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) # Delete the list deleted_list = [] for current_id in ids : deleted_list . append ( self . _client . get_by_id ( current_id , search = 'project_folders' )) self . _client . sync () if len ( deleted_list ) == 1 : return deleted_list [ 0 ] else : return deleted_list update ( self , obj ) \u00b6 Updates the passed project(s). Supports single project update and multiple project update (batch) Make local changes to the project objects that you want to change first, then pass the actual objects to the method. Info Every potential update to a project's attributes have not been tested. See Example TickTick Project Dictionary for a listing of the fields present in a project. Parameters: Name Type Description Default obj dict or list Single Project (dict) : The project dictionary. Multiple Projects (list) : A list of project dictionaries. required Returns: Type Description dict or list Single Project (dict) : The updated project dictionary Multiple Projects (list) : A list containing the updated project dictionaries. Exceptions: Type Description TypeError If the input is not a dict or a list. RuntimeError If the projects could not be updated successfully. Updates are done by changing the fields in the objects locally first. Single Project Update Changing The Name # Lets assume that we have a project named \"Reading\" that we want to change to \"Summer Reading\" project = client . get_by_fields ( name = 'Reading' , search = 'projects' ) # Get the project # Now lets change the name project [ 'name' ] = 'Summer Reading' # Updating a single project requires just passing in the entire dictionary. updated = client . project . update ( project ) Result The dictionary is returned and the name changed remotely. { 'id' : '5ffe24a18f081003f3294c44' , 'name' : 'Summer Reading' , 'isOwner' : True , 'color' : '#6fcbdf' , 'inAll' : True , 'sortOrder' : - 6236426731520 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : '0vbsvn8e' , 'modifiedTime' : '2021-01-12T23:38:16.456+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe2d37b04b35082bbcdf74' , 'viewMode' : 'list' , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' } Before After Multiple Project Update Changing Multiple Names # Lets assume that we have a project named \"Writing\" that we want to change to \"Summer Reading\" project = client . get_by_fields ( name = 'Writing' , search = 'projects' ) # Get the project project [ 'name' ] = 'Summer Writing' # Lets assume that we have a project named \"Movies\" that we want to change to \"Summer Movies\" movie_project = client . get_by_fields ( name = 'Movies' , search = 'projects' ) movie_project [ 'name' ] = 'Summer Movies' # Updating multiple projects requires passing the projects in a list. update_list = [ project , movie_project ] # Lets update remotely now updated_projects = client . project . update ( update_list ) Result A list containing the updated projects is returned. [{ 'id' : '5ffe24a18f081003f3294c46' , 'name' : 'Summer Reading' , 'isOwner' : True , 'color' : '#9730ce' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'bgl0pkm8' , 'modifiedTime' : '2021-01-13T00:13:29.796+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }, { 'id' : '5ffe399c8f08237f3d144ece' , 'name' : 'Summer Movies' , 'isOwner' : True , 'color' : '#F18181' , 'inAll' : True , 'sortOrder' : - 2843335458816 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : 'jmjy1xtc' , 'modifiedTime' : '2021-01-13T00:13:29.800+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }] Before After Source code in managers/projects.py def update ( self , obj ): \"\"\" Updates the passed project(s). Supports single project update and multiple project update (batch) Make local changes to the project objects that you want to change first, then pass the actual objects to the method. !!! info Every potential update to a project's attributes have not been tested. See [Example `TickTick` Project Dictionary](projects.md#example-ticktick-project-dictionary) for a listing of the fields present in a project. Arguments: obj (dict or list): **Single Project (dict)**: The project dictionary. **Multiple Projects (list)**: A list of project dictionaries. Returns: dict or list: **Single Project (dict)**: The updated project dictionary **Multiple Projects (list)**: A list containing the updated project dictionaries. Raises: TypeError: If the input is not a dict or a list. RuntimeError: If the projects could not be updated successfully. Updates are done by changing the fields in the objects locally first. !!! example \"Single Project Update\" === \"Changing The Name\" ```python # Lets assume that we have a project named \"Reading\" that we want to change to \"Summer Reading\" project = client.get_by_fields(name='Reading', search='projects') # Get the project # Now lets change the name project['name'] = 'Summer Reading' # Updating a single project requires just passing in the entire dictionary. updated = client.project.update(project) ``` ??? success \"Result\" The dictionary is returned and the name changed remotely. ```python {'id': '5ffe24a18f081003f3294c44', 'name': 'Summer Reading', 'isOwner': True, 'color': '#6fcbdf', 'inAll': True, 'sortOrder': -6236426731520, 'sortType': 'sortOrder', 'userCount': 1, 'etag': '0vbsvn8e', 'modifiedTime': '2021-01-12T23:38:16.456+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe2d37b04b35082bbcdf74', 'viewMode': 'list', 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'} ``` **Before** [![project-update-before.png](https://i.postimg.cc/K8hcpzvP/project-update-before.png)](https://postimg.cc/crTNrd3C) **After** [![project-update-after.png](https://i.postimg.cc/DwcWqsdJ/project-update-after.png)](https://postimg.cc/FY7svY6N) !!! example \"Multiple Project Update\" === \"Changing Multiple Names\" ```python # Lets assume that we have a project named \"Writing\" that we want to change to \"Summer Reading\" project = client.get_by_fields(name='Writing', search='projects') # Get the project project['name'] = 'Summer Writing' # Lets assume that we have a project named \"Movies\" that we want to change to \"Summer Movies\" movie_project = client.get_by_fields(name='Movies', search='projects') movie_project['name'] = 'Summer Movies' # Updating multiple projects requires passing the projects in a list. update_list = [project, movie_project] # Lets update remotely now updated_projects = client.project.update(update_list) ``` ??? success \"Result\" A list containing the updated projects is returned. ```python [{'id': '5ffe24a18f081003f3294c46', 'name': 'Summer Reading', 'isOwner': True, 'color': '#9730ce', 'inAll': True, 'sortOrder': 0, 'sortType': None, 'userCount': 1, 'etag': 'bgl0pkm8', 'modifiedTime': '2021-01-13T00:13:29.796+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe11b7b04b356ce74d49da', 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}, {'id': '5ffe399c8f08237f3d144ece', 'name': 'Summer Movies', 'isOwner': True, 'color': '#F18181', 'inAll': True, 'sortOrder': -2843335458816, 'sortType': 'sortOrder', 'userCount': 1, 'etag': 'jmjy1xtc', 'modifiedTime': '2021-01-13T00:13:29.800+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe11b7b04b356ce74d49da', 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}] ``` **Before** [![project-update-multiople.png](https://i.postimg.cc/9QbcJH81/project-update-multiople.png)](https://postimg.cc/zyLmG61R) **After** [![project-update-multiple-after.png](https://i.postimg.cc/3RVGNv2y/project-update-multiple-after.png)](https://postimg.cc/0MGjHrWx) \"\"\" # Check the types if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( \"Project objects must be a dict or list of dicts.\" ) if isinstance ( obj , dict ): tasks = [ obj ] else : tasks = obj url = self . _client . BASE_URL + 'batch/project' payload = { 'update' : tasks } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () if len ( tasks ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'projects' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Get the ids items = [ '' ] * len ( obj ) # Create enough spots for the objects for proj_id in etag2 : found = self . _client . get_by_id ( proj_id , search = 'projects' ) for original in obj : if found [ 'name' ] == original [ 'name' ]: # Get the index of original index = obj . index ( original ) # Place found at the index in return list items [ index ] = found return items update_folder ( self , obj ) \u00b6 Updates the project folders(s) remotely based off changes made locally. Make the changes you want to the project folder(s) first. Parameters: Name Type Description Default obj dict or list Single Folder (dict) : The dictionary object of the folder to update. Multiple Folders (list) : A list containing dictionary objects of folders to update. required Returns: Type Description dict or list Single Folder (dict) : The dictionary object of the updated folder. Multiple Folders (list) : A list of dictionary objects corresponding to the updated folders. Exceptions: Type Description TypeError If obj is not a dictionary or list RuntimeError If the updating was unsuccessful. Updating A Project Folder Single Folder Update # Lets assume that we have a folder called \"Productivity\" productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) # Lets change the name to \"Hobbies\" productivity_folder [ 'name' ] = \"Hobbies\" # Update updated_folder = client . project . update_folder ( productivity_folder ) Result The dictionary of the updated folder is returned. { 'id' : '5ffe7dab8f089fb5795d8ef2' , 'etag' : 'r9xl60e5' , 'name' : 'Hobbies' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None } Before After Multiple Folder Update # Lets assume that we have a folder called \"Productivity\" productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) # Lets assume that we have another folder called \"Games\" games_folder = client . get_by_fields ( name = 'Games' , search = 'project_folders' ) # Lets change the \"Productivity\" folder to \"Work\" productivity_folder [ 'name' ] = \"Work\" # Lets change the \"Games\" folder to \"Hobbies\" games_folder [ 'name' ] = \"Hobbies\" update_list = [ productivity_folder , games_folder ] # List of objects to update # Update updated_folder = client . project . update_folder ( update_list ) Result A list of the updated folder objects is returned. [{ 'id' : '5ffe80ce8f08068e86aab288' , 'etag' : '0oh0pxel' , 'name' : 'Work' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }, { 'id' : '5ffe80cf8f08068e86aab289' , 'etag' : 'xwvehtfo' , 'name' : 'Hobbies' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }] Before After Source code in managers/projects.py def update_folder ( self , obj ): \"\"\" Updates the project folders(s) remotely based off changes made locally. Make the changes you want to the project folder(s) first. Arguments: obj (dict or list): **Single Folder (dict)**: The dictionary object of the folder to update. **Multiple Folders (list)**: A list containing dictionary objects of folders to update. Returns: dict or list: **Single Folder (dict)**: The dictionary object of the updated folder. **Multiple Folders (list)**: A list of dictionary objects corresponding to the updated folders. Raises: TypeError: If `obj` is not a dictionary or list RuntimeError: If the updating was unsuccessful. !!! example \"Updating A Project Folder\" === \"Single Folder Update\" ```python # Lets assume that we have a folder called \"Productivity\" productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') # Lets change the name to \"Hobbies\" productivity_folder['name'] = \"Hobbies\" # Update updated_folder = client.project.update_folder(productivity_folder) ``` ??? success \"Result\" The dictionary of the updated folder is returned. ```python {'id': '5ffe7dab8f089fb5795d8ef2', 'etag': 'r9xl60e5', 'name': 'Hobbies', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104408388-c48bbb80-5518-11eb-80d4-34e82bbaffd7.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104408436-e1c08a00-5518-11eb-953a-4933f407e4f9.png) === \"Multiple Folder Update\" ```python # Lets assume that we have a folder called \"Productivity\" productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') # Lets assume that we have another folder called \"Games\" games_folder = client.get_by_fields(name='Games', search='project_folders') # Lets change the \"Productivity\" folder to \"Work\" productivity_folder['name'] = \"Work\" # Lets change the \"Games\" folder to \"Hobbies\" games_folder['name'] = \"Hobbies\" update_list = [productivity_folder, games_folder] # List of objects to update # Update updated_folder = client.project.update_folder(update_list) ``` ??? success \"Result\" A list of the updated folder objects is returned. ```python [{'id': '5ffe80ce8f08068e86aab288', 'etag': '0oh0pxel', 'name': 'Work', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}, {'id': '5ffe80cf8f08068e86aab289', 'etag': 'xwvehtfo', 'name': 'Hobbies', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104409143-75468a80-551a-11eb-96c8-5953c97d6f6a.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104409181-8bece180-551a-11eb-8424-9f147d85eb80.png) \"\"\" # Check the types if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( \"Project objects must be a dict or list of dicts.\" ) if isinstance ( obj , dict ): tasks = [ obj ] else : tasks = obj url = self . _client . BASE_URL + 'batch/projectGroup' payload = { 'update' : tasks } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () if len ( tasks ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'project_folders' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Get the ids items = [ '' ] * len ( tasks ) # Create enough spots for the objects for proj_id in etag2 : found = self . _client . get_by_id ( proj_id , search = 'project_folders' ) for original in tasks : if found [ 'name' ] == original [ 'name' ]: # Get the index of original index = tasks . index ( original ) # Place found at the index in return list items [ index ] = found return items","title":"Projects"},{"location":"usage/projects/#example-ticktick-project-dictionary","text":"Members Descriptions It is possible that not all possible fields are present in the table. Property Description Example Value Type Useful Values id The ID of the project '5ffe93f3b04b35082bbce7b0' str N/A name The name of the project 'Hobbies' str N/A isOwner Whether you are the owner of the project or not. True bool N/A color The hex color code for the project. '#6fcbdf' str N/A inAll N/A True bool N/A sortOrder A sort ID relative to other tasks in the project -1099511627776 int Lower sortOrder == Higher Position sortType Sort type of the project dueDate str dueDate , sortOrder , title , tag , priority userCount How many users have access to the project. 1 int N/A etag Etag identifier. 'ji35exmv' str N/A modifiedTime Time last modified. '2021-01-13T07:18:21.000+0000' str N/A closed Archive status. False bool none and False = Not Archived, True = Archived muted Whether the project is 'hidden' (no notifications) False bool N/A transferred Possibly if the ownership of the project has changed. None bool N/A groupId ID of the project folder if it exists. '5ffe11b7b04b356ce74d49da' str N/A viewMode View mode of the project. 'kanban' str kanban or list notificationOptions N/A None N/A N/A teamId ID of your team. 342537403 int N/A permission N/A None N/A N/A kind If the project is a normal TASK project or NOTE project 'TASK' str 'TASK' or 'NOTE' { 'id' : '5ffe24a18f081003f3294c44' , 'name' : 'Reading' , 'isOwner' : True , 'color' : '#6fcbdf' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'qbj4z0gl' , 'modifiedTime' : '2021-01-12T22:37:21.823+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }","title":"Example TickTick Project Dictionary"},{"location":"usage/projects/#example-ticktick-project-folder-group-dictionary","text":"Members Descriptions It is possible that not all possible fields are present in the table. Property Description Example Value Type Useful Values id The ID of the project folder '5ffe93f3b04b35082bbce7b0' str N/A etag Etag identifier. 'ji35exmv' str N/A name The name of the project folder 'Hobbies' str N/A showAll N/A True bool N/A sortOrder A sort ID relative to other tasks in the project -1099511627776 int Lower sortOrder == Higher Position deleted Whether the project folder is deleted or not. 0 int N/A userId User ID of the creator 586938759 int N/A sortType Sort type of the project folder dueDate str dueDate , project , title , tag , priority teamId ID of your team. 342537403 int N/A { 'id' : '600008f2b04b355792c7a42d' , 'etag' : 'yeozz5v8' , 'name' : 'Test' , 'showAll' : True , 'sortOrder' : - 6786182545408 , 'deleted' : 0 , 'userId' : 586934829 , 'sortType' : 'project' , 'teamId' : None }","title":"Example TickTick Project Folder (group) Dictionary"},{"location":"usage/projects/#managers.projects.ProjectManager","text":"Handles all interactions for projects.","title":"ProjectManager"},{"location":"usage/projects/#managers.projects.ProjectManager.archive","text":"Moves the project(s) to a project folder created by TickTick called \"Archived Lists\" To unarchive a project, change its 'closed' field to True , then update Parameters: Name Type Description Default ids str or list Single Project (str) : ID string of the project to archive. Multiple Projects (list) : List of ID strings of the projects to archive. required Returns: Type Description dict or list Single Project (dict) : Dictionary of the archived object. Multiple Projects (list) : List of dictionaries of the archived objects. Exceptions: Type Description TypeError If ids is not a string or list. ValueError If the project(s) don't already exist RuntimeError If the project(s) could not be successfully archived. Example Single Project Archive # Lets assume there is a project that exists named \"Reading\" reading_project = client . get_by_fields ( name = \"Reading\" , search = \"projects\" ) reading_project_id = reading_project [ 'id' ] archived = client . project . archive ( reading_project_id ) Result A single dictionary is returned. { 'id' : '5ffe1673e4b062d60dd29dc0' , 'name' : 'Reading' , 'isOwner' : True , 'color' : '#51b9e3' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : 'c9tgze9b' , 'modifiedTime' : '2021-01-13T00:34:50.449+0000' , 'closed' : True , 'muted' : False , 'transferred' : None , 'groupId' : None , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' } Before After Multiple Project Archive # Lets assume there is a project that exists named \"Reading\" reading_project = client . get_by_fields ( name = \"Reading\" , search = \"projects\" ) reading_project_id = reading_project [ 'id' ] # Lets assume another project exists named \"Writing\" writing_project = client . get_by_fields ( name = 'Writing' , search = 'projects' ) writing_project_id = writing_project [ 'id' ] # Archiving multiple requires putting the ID's in a list. archive_list = [ reading_project_id , writing_project_id ] archived = client . project . archive ( archive_list ) Result A list of dictionary objects is returned. [{ 'id' : '5ffe1673e4b062d60dd29dc0' , 'name' : 'Reading' , 'isOwner' : True , 'color' : '#51b9e3' , 'inAll' : True , 'sortOrder' : - 7335938359296 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : 'qrga45as' , 'modifiedTime' : '2021-01-13T00:40:49.839+0000' , 'closed' : True , 'muted' : False , 'transferred' : None , 'groupId' : None , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }, { 'id' : '5ffe41328f08237f3d147e33' , 'name' : 'Writing' , 'isOwner' : True , 'color' : '#F2B04B' , 'inAll' : True , 'sortOrder' : - 7885694173184 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : 'aenkajam' , 'modifiedTime' : '2021-01-13T00:40:49.843+0000' , 'closed' : True , 'muted' : False , 'transferred' : None , 'groupId' : None , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }] Before After Source code in managers/projects.py def archive ( self , ids ): \"\"\" Moves the project(s) to a project folder created by `TickTick` called \"Archived Lists\" To unarchive a project, change its `'closed'` field to `True`, then [update][managers.projects.ProjectManager.update] Arguments: ids (str or list): **Single Project (str)**: ID string of the project to archive. **Multiple Projects (list)**: List of ID strings of the projects to archive. Returns: dict or list: **Single Project (dict)**: Dictionary of the archived object. **Multiple Projects (list)**: List of dictionaries of the archived objects. Raises: TypeError: If `ids` is not a string or list. ValueError: If the project(s) don't already exist RuntimeError: If the project(s) could not be successfully archived. !!! example === \"Single Project Archive\" ```python # Lets assume there is a project that exists named \"Reading\" reading_project = client.get_by_fields(name=\"Reading\", search=\"projects\") reading_project_id = reading_project['id'] archived = client.project.archive(reading_project_id) ``` ??? success \"Result\" A single dictionary is returned. ```python {'id': '5ffe1673e4b062d60dd29dc0', 'name': 'Reading', 'isOwner': True, 'color': '#51b9e3', 'inAll': True, 'sortOrder': 0, 'sortType': 'sortOrder', 'userCount': 1, 'etag': 'c9tgze9b', 'modifiedTime': '2021-01-13T00:34:50.449+0000', 'closed': True, 'muted': False, 'transferred': None, 'groupId': None, 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'} ``` **Before** [![archive-before.png](https://i.postimg.cc/R0jfVt7W/archive-before.png)](https://postimg.cc/B8BtmXw3) **After** [![archived-after.png](https://i.postimg.cc/xjPkBh4J/archived-after.png)](https://postimg.cc/K4RvMqFx) === \"Multiple Project Archive\" ```python # Lets assume there is a project that exists named \"Reading\" reading_project = client.get_by_fields(name=\"Reading\", search=\"projects\") reading_project_id = reading_project['id'] # Lets assume another project exists named \"Writing\" writing_project = client.get_by_fields(name='Writing', search='projects') writing_project_id = writing_project['id'] # Archiving multiple requires putting the ID's in a list. archive_list = [reading_project_id, writing_project_id] archived = client.project.archive(archive_list) ``` ??? success \"Result\" A list of dictionary objects is returned. ```python [{'id': '5ffe1673e4b062d60dd29dc0', 'name': 'Reading', 'isOwner': True, 'color': '#51b9e3', 'inAll': True, 'sortOrder': -7335938359296, 'sortType': 'sortOrder', 'userCount': 1, 'etag': 'qrga45as', 'modifiedTime': '2021-01-13T00:40:49.839+0000', 'closed': True, 'muted': False, 'transferred': None, 'groupId': None, 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}, {'id': '5ffe41328f08237f3d147e33', 'name': 'Writing', 'isOwner': True, 'color': '#F2B04B', 'inAll': True, 'sortOrder': -7885694173184, 'sortType': 'sortOrder', 'userCount': 1, 'etag': 'aenkajam', 'modifiedTime': '2021-01-13T00:40:49.843+0000', 'closed': True, 'muted': False, 'transferred': None, 'groupId': None, 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}] ``` **Before** [![archive-multiple-before.png](https://i.postimg.cc/sgHHmnrb/archive-multiple-before.png)](https://postimg.cc/qNnGMxgG) **After** [![archived-multiple-after.png](https://i.postimg.cc/tg1SMhRJ/archived-multiple-after.png)](https://postimg.cc/rdkNdRr2) \"\"\" if not isinstance ( ids , str ) and not isinstance ( ids , list ): raise TypeError ( 'Ids Must Be A String or List Of Strings' ) objs = [] if isinstance ( ids , str ): proj = self . _client . get_by_fields ( id = ids , search = 'projects' ) if not proj : raise ValueError ( f \"Project ' { ids } ' Does Not Exist To Archive\" ) # Change the list to archived proj [ 'closed' ] = True objs = [ proj ] else : for i in ids : proj = self . _client . get_by_fields ( id = i , search = 'projects' ) if not proj : raise ValueError ( f \"Project ' { i } ' Does Not Exist To Archive\" ) proj [ 'closed' ] = True objs . append ( proj ) return self . update ( objs )","title":"archive()"},{"location":"usage/projects/#managers.projects.ProjectManager.builder","text":"Creates and returns a local project object. Helper method for create to make batch creating projects easier. Note The project folder must already exist prior to calling this method. Parameters: Name Type Description Default name str Desired name of the project - project names cannot be repeated required color str Hex color string. A random color will be generated if no color is specified. 'random' project_type str 'TASK' or 'NOTE' 'TASK' folder_id str The project folder id that the project should be placed under (if desired) None Returns: Type Description dict A dictionary containing all the fields necessary to create a remote project. Exceptions: Type Description TypeError If any of the types of the arguments are wrong. ValueError Project name already exists ValueError Project Folder corresponding to the ID does not exist. ValueError The hex string color inputted is invalid. Argument rules are shared with create , so for more examples on how to use the arguments see that method. Example project_name = 'Work' # The name of our project # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) productivity_id = productivity_folder [ 'id' ] # Build the object project_object = client . project . builder ( project_name , folder_id = productivity_id ) Result # The fields needed for a successful project creation are set. { 'name' : 'Work' , 'color' : '#665122' , 'kind' : 'TASK' , 'groupId' : '5ffe11b7b04b356ce74d49da' } Source code in managers/projects.py def builder ( self , name : str , color : str = 'random' , project_type : str = 'TASK' , folder_id : str = None ) -> dict : \"\"\" Creates and returns a local project object. Helper method for [create][managers.projects.ProjectManager.create] to make batch creating projects easier. !!! note The project [folder][managers.projects.ProjectManager.create_folder] must already exist prior to calling this method. Arguments: name: Desired name of the project - project names cannot be repeated color: Hex color string. A random color will be generated if no color is specified. project_type: 'TASK' or 'NOTE' folder_id: The project folder id that the project should be placed under (if desired) Returns: A dictionary containing all the fields necessary to create a remote project. Raises: TypeError: If any of the types of the arguments are wrong. ValueError: Project name already exists ValueError: Project Folder corresponding to the ID does not exist. ValueError: The hex string color inputted is invalid. Argument rules are shared with [create][managers.projects.ProjectManager.create], so for more examples on how to use the arguments see that method. !!! example ```python project_name = 'Work' # The name of our project # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') productivity_id = productivity_folder['id'] # Build the object project_object = client.project.builder(project_name, folder_id=productivity_id) ``` ??? success \"Result\" ```python # The fields needed for a successful project creation are set. {'name': 'Work', 'color': '#665122', 'kind': 'TASK', 'groupId': '5ffe11b7b04b356ce74d49da'} ``` \"\"\" if not isinstance ( name , str ): raise TypeError ( \"Name must be a string\" ) if not isinstance ( color , str ) and color is not None : raise TypeError ( \"Color must be a string\" ) if not isinstance ( project_type , str ): raise TypeError ( \"Project type must be a string\" ) if not isinstance ( folder_id , str ) and folder_id is not None : raise TypeError ( \"Folder id must be a string\" ) # Go through self.state['lists'] and determine if the name already exists id_list = self . _client . get_by_fields ( search = 'projects' , name = name ) if id_list : raise ValueError ( f \"Invalid Project Name ' { name } ' -> It Already Exists\" ) # Determine if parent list exists if folder_id is not None : parent = self . _client . get_by_id ( folder_id , search = 'project_folders' ) if not parent : raise ValueError ( f \"Parent Id { folder_id } Does Not Exist\" ) # Make sure project type is valid if project_type != 'TASK' and project_type != 'NOTE' : raise ValueError ( f \"Invalid Project Type ' { project_type } ' -> Should be 'TASK' or 'NOTE'\" ) # Check color_id if color == 'random' : color = generate_hex_color () # Random color will be generated elif color is not None : if not check_hex_color ( color ): raise ValueError ( 'Invalid Hex Color String' ) return { 'name' : name , 'color' : color , 'kind' : project_type , 'groupId' : folder_id }","title":"builder()"},{"location":"usage/projects/#managers.projects.ProjectManager.create","text":"Creates a project remotely. Supports single project creation or batch project creation. Parameters: Name Type Description Default name str or list Single Project (str) : The desired name of the project. Project names cannot be repeated. Multiple Projects (list) : A list of project objects created using the builder method. required color str Hex color string. A random color will be generated if no color is specified. 'random' project_type str 'TASK' or 'NOTE' 'TASK' folder_id str The project folder id that the project should be placed under (if desired) None Returns: Type Description dict or list Single Project : Return the dictionary of the object. Multiple Projects : Return a list of dictionaries containing all the created objects in the same order as created. Exceptions: Type Description TypeError If any of the types of the arguments are wrong. ValueError Project name already exists ValueError Project Folder corresponding to the ID does not exist. ValueError The hex string color inputted is invalid. RuntimeError The project(s) could not be created. Single Project Just A Name project = client . project . create ( 'School' ) Result # The dictionary object of the created project is returned. { 'id' : '5ffe1673e4b062d60dd29dc0' , 'name' : 'School' , 'isOwner' : True , 'color' : '#51b9e3' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'uerkdkcd' , 'modifiedTime' : '2021-01-12T21:36:51.890+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : None , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' } Our project is created. Specify a Color A random color can be generated using generate_hex_color . However, just not specifying a color will automatically generate a random color (as seen in the previous tab). You can always specify the color that you want. project = client . project . create ( 'Work' , color = '#86bb6d' ) Result Our project is created with the color specified. Changing the Project Type The default project type is for Tasks. To change the type to handle Notes, pass in the string 'NOTE' project = client . project . create ( 'Hobbies' , project_type = 'NOTE' ) Result The project type is now for notes. Creating Inside of A Folder Note For folder_id The project folder must already exist prior to calling this method. project_name = 'Day Job' # The name of our project # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) productivity_id = productivity_folder [ 'id' ] # Create the object project_object = client . project . create ( project_name , folder_id = productivity_id ) Result The project was created in the group folder. Multiple Projects (batch) To create multiple projects, you will need to build the projects locally prior to calling the create method. This can be accomplished using the builder method. Pass in a list of the locally created project objects to create them remotely. (Again About Folders) The project folders should already be created prior to calling the create method. # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) productivity_id = productivity_folder [ 'id' ] # Names of our projects name_1 = 'Reading' name_2 = 'Writing' # Build the local projects project1 = client . project . builder ( name_1 , folder_id = productivity_id ) project2 = client . project . builder ( name_2 , folder_id = productivity_id ) project_list = [ project1 , project2 ] # Create the projects project_object = client . project . create ( project_list ) Result When multiple projects are created, the dictionaries will be returned in a list in the same order as the input. [{ 'id' : '5ffe24a18f081003f3294c44' , 'name' : 'Reading' , 'isOwner' : True , 'color' : '#6fcbdf' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'qbj4z0gl' , 'modifiedTime' : '2021-01-12T22:37:21.823+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }, { 'id' : '5ffe24a18f081003f3294c46' , 'name' : 'Writing' , 'isOwner' : True , 'color' : '#9730ce' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'u0loxz2v' , 'modifiedTime' : '2021-01-12T22:37:21.827+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }] Source code in managers/projects.py def create ( self , name , color : str = 'random' , project_type : str = 'TASK' , folder_id : str = None ): \"\"\" Creates a project remotely. Supports single project creation or batch project creation. Arguments: name (str or list): **Single Project** (str) : The desired name of the project. Project names cannot be repeated. **Multiple Projects** (list) : A list of project objects created using the [builder][managers.projects.ProjectManager.builder] method. color: Hex color string. A random color will be generated if no color is specified. project_type: 'TASK' or 'NOTE' folder_id: The project folder id that the project should be placed under (if desired) Returns: dict or list: **Single Project**: Return the dictionary of the object. **Multiple Projects**: Return a list of dictionaries containing all the created objects in the same order as created. Raises: TypeError: If any of the types of the arguments are wrong. ValueError: Project name already exists ValueError: Project Folder corresponding to the ID does not exist. ValueError: The hex string color inputted is invalid. RuntimeError: The project(s) could not be created. !!! example \"Single Project\" === \"Just A Name\" ```python project = client.project.create('School') ``` ??? success \"Result\" ```python # The dictionary object of the created project is returned. {'id': '5ffe1673e4b062d60dd29dc0', 'name': 'School', 'isOwner': True, 'color': '#51b9e3', 'inAll': True, 'sortOrder': 0, 'sortType': None, 'userCount': 1, 'etag': 'uerkdkcd', 'modifiedTime': '2021-01-12T21:36:51.890+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': None, 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'} ``` Our project is created. [![project-create.png](https://i.postimg.cc/d1NNqN7F/project-create.png)](https://postimg.cc/PpZQy4zV) === \"Specify a Color\" A random color can be generated using [generate_hex_color][helpers.hex_color.generate_hex_color]. However, just not specifying a color will automatically generate a random color (as seen in the previous tab). You can always specify the color that you want. ```python project = client.project.create('Work', color='#86bb6d') ``` ??? success \"Result\" Our project is created with the color specified. [![project-color.png](https://i.postimg.cc/K8ppnvrb/project-color.png)](https://postimg.cc/5XvmJJRK) === \"Changing the Project Type\" The default project type is for Tasks. To change the type to handle Notes, pass in the string 'NOTE' ```python project = client.project.create('Hobbies', project_type='NOTE') ``` ??? success \"Result\" The project type is now for notes. [![project-note.png](https://i.postimg.cc/fy0Mhrzt/project-note.png)](https://postimg.cc/rRcB1gtM) === \"Creating Inside of A Folder\" !!! warning \"Note For `folder_id`\" The project [folder][managers.projects.ProjectManager.create_folder] must already exist prior to calling this method. ```python project_name = 'Day Job' # The name of our project # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') productivity_id = productivity_folder['id'] # Create the object project_object = client.project.create(project_name, folder_id=productivity_id) ``` ??? success \"Result\" The project was created in the group folder. [![project-create-with-folder.png](https://i.postimg.cc/mr53rmfN/project-create-with-folder.png)](https://postimg.cc/rd5RnCpK) !!! example \"Multiple Projects (batch)\" To create multiple projects, you will need to build the projects locally prior to calling the `create` method. This can be accomplished using the [builder][managers.projects.ProjectManager.builder] method. Pass in a list of the locally created project objects to create them remotely. !!! warning \"(Again About Folders)\" The project folders should already be created prior to calling the create method. ```python # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') productivity_id = productivity_folder['id'] # Names of our projects name_1 = 'Reading' name_2 = 'Writing' # Build the local projects project1 = client.project.builder(name_1, folder_id=productivity_id) project2 = client.project.builder(name_2, folder_id=productivity_id) project_list = [project1, project2] # Create the projects project_object = client.project.create(project_list) ``` ??? success \"Result\" When multiple projects are created, the dictionaries will be returned in a list in the same order as the input. ```python [{'id': '5ffe24a18f081003f3294c44', 'name': 'Reading', 'isOwner': True, 'color': '#6fcbdf', 'inAll': True, 'sortOrder': 0, 'sortType': None, 'userCount': 1, 'etag': 'qbj4z0gl', 'modifiedTime': '2021-01-12T22:37:21.823+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe11b7b04b356ce74d49da', 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}, {'id': '5ffe24a18f081003f3294c46', 'name': 'Writing', 'isOwner': True, 'color': '#9730ce', 'inAll': True, 'sortOrder': 0, 'sortType': None, 'userCount': 1, 'etag': 'u0loxz2v', 'modifiedTime': '2021-01-12T22:37:21.827+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe11b7b04b356ce74d49da', 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}] ``` [![project-batch-create.png](https://i.postimg.cc/8CHH8xSZ/project-batch-create.png)](https://postimg.cc/d7hdrHDC) \"\"\" if isinstance ( name , list ): # If task name is a list, we will batch create objects obj = name batch = True # Create the single project object elif isinstance ( name , str ): batch = False obj = self . builder ( name = name , color = color , project_type = project_type , folder_id = folder_id ) obj = [ obj ] else : raise TypeError ( f \"Required Positional Argument Must Be A String or List of Project Objects\" ) url = self . _client . BASE_URL + 'batch/project' payload = { 'add' : obj } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () if len ( obj ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'projects' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Get the ids items = [ '' ] * len ( obj ) # Create enough spots for the objects for proj_id in etag2 : found = self . _client . get_by_id ( proj_id , search = 'projects' ) for original in obj : if found [ 'name' ] == original [ 'name' ]: # Get the index of original index = obj . index ( original ) # Place found at the index in return list items [ index ] = found return items","title":"create()"},{"location":"usage/projects/#managers.projects.ProjectManager.create_folder","text":"Creates a project folder to allow for project grouping. Project folder names can be repeated. Parameters: Name Type Description Default name str or list Single Folder (str) : A string for the name of the folder Multiple Folders (list) : A list of strings for names of the folders. required Returns: Type Description dict or list Single Folder (dict) : A dictionary for the created folder. Multiple Folders (list) : A list of dictionaries for the created folders. Exceptions: Type Description TypeError If name is not a string or list RuntimeError If the folder(s) could not be created. Example Creating a Single Folder A single string for the name is the only parameter needed. project_folder = client . project . create_folder ( 'Productivity' ) Result A single dictionary is returned. { 'id' : '5ffe44528f089fb5795c45bf' , 'etag' : '9eun9kyc' , 'name' : 'Productivity' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 115781412 , 'sortType' : 'project' , 'teamId' : None } Creating Multiple Folders The desired names of the folders are passed to create as a list. names = [ 'Productivity' , 'School' , 'Hobbies' ] project_folder = client . project . create_folder ( names ) Result A list of dictionaries containing the foler objects is returned. [{ 'id' : '5ffe45d6e4b062d60dd3ce15' , 'etag' : '4nvnuiw1' , 'name' : 'Productivity' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }, { 'id' : '5ffe45d6e4b062d60dd3ce16' , 'etag' : 's072l3pu' , 'name' : 'School' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }, { 'id' : '5ffe45d6e4b062d60dd3ce17' , 'etag' : '12t1xmt9' , 'name' : 'Hobbies' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }] Source code in managers/projects.py def create_folder ( self , name ): \"\"\" Creates a project folder to allow for project grouping. Project folder names can be repeated. Arguments: name (str or list): **Single Folder (str)**: A string for the name of the folder **Multiple Folders (list)**: A list of strings for names of the folders. Returns: dict or list: **Single Folder (dict)**: A dictionary for the created folder. **Multiple Folders (list)**: A list of dictionaries for the created folders. Raises: TypeError: If `name` is not a string or list RuntimeError: If the folder(s) could not be created. !!! example === \"Creating a Single Folder\" A single string for the name is the only parameter needed. ```python project_folder = client.project.create_folder('Productivity') ``` ??? success \"Result\" A single dictionary is returned. ```python {'id': '5ffe44528f089fb5795c45bf', 'etag': '9eun9kyc', 'name': 'Productivity', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 115781412, 'sortType': 'project', 'teamId': None} ``` [![folder.png](https://i.postimg.cc/HWRTjtRW/folder.png)](https://postimg.cc/c6RpbfdP) === \"Creating Multiple Folders\" The desired names of the folders are passed to create as a list. ```python names = ['Productivity', 'School', 'Hobbies'] project_folder = client.project.create_folder(names) ``` ??? success \"Result\" A list of dictionaries containing the foler objects is returned. ```python [{'id': '5ffe45d6e4b062d60dd3ce15', 'etag': '4nvnuiw1', 'name': 'Productivity', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}, {'id': '5ffe45d6e4b062d60dd3ce16', 'etag': 's072l3pu', 'name': 'School', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}, {'id': '5ffe45d6e4b062d60dd3ce17', 'etag': '12t1xmt9', 'name': 'Hobbies', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}] ``` [![folders-multiple.png](https://i.postimg.cc/2jwXKjds/folders-multiple.png)](https://postimg.cc/0rzf6sBn) \"\"\" if not isinstance ( name , str ) and not isinstance ( name , list ): raise TypeError ( 'Name Must Be A String or List Of Strings' ) objs = [] if isinstance ( name , str ): names = { 'name' : name , 'listType' : 'group' } objs = [ names ] else : for nm in name : objs . append ({ 'name' : nm , 'listType' : 'group' }) url = self . _client . BASE_URL + 'batch/projectGroup' payload = { 'add' : objs } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () if len ( objs ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'project_folders' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Get the ids items = [ '' ] * len ( objs ) # Create enough spots for the objects for proj_id in etag2 : found = self . _client . get_by_id ( proj_id , search = 'project_folders' ) for original in objs : if found [ 'name' ] == original [ 'name' ]: # Get the index of original index = objs . index ( original ) # Place found at the index in return list items [ index ] = found return items","title":"create_folder()"},{"location":"usage/projects/#managers.projects.ProjectManager.delete","text":"Deletes the project(s) with the passed ID string. Warning Tasks will be deleted from the project. If you want to preserve the tasks before deletion, use move_all Parameters: Name Type Description Default ids str or list Single Deletion (str) : ID string of the project Multiple Deletions (list) : List of ID strings of projects to be deleted. required Returns: Type Description dict or list Single Deletion (dict) : Dictionary of the deleted project. Multiple Deletions (list) : A list of dictionaries of the deleted projects. Exceptions: Type Description TypeError If ids is not a string or list of strings ValueError If ids does not exist. RuntimeError If the deletion was not successful. Example Single Project Deletion # Lets assume that we have a project that exists named 'School' school = client . get_by_fields ( name = 'School' , search = 'projects' ) # Get the project object project_id = school [ 'id' ] # Get the project id delete = client . project . delete ( project_id ) A dictionary of the deleted project object will be returned. Multiple Project Deletion # Lets assume that we have two projects that we want to delete: 'School' and 'Work' school = client . get_by_fields ( name = 'School' , search = 'projects' ) # Get the project object work = client . get_by_fields ( name = 'Work' , search = 'projects' ) delete_ids = [ school [ 'id' ], work [ 'id' ]] # A list of the ID strings of the projects to be deleted delete = client . project . delete ( delete_ids ) A list of the deleted dictionary objects will be returned. Source code in managers/projects.py def delete ( self , ids ): \"\"\" Deletes the project(s) with the passed ID string. !!! warning [Tasks](tasks.md) will be deleted from the project. If you want to preserve the tasks before deletion, use [move_all][managers.tasks.TaskManager.move_all] Arguments: ids (str or list): **Single Deletion (str)**: ID string of the project **Multiple Deletions (list)**: List of ID strings of projects to be deleted. Returns: dict or list: **Single Deletion (dict)**: Dictionary of the deleted project. **Multiple Deletions (list)**: A list of dictionaries of the deleted projects. Raises: TypeError: If `ids` is not a string or list of strings ValueError: If `ids` does not exist. RuntimeError: If the deletion was not successful. !!! example === \"Single Project Deletion\" ```python # Lets assume that we have a project that exists named 'School' school = client.get_by_fields(name='School', search='projects') # Get the project object project_id = school['id'] # Get the project id delete = client.project.delete(project_id) ``` A dictionary of the deleted project object will be returned. === \"Multiple Project Deletion\" ```python # Lets assume that we have two projects that we want to delete: 'School' and 'Work' school = client.get_by_fields(name='School', search='projects') # Get the project object work = client.get_by_fields(name='Work', search='projects') delete_ids = [school['id'], work['id']] # A list of the ID strings of the projects to be deleted delete = client.project.delete(delete_ids) ``` A list of the deleted dictionary objects will be returned. \"\"\" if not isinstance ( ids , str ) and not isinstance ( ids , list ): raise TypeError ( 'Ids Must Be A String or List Of Strings' ) if isinstance ( ids , str ): proj = self . _client . get_by_fields ( id = ids , search = 'projects' ) if not proj : raise ValueError ( f \"Project ' { ids } ' Does Not Exist To Delete\" ) ids = [ ids ] else : for i in ids : proj = self . _client . get_by_fields ( id = i , search = 'projects' ) if not proj : raise ValueError ( f \"Project ' { i } ' Does Not Exist To Delete\" ) # Delete the task url = self . _client . BASE_URL + 'batch/project' payload = { 'delete' : ids } self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) # Delete the list deleted_list = [] for current_id in ids : tasks = self . _client . task . get_from_project ( current_id ) for task in tasks : self . _client . delete_from_local_state ( id = task [ 'id' ], search = 'tasks' ) deleted_list . append ( self . _client . delete_from_local_state ( id = current_id , search = 'projects' )) if len ( deleted_list ) == 1 : return deleted_list [ 0 ] else : return deleted_list","title":"delete()"},{"location":"usage/projects/#managers.projects.ProjectManager.delete_folder","text":"Deletes the folder(s). Tip Any projects inside of the folder will be preserved - they will just not be grouped anymore. Parameters: Name Type Description Default ids str or list Single Folder (str) : The ID of the folder to be deleted. Multiple Folders (list) : A list containing the ID strings of the folders to be deleted. required Returns: Type Description dict or list Single Folder (dict) : The dictionary object for the deleted folder. Multiple Folders (list) : A list of dictionary objects of the deleted folders. Exceptions: Type Description TypeError If ids is not a str or list ValueError If ids does not match an actual folder object. RunTimeError If the folders could not be successfully deleted. Folder Deletion Single Folder Deletion Pass in the ID of the folder object to delete it remotely. # Lets assume we have a folder named \"Productivity\" project_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) # Get the project folder deleted_folder = client . project . delete_folder ( project_folder [ 'id' ]) Result The folder is deleted, and a single dictionary of the deleted folder object is returned. { 'id' : '5ffe75008f089fb5795d544a' , 'etag' : 'e95rdzi7' , 'name' : 'Productivity' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None } Before After The project inside still exists. Multiple Folder Deletion Pass in the list of ID strings of the folders to be deleted. # Lets assume that we have two folders that already exist: \"Productivity\" and \"Hobbies\" productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) hobbies_folder = client . get_by_fields ( name = 'Hobbies' , search = 'project_folders' ) ids = [ productivity_folder [ 'id' ], hobbies_folder [ 'id' ]] deleted_folders = client . project . delete_folder ( ids ) Result The folders are deleted, and a list of dictionaries for the deleted folder objects are returned. [{ 'id' : '5ffe79d78f08237f3d1636ad' , 'etag' : '2o2dn2al' , 'name' : 'Productivity' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }, { 'id' : '5ffe79d78f08237f3d1636ae' , 'etag' : 'mah5a78l' , 'name' : 'Hobbies' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }] Before After All folders deleted and all projects retained. Source code in managers/projects.py def delete_folder ( self , ids ): \"\"\" Deletes the folder(s). !!! tip Any projects inside of the folder will be preserved - they will just not be grouped anymore. Arguments: ids (str or list): **Single Folder (str)**: The ID of the folder to be deleted. **Multiple Folders (list)**: A list containing the ID strings of the folders to be deleted. Returns: dict or list: **Single Folder (dict)**: The dictionary object for the deleted folder. **Multiple Folders (list)**: A list of dictionary objects of the deleted folders. Raises: TypeError: If `ids` is not a str or list ValueError: If `ids` does not match an actual folder object. RunTimeError: If the folders could not be successfully deleted. !!! example \"Folder Deletion\" === \"Single Folder Deletion\" Pass in the ID of the folder object to delete it remotely. ```python # Lets assume we have a folder named \"Productivity\" project_folder = client.get_by_fields(name='Productivity', search='project_folders') # Get the project folder deleted_folder = client.project.delete_folder(project_folder['id']) ``` ??? success \"Result\" The folder is deleted, and a single dictionary of the deleted folder object is returned. ```python {'id': '5ffe75008f089fb5795d544a', 'etag': 'e95rdzi7', 'name': 'Productivity', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104407093-b5573e80-5515-11eb-99dc-16ca4f33d06a.png) **After** The project inside still exists. ![image](https://user-images.githubusercontent.com/56806733/104407123-c607b480-5515-11eb-92ff-15df1d41b404.png) === \"Multiple Folder Deletion\" Pass in the list of ID strings of the folders to be deleted. ```python # Lets assume that we have two folders that already exist: \"Productivity\" and \"Hobbies\" productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') hobbies_folder = client.get_by_fields(name='Hobbies', search='project_folders') ids = [productivity_folder['id'], hobbies_folder['id']] deleted_folders = client.project.delete_folder(ids) ``` ??? success \"Result\" The folders are deleted, and a list of dictionaries for the deleted folder objects are returned. ```python [{'id': '5ffe79d78f08237f3d1636ad', 'etag': '2o2dn2al', 'name': 'Productivity', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}, {'id': '5ffe79d78f08237f3d1636ae', 'etag': 'mah5a78l', 'name': 'Hobbies', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104407469-8097b700-5516-11eb-9919-069e5beb3b8a.png) **After** All folders deleted and all projects retained. ![image](https://user-images.githubusercontent.com/56806733/104407546-a8871a80-5516-11eb-815b-4df41e3d797a.png) \"\"\" if not isinstance ( ids , str ) and not isinstance ( ids , list ): raise TypeError ( 'Ids Must Be A String or List Of Strings' ) if isinstance ( ids , str ): proj = self . _client . get_by_fields ( id = ids , search = 'project_folders' ) if not proj : raise ValueError ( f \"Project Folder ' { ids } ' Does Not Exist To Delete\" ) ids = [ ids ] else : for i in ids : proj = self . _client . get_by_fields ( id = i , search = 'project_folders' ) if not proj : raise ValueError ( f \"Project Folder ' { i } ' Does Not Exist To Delete\" ) url = self . _client . BASE_URL + 'batch/projectGroup' payload = { 'delete' : ids } self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) # Delete the list deleted_list = [] for current_id in ids : deleted_list . append ( self . _client . get_by_id ( current_id , search = 'project_folders' )) self . _client . sync () if len ( deleted_list ) == 1 : return deleted_list [ 0 ] else : return deleted_list","title":"delete_folder()"},{"location":"usage/projects/#managers.projects.ProjectManager.update","text":"Updates the passed project(s). Supports single project update and multiple project update (batch) Make local changes to the project objects that you want to change first, then pass the actual objects to the method. Info Every potential update to a project's attributes have not been tested. See Example TickTick Project Dictionary for a listing of the fields present in a project. Parameters: Name Type Description Default obj dict or list Single Project (dict) : The project dictionary. Multiple Projects (list) : A list of project dictionaries. required Returns: Type Description dict or list Single Project (dict) : The updated project dictionary Multiple Projects (list) : A list containing the updated project dictionaries. Exceptions: Type Description TypeError If the input is not a dict or a list. RuntimeError If the projects could not be updated successfully. Updates are done by changing the fields in the objects locally first. Single Project Update Changing The Name # Lets assume that we have a project named \"Reading\" that we want to change to \"Summer Reading\" project = client . get_by_fields ( name = 'Reading' , search = 'projects' ) # Get the project # Now lets change the name project [ 'name' ] = 'Summer Reading' # Updating a single project requires just passing in the entire dictionary. updated = client . project . update ( project ) Result The dictionary is returned and the name changed remotely. { 'id' : '5ffe24a18f081003f3294c44' , 'name' : 'Summer Reading' , 'isOwner' : True , 'color' : '#6fcbdf' , 'inAll' : True , 'sortOrder' : - 6236426731520 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : '0vbsvn8e' , 'modifiedTime' : '2021-01-12T23:38:16.456+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe2d37b04b35082bbcdf74' , 'viewMode' : 'list' , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' } Before After Multiple Project Update Changing Multiple Names # Lets assume that we have a project named \"Writing\" that we want to change to \"Summer Reading\" project = client . get_by_fields ( name = 'Writing' , search = 'projects' ) # Get the project project [ 'name' ] = 'Summer Writing' # Lets assume that we have a project named \"Movies\" that we want to change to \"Summer Movies\" movie_project = client . get_by_fields ( name = 'Movies' , search = 'projects' ) movie_project [ 'name' ] = 'Summer Movies' # Updating multiple projects requires passing the projects in a list. update_list = [ project , movie_project ] # Lets update remotely now updated_projects = client . project . update ( update_list ) Result A list containing the updated projects is returned. [{ 'id' : '5ffe24a18f081003f3294c46' , 'name' : 'Summer Reading' , 'isOwner' : True , 'color' : '#9730ce' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'bgl0pkm8' , 'modifiedTime' : '2021-01-13T00:13:29.796+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }, { 'id' : '5ffe399c8f08237f3d144ece' , 'name' : 'Summer Movies' , 'isOwner' : True , 'color' : '#F18181' , 'inAll' : True , 'sortOrder' : - 2843335458816 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : 'jmjy1xtc' , 'modifiedTime' : '2021-01-13T00:13:29.800+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }] Before After Source code in managers/projects.py def update ( self , obj ): \"\"\" Updates the passed project(s). Supports single project update and multiple project update (batch) Make local changes to the project objects that you want to change first, then pass the actual objects to the method. !!! info Every potential update to a project's attributes have not been tested. See [Example `TickTick` Project Dictionary](projects.md#example-ticktick-project-dictionary) for a listing of the fields present in a project. Arguments: obj (dict or list): **Single Project (dict)**: The project dictionary. **Multiple Projects (list)**: A list of project dictionaries. Returns: dict or list: **Single Project (dict)**: The updated project dictionary **Multiple Projects (list)**: A list containing the updated project dictionaries. Raises: TypeError: If the input is not a dict or a list. RuntimeError: If the projects could not be updated successfully. Updates are done by changing the fields in the objects locally first. !!! example \"Single Project Update\" === \"Changing The Name\" ```python # Lets assume that we have a project named \"Reading\" that we want to change to \"Summer Reading\" project = client.get_by_fields(name='Reading', search='projects') # Get the project # Now lets change the name project['name'] = 'Summer Reading' # Updating a single project requires just passing in the entire dictionary. updated = client.project.update(project) ``` ??? success \"Result\" The dictionary is returned and the name changed remotely. ```python {'id': '5ffe24a18f081003f3294c44', 'name': 'Summer Reading', 'isOwner': True, 'color': '#6fcbdf', 'inAll': True, 'sortOrder': -6236426731520, 'sortType': 'sortOrder', 'userCount': 1, 'etag': '0vbsvn8e', 'modifiedTime': '2021-01-12T23:38:16.456+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe2d37b04b35082bbcdf74', 'viewMode': 'list', 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'} ``` **Before** [![project-update-before.png](https://i.postimg.cc/K8hcpzvP/project-update-before.png)](https://postimg.cc/crTNrd3C) **After** [![project-update-after.png](https://i.postimg.cc/DwcWqsdJ/project-update-after.png)](https://postimg.cc/FY7svY6N) !!! example \"Multiple Project Update\" === \"Changing Multiple Names\" ```python # Lets assume that we have a project named \"Writing\" that we want to change to \"Summer Reading\" project = client.get_by_fields(name='Writing', search='projects') # Get the project project['name'] = 'Summer Writing' # Lets assume that we have a project named \"Movies\" that we want to change to \"Summer Movies\" movie_project = client.get_by_fields(name='Movies', search='projects') movie_project['name'] = 'Summer Movies' # Updating multiple projects requires passing the projects in a list. update_list = [project, movie_project] # Lets update remotely now updated_projects = client.project.update(update_list) ``` ??? success \"Result\" A list containing the updated projects is returned. ```python [{'id': '5ffe24a18f081003f3294c46', 'name': 'Summer Reading', 'isOwner': True, 'color': '#9730ce', 'inAll': True, 'sortOrder': 0, 'sortType': None, 'userCount': 1, 'etag': 'bgl0pkm8', 'modifiedTime': '2021-01-13T00:13:29.796+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe11b7b04b356ce74d49da', 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}, {'id': '5ffe399c8f08237f3d144ece', 'name': 'Summer Movies', 'isOwner': True, 'color': '#F18181', 'inAll': True, 'sortOrder': -2843335458816, 'sortType': 'sortOrder', 'userCount': 1, 'etag': 'jmjy1xtc', 'modifiedTime': '2021-01-13T00:13:29.800+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe11b7b04b356ce74d49da', 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}] ``` **Before** [![project-update-multiople.png](https://i.postimg.cc/9QbcJH81/project-update-multiople.png)](https://postimg.cc/zyLmG61R) **After** [![project-update-multiple-after.png](https://i.postimg.cc/3RVGNv2y/project-update-multiple-after.png)](https://postimg.cc/0MGjHrWx) \"\"\" # Check the types if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( \"Project objects must be a dict or list of dicts.\" ) if isinstance ( obj , dict ): tasks = [ obj ] else : tasks = obj url = self . _client . BASE_URL + 'batch/project' payload = { 'update' : tasks } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () if len ( tasks ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'projects' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Get the ids items = [ '' ] * len ( obj ) # Create enough spots for the objects for proj_id in etag2 : found = self . _client . get_by_id ( proj_id , search = 'projects' ) for original in obj : if found [ 'name' ] == original [ 'name' ]: # Get the index of original index = obj . index ( original ) # Place found at the index in return list items [ index ] = found return items","title":"update()"},{"location":"usage/projects/#managers.projects.ProjectManager.update_folder","text":"Updates the project folders(s) remotely based off changes made locally. Make the changes you want to the project folder(s) first. Parameters: Name Type Description Default obj dict or list Single Folder (dict) : The dictionary object of the folder to update. Multiple Folders (list) : A list containing dictionary objects of folders to update. required Returns: Type Description dict or list Single Folder (dict) : The dictionary object of the updated folder. Multiple Folders (list) : A list of dictionary objects corresponding to the updated folders. Exceptions: Type Description TypeError If obj is not a dictionary or list RuntimeError If the updating was unsuccessful. Updating A Project Folder Single Folder Update # Lets assume that we have a folder called \"Productivity\" productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) # Lets change the name to \"Hobbies\" productivity_folder [ 'name' ] = \"Hobbies\" # Update updated_folder = client . project . update_folder ( productivity_folder ) Result The dictionary of the updated folder is returned. { 'id' : '5ffe7dab8f089fb5795d8ef2' , 'etag' : 'r9xl60e5' , 'name' : 'Hobbies' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None } Before After Multiple Folder Update # Lets assume that we have a folder called \"Productivity\" productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) # Lets assume that we have another folder called \"Games\" games_folder = client . get_by_fields ( name = 'Games' , search = 'project_folders' ) # Lets change the \"Productivity\" folder to \"Work\" productivity_folder [ 'name' ] = \"Work\" # Lets change the \"Games\" folder to \"Hobbies\" games_folder [ 'name' ] = \"Hobbies\" update_list = [ productivity_folder , games_folder ] # List of objects to update # Update updated_folder = client . project . update_folder ( update_list ) Result A list of the updated folder objects is returned. [{ 'id' : '5ffe80ce8f08068e86aab288' , 'etag' : '0oh0pxel' , 'name' : 'Work' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }, { 'id' : '5ffe80cf8f08068e86aab289' , 'etag' : 'xwvehtfo' , 'name' : 'Hobbies' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }] Before After Source code in managers/projects.py def update_folder ( self , obj ): \"\"\" Updates the project folders(s) remotely based off changes made locally. Make the changes you want to the project folder(s) first. Arguments: obj (dict or list): **Single Folder (dict)**: The dictionary object of the folder to update. **Multiple Folders (list)**: A list containing dictionary objects of folders to update. Returns: dict or list: **Single Folder (dict)**: The dictionary object of the updated folder. **Multiple Folders (list)**: A list of dictionary objects corresponding to the updated folders. Raises: TypeError: If `obj` is not a dictionary or list RuntimeError: If the updating was unsuccessful. !!! example \"Updating A Project Folder\" === \"Single Folder Update\" ```python # Lets assume that we have a folder called \"Productivity\" productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') # Lets change the name to \"Hobbies\" productivity_folder['name'] = \"Hobbies\" # Update updated_folder = client.project.update_folder(productivity_folder) ``` ??? success \"Result\" The dictionary of the updated folder is returned. ```python {'id': '5ffe7dab8f089fb5795d8ef2', 'etag': 'r9xl60e5', 'name': 'Hobbies', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104408388-c48bbb80-5518-11eb-80d4-34e82bbaffd7.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104408436-e1c08a00-5518-11eb-953a-4933f407e4f9.png) === \"Multiple Folder Update\" ```python # Lets assume that we have a folder called \"Productivity\" productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') # Lets assume that we have another folder called \"Games\" games_folder = client.get_by_fields(name='Games', search='project_folders') # Lets change the \"Productivity\" folder to \"Work\" productivity_folder['name'] = \"Work\" # Lets change the \"Games\" folder to \"Hobbies\" games_folder['name'] = \"Hobbies\" update_list = [productivity_folder, games_folder] # List of objects to update # Update updated_folder = client.project.update_folder(update_list) ``` ??? success \"Result\" A list of the updated folder objects is returned. ```python [{'id': '5ffe80ce8f08068e86aab288', 'etag': '0oh0pxel', 'name': 'Work', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}, {'id': '5ffe80cf8f08068e86aab289', 'etag': 'xwvehtfo', 'name': 'Hobbies', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104409143-75468a80-551a-11eb-96c8-5953c97d6f6a.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104409181-8bece180-551a-11eb-8424-9f147d85eb80.png) \"\"\" # Check the types if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( \"Project objects must be a dict or list of dicts.\" ) if isinstance ( obj , dict ): tasks = [ obj ] else : tasks = obj url = self . _client . BASE_URL + 'batch/projectGroup' payload = { 'update' : tasks } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () if len ( tasks ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'project_folders' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Get the ids items = [ '' ] * len ( tasks ) # Create enough spots for the objects for proj_id in etag2 : found = self . _client . get_by_id ( proj_id , search = 'project_folders' ) for original in tasks : if found [ 'name' ] == original [ 'name' ]: # Get the index of original index = tasks . index ( original ) # Place found at the index in return list items [ index ] = found return items","title":"update_folder()"},{"location":"usage/tags/","text":"Info Tag methods are accessed through the tag public member of your TickTickClient instance. # Assumes that 'client' is the name that references the TickTickClient instance. tag = client . tag . method () Question About Logging In or Other Functionality Available? API and Important Information Tip All supported methods are documented below with usage examples, take a look! All usage examples assume that client is the name referencing the TickTickClient instance Example TickTick Tag Dictionary \u00b6 Members Descriptions It is possible that not all possible fields are present in the table. Property Description Example Value Type Useful Values name The lowercase of label 'books' str N/A label The uppercase of name 'Books' str N/A sortOrder A sort ID relative to other tags. 2748779069440 int N/A sortType Sort type of the tag dueDate str dueDate , project , title , priority color Hex color code string #4AA6EF str N/A etag Etag identifier. 'ji35exmv' str N/A parent name field of the parent tag 'friends' str N/A { 'name' : 'test' , 'label' : 'Test' , 'sortOrder' : 2748779069440 , 'sortType' : 'project' , 'color' : '#4AA6EF' , 'etag' : 'zxdvlhqd' , 'parent' : 'friends' } Sort Dictionary \u00b6 SORT_DICTIONARY The sort dictionary maps integers to the different sort types possible for tags. It is a public member called SORT_DICTIONARY available through the tag public member of the TickTickClient instance. Descriptions Value Sort Type 0 'project' 1 'dueDate' 2 'title' 3 'priority' TagsManager \u00b6 Handles all interactions for tags. builder ( self , label , color = 'random' , parent = None , sort = None ) \u00b6 Creates and returns a local tag object. Helper method for create to make batch creating projects easier. Note The parent tag must already exist prior to calling this method. Parameters: Name Type Description Default label str Desired label of the tag - tag labels cannot be repeated. required color str Hex color string. A random color will be generated if no color is specified. 'random' parent str The label of the parent tag if desired (include capitals in the label if it exists). None sort int The desired sort type of the tag. Valid integer values are present in the sort dictionary . The default sort value will be by 'project' None Returns: Type Description dict A dictionary containing all the fields necessary to create a tag remotely. Exceptions: Type Description TypeError If any of the types of the arguments are wrong. ValueError Tag label already exists. ValueError Parent tag does not exist. ValueError The hex string color inputted is invalid. Example tag_name = 'Books' # The name for our tag parent_name = 'Productivity' # The desired parent tag -> this should already exist. color_code = '#1387c4' sort_type = 1 # Sort by `dueDate` tag_object = client . tag . builder ( tag_name , parent = parent_name , color = color_code , sort = sort_type ) Result The required fields to create a tag object are created and returned in a dictionary. { 'label' : 'Fiction' , 'color' : '#1387c4' , 'parent' : 'books' , 'sortType' : 'dueDate' , 'name' : 'fiction' } Source code in managers/tags.py def builder ( self , label : str , color : str = 'random' , parent : str = None , sort : int = None ) -> dict : \"\"\" Creates and returns a local tag object. Helper method for [create][managers.tags.TagsManager.create] to make batch creating projects easier. !!! note The parent tag must already exist prior to calling this method. Arguments: label: Desired label of the tag - tag labels cannot be repeated. color: Hex color string. A random color will be generated if no color is specified. parent: The label of the parent tag if desired (include capitals in the label if it exists). sort: The desired sort type of the tag. Valid integer values are present in the [sort dictionary](tags.md#sort-dictionary). The default sort value will be by 'project' Returns: A dictionary containing all the fields necessary to create a tag remotely. Raises: TypeError: If any of the types of the arguments are wrong. ValueError: Tag label already exists. ValueError: Parent tag does not exist. ValueError: The hex string color inputted is invalid. !!! example ```python tag_name = 'Books' # The name for our tag parent_name = 'Productivity' # The desired parent tag -> this should already exist. color_code = '#1387c4' sort_type = 1 # Sort by `dueDate` tag_object = client.tag.builder(tag_name, parent=parent_name, color=color_code, sort=sort_type) ``` ??? success \"Result\" The required fields to create a tag object are created and returned in a dictionary. ```python {'label': 'Fiction', 'color': '#1387c4', 'parent': 'books', 'sortType': 'dueDate', 'name': 'fiction'} ``` \"\"\" # Perform checks return self . _check_fields ( label , color = color , parent_label = parent , sort = sort ) color ( self , label , color ) \u00b6 Change the color of a tag. For batch changing colors, see update . Parameters: Name Type Description Default label str The label of the tag to be changed. required color str The new desired hex color string. required Returns: Type Description dict The updated tag dictionary object. Exceptions: Type Description TypeError If label or color are not strings. ValueError If the tag label does not exist. ValueError If color is not a valid hex color string. RuntimeError If changing the color was not successful. Changing a Tag's Color # Lets assume that we have a tag named \"Movies\" that we want to change the color for. new_color = '#134397' movies_updated = client . tag . color ( 'Movies' , new_color ) Result The updated tag dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#134397' , 'etag' : 'wwb49yfr' } Before After Source code in managers/tags.py def color ( self , label : str , color : str ) -> dict : \"\"\" Change the color of a tag. For batch changing colors, see [update][managers.tags.TagsManager.update]. Arguments: label: The label of the tag to be changed. color: The new desired hex color string. Returns: The updated tag dictionary object. Raises: TypeError: If `label` or `color` are not strings. ValueError: If the tag `label` does not exist. ValueError: If `color` is not a valid hex color string. RuntimeError: If changing the color was not successful. !!! example \"Changing a Tag's Color\" ```python # Lets assume that we have a tag named \"Movies\" that we want to change the color for. new_color = '#134397' movies_updated = client.tag.color('Movies', new_color) ``` ??? success \"Result\" The updated tag dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'project', 'color': '#134397', 'etag': 'wwb49yfr'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104661749-0eda7d00-567e-11eb-836f-3a8851bcf9a5.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104661860-55c87280-567e-11eb-93b5-054fa4f1104a.png) \"\"\" if not isinstance ( label , str ) or not isinstance ( color , str ): raise TypeError ( 'Label and Color Must Be Strings' ) # Get the object label = label . lower () obj = self . _client . get_by_fields ( name = label , search = 'tags' ) if not obj : raise ValueError ( f \"Tag ' { label } ' Does Not Exist To Update\" ) # Check the color if not check_hex_color ( color ): raise ValueError ( f \"Hex Color String ' { color } ' Is Not Valid\" ) obj [ 'color' ] = color # Set the color url = self . _client . BASE_URL + 'batch/tag' payload = { 'update' : [ obj ] } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () return self . _client . get_by_etag ( response [ 'id2etag' ][ obj [ 'name' ]]) create ( self , label , color = 'random' , parent = None , sort = None ) \u00b6 Creates a tag remotely. Supports single tag creation or batch tag creation. Tip Allows creation with a label that may normally not be allowed by TickTick for tags. Normal TickTick excluded characters are: \\ / \" # : * ? < > | Space Parameters: Name Type Description Default label str or list Single Tag (str) : The desired label of the tag. Tag labels cannot be repeated. Multiple Tags (list) : A list of tag objects created using the builder method. required color str Hex color string. A random color will be generated if no color is specified. 'random' parent str The label of the parent tag if desired (include capitals in if it exists). None sort int The desired sort type of the tag. Valid integer values are present in the sort dictionary . The default sort value will be by 'project' None Returns: Type Description dict or list Single Tag (dict) : The created tag object dictionary. Multiple Tags (list) : A list of the created tag object dictionaries. Exceptions: Type Description TypeError If any of the types of the arguments are wrong. ValueError Tag label already exists. ValueError Parent tag does not exist. ValueError The hex string color inputted is invalid. RuntimeError The tag(s) could not be created. Single Tag Just A Label tag = client . tag . create ( 'Fun' ) Result The tag object dictionary is returned. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#9b69f3' , 'etag' : '7fc8zb58' } Our tag is created. Specify a Color A random color can be generated using generate_hex_color . However, just not specifying a color will automatically generate a random color (as seen in the previous tab) You can always specify the color that you want. tag = client . tag . create ( 'Fun' , color = '#86bb6d' ) Result The tag object dictionary is returned and our project is created with the color specified. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#86bb6d' , 'etag' : '8bzzdws3' } Specifying a Parent Tag Tags can be nested one level. To create a tag that is nested, include the label of the parent tag. The parent tag should already exist. tag = client . tag . create ( 'Fun' , parent = 'Hobbies' ) Result The tag object dictionary is returned and our tag is created nested under the parent tag. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#d2a6e4' , 'etag' : 'nauticx1' , 'parent' : 'hobbies' } Before After Sort Type You can specify the sort type of the created tag using integer values from the sort dictionary . tag = client . tag . create ( 'Fun' , sort = 2 ) # Sort by `title` Result The tag object dictionary is returned and our tag has the specified sort type. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'title' , 'color' : '#e7e7ba' , 'etag' : 'n4k3pezc' } Multiple Tag Creation (batch) To create multiple tags, build the tag objects first using the builder method. Pass in a list of the project objects to create them remotely. parent_tag = client . tag . create ( 'Hobbies' ) # Create a parent tag. # We will create tag objects using builder that will be nested under the parent tag fun_tag = client . tag . builder ( 'Fun' , sort = 2 , parent = 'Hobbies' ) read_tag = client . tag . builder ( 'Read' , color = '#d2a6e4' , parent = 'Hobbies' ) movie_tag = client . tag . builder ( 'Movies' , parent = 'Hobbies' ) # Create the tags tag_list = [ fun_tag , read_tag , movie_tag ] created_tags = client . tag . create ( tag_list ) Result The tag object dictionaries are returned in a list. [{ 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'title' , 'color' : '#172d1c' , 'etag' : '1tceclp4' , 'parent' : 'hobbies' }, { 'name' : 'read' , 'label' : 'Read' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#d2a6e4' , 'etag' : 'ykdem8dg' , 'parent' : 'hobbies' }, { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#94a5f8' , 'etag' : 'o0nifkbv' , 'parent' : 'hobbies' }] Source code in managers/tags.py def create ( self , label , color : str = 'random' , parent : str = None , sort : int = None ): \"\"\" Creates a tag remotely. Supports single tag creation or batch tag creation. !!! tip Allows creation with a label that may normally not be allowed by `TickTick` for tags. Normal `TickTick` excluded characters are: \\\\ / \" # : * ? < > | Space Arguments: label (str or list): **Single Tag (str)**: The desired label of the tag. Tag labels cannot be repeated. **Multiple Tags (list)**: A list of tag objects created using the [builder][managers.tags.TagsManager.builder] method. color: Hex color string. A random color will be generated if no color is specified. parent: The label of the parent tag if desired (include capitals in if it exists). sort: The desired sort type of the tag. Valid integer values are present in the [sort dictionary](tags.md#sort-dictionary). The default sort value will be by 'project' Returns: dict or list: **Single Tag (dict)**: The created tag object dictionary. **Multiple Tags (list)**: A list of the created tag object dictionaries. Raises: TypeError: If any of the types of the arguments are wrong. ValueError: Tag label already exists. ValueError: Parent tag does not exist. ValueError: The hex string color inputted is invalid. RuntimeError: The tag(s) could not be created. !!! example \"Single Tag\" === \"Just A Label\" ```python tag = client.tag.create('Fun') ``` ??? success \"Result\" The tag object dictionary is returned. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'project', 'color': '#9b69f3', 'etag': '7fc8zb58'} ``` Our tag is created. ![image](https://user-images.githubusercontent.com/56806733/104658773-5bbb5500-5678-11eb-9d44-27214203d70e.png) === \"Specify a Color\" A random color can be generated using [generate_hex_color][helpers.hex_color.generate_hex_color]. However, just not specifying a color will automatically generate a random color (as seen in the previous tab) You can always specify the color that you want. ```python tag = client.tag.create('Fun', color='#86bb6d') ``` ??? success \"Result\" The tag object dictionary is returned and our project is created with the color specified. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'project', 'color': '#86bb6d', 'etag': '8bzzdws3'} ``` ![image](https://user-images.githubusercontent.com/56806733/104659184-0c295900-5679-11eb-9f3c-2cd154c0500c.png) === \"Specifying a Parent Tag\" Tags can be nested one level. To create a tag that is nested, include the label of the parent tag. The parent tag should already exist. ```python tag = client.tag.create('Fun', parent='Hobbies') ``` ??? success \"Result\" The tag object dictionary is returned and our tag is created nested under the parent tag. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'project', 'color': '#d2a6e4', 'etag': 'nauticx1', 'parent': 'hobbies'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104659785-24e63e80-567a-11eb-9a62-01ebca55e649.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104659814-33ccf100-567a-11eb-8dca-c91aea68b4c7.png) === \"Sort Type\" You can specify the sort type of the created tag using integer values from the [sort dictionary](#sort-dictionary). ```python tag = client.tag.create('Fun', sort=2) # Sort by `title` ``` ??? success \"Result\" The tag object dictionary is returned and our tag has the specified sort type. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'title', 'color': '#e7e7ba', 'etag': 'n4k3pezc'} ``` ![image](https://user-images.githubusercontent.com/56806733/104660156-e4d38b80-567a-11eb-8c61-8fb874a515a2.png) !!! example \"Multiple Tag Creation (batch)\" To create multiple tags, build the tag objects first using the [builder][managers.projects.ProjectManager.builder] method. Pass in a list of the project objects to create them remotely. ```python parent_tag = client.tag.create('Hobbies') # Create a parent tag. # We will create tag objects using builder that will be nested under the parent tag fun_tag = client.tag.builder('Fun', sort=2, parent='Hobbies') read_tag = client.tag.builder('Read', color='#d2a6e4', parent='Hobbies') movie_tag = client.tag.builder('Movies', parent='Hobbies') # Create the tags tag_list = [fun_tag, read_tag, movie_tag] created_tags = client.tag.create(tag_list) ``` ??? success \"Result\" The tag object dictionaries are returned in a list. ```python [{'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'title', 'color': '#172d1c', 'etag': '1tceclp4', 'parent': 'hobbies'}, {'name': 'read', 'label': 'Read', 'sortOrder': 0, 'sortType': 'project', 'color': '#d2a6e4', 'etag': 'ykdem8dg', 'parent': 'hobbies'}, {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'project', 'color': '#94a5f8', 'etag': 'o0nifkbv', 'parent': 'hobbies'}] ``` ![image](https://user-images.githubusercontent.com/56806733/104660625-cb7f0f00-567b-11eb-8649-68646870ccfa.png) \"\"\" batch = False # Bool signifying batch create or not if isinstance ( label , list ): # Batch tag creation triggered obj = label # Assuming all correct objects batch = True else : if not isinstance ( label , str ): raise TypeError ( 'Required Positional Argument Must Be A String or List of Tag Objects' ) # Create a single object obj = self . builder ( label = label , color = color , parent = parent , sort = sort ) if not batch : obj = [ obj ] url = self . _client . BASE_URL + 'batch/tag' payload = { 'add' : obj } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () if not batch : return self . _client . get_by_etag ( self . _client . parse_etag ( response ), search = 'tags' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Tag names are out of order labels = [ x [ 'name' ] for x in obj ] # Tag names are in order items = [ '' ] * len ( obj ) # Create enough spots for the objects for tag in etag2 : index = labels . index ( tag ) # Object of the index is here actual_etag = etag [ tag ] # Get the actual etag found = self . _client . get_by_etag ( actual_etag , search = 'tags' ) items [ index ] = found # Place at the correct index if len ( items ) == 1 : return items [ 0 ] else : return items delete ( self , label ) \u00b6 Delete tag(s). Supports single tag deletion and \"mock\" batch tag deletion. Info Batch deleting for tags is not supported by TickTick. However, passing in a list of labels to delete will \"mock\" batch deleting - but individual requests will have to be made for each deletion. Parameters: Name Type Description Default label str or list Single Tag (str) : The label of the tag. Multiple Tags (list) : A list of tag label strings. required Returns: Type Description dict or list Single Tag (dict) : The dictionary object of the deleted tag. Multiple Tags (list) : The dictionary objects of the deleted tags in a list. Exceptions: Type Description TypeError If label is not a string or list. ValueError If a label does not exist. RuntimeError If the tag could not be deleted successfully. Tag Deletion Single Tag Deletion Deleting a single tag requires passing in the label string of the tag. # Lets delete a tag named \"Fun\" delete_tag = client . tag . delete ( \"Fun\" ) Result The dictionary object of the deleted tag returned. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : - 3298534883328 , 'sortType' : 'project' , 'color' : '#A9949E' , 'etag' : '32balm5l' } Before \"Fun\" Tag Exists After \"Fun\" Tag Does Not Exist Multiple Tag Deletion Deleting multiple tags requires passing the label strings of the tags in a list. # Lets delete tags named \"Fun\", \"Movies\", and \"Hobbies\" delete_labels = [ \"Fun\" , \"Movies\" , \"Hobbies\" ] deleted_tags = client . tag . delete ( delete_labels ) Result The dictionary object of the deleted tags returned in a list. [{ 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : - 3848290697216 , 'sortType' : 'project' , 'color' : '#FFD966' , 'etag' : '56aa6dva' }, { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : - 2748779069440 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : 's0czro3e' }, { 'name' : 'hobbies' , 'label' : 'Hobbies' , 'sortOrder' : - 2199023255552 , 'sortType' : 'project' , 'color' : '#ABA6B5' , 'etag' : 'shu2xbvq' }] Before All three tags exist. After All three tags don't exist. Source code in managers/tags.py def delete ( self , label ): \"\"\" Delete tag(s). Supports single tag deletion and \"mock\" batch tag deletion. !!! info Batch deleting for tags is not supported by TickTick. However, passing in a list of labels to delete will \"mock\" batch deleting - but individual requests will have to be made for each deletion. Arguments: label (str or list): **Single Tag (str)**: The label of the tag. **Multiple Tags (list)**: A list of tag label strings. Returns: dict or list: **Single Tag (dict)**: The dictionary object of the deleted tag. **Multiple Tags (list)**: The dictionary objects of the deleted tags in a list. Raises: TypeError: If `label` is not a string or list. ValueError: If a label does not exist. RuntimeError: If the tag could not be deleted successfully. !!! example \"Tag Deletion\" === \"Single Tag Deletion\" Deleting a single tag requires passing in the label string of the tag. ```python # Lets delete a tag named \"Fun\" delete_tag = client.tag.delete(\"Fun\") ``` ??? success \"Result\" The dictionary object of the deleted tag returned. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': -3298534883328, 'sortType': 'project', 'color': '#A9949E', 'etag': '32balm5l'} ``` **Before** \"Fun\" Tag Exists ![image](https://user-images.githubusercontent.com/56806733/104668024-2c164800-568c-11eb-853e-5b7eba1f4528.png) **After** \"Fun\" Tag Does Not Exist ![image](https://user-images.githubusercontent.com/56806733/104667768-ac887900-568b-11eb-9bfb-597c752e4c3b.png) === \"Multiple Tag Deletion\" Deleting multiple tags requires passing the label strings of the tags in a list. ```python # Lets delete tags named \"Fun\", \"Movies\", and \"Hobbies\" delete_labels = [\"Fun\", \"Movies\", \"Hobbies\"] deleted_tags = client.tag.delete(delete_labels) ``` ??? success \"Result\" The dictionary object of the deleted tags returned in a list. ```python [{'name': 'fun', 'label': 'Fun', 'sortOrder': -3848290697216, 'sortType': 'project', 'color': '#FFD966', 'etag': '56aa6dva'}, {'name': 'movies', 'label': 'Movies', 'sortOrder': -2748779069440, 'sortType': 'dueDate', 'color': '#134397', 'etag': 's0czro3e'}, {'name': 'hobbies', 'label': 'Hobbies', 'sortOrder': -2199023255552, 'sortType': 'project', 'color': '#ABA6B5', 'etag': 'shu2xbvq'}] ``` **Before** All three tags exist. ![image](https://user-images.githubusercontent.com/56806733/104668135-61bb3100-568c-11eb-8707-314deb42cd1d.png) **After** All three tags don't exist. ![image](https://user-images.githubusercontent.com/56806733/104668185-7b5c7880-568c-11eb-8da0-aaee68d53500.png) \"\"\" # Determine if the tag exists if not isinstance ( label , str ) and not isinstance ( label , list ): raise TypeError ( 'Label Must Be A String or List Of Strings' ) url = self . _client . BASE_URL + 'tag' if isinstance ( label , str ): label = [ label ] # If a singular string we are going to add it to a list objects = [] for lbl in label : if not isinstance ( lbl , str ): raise TypeError ( f \"' { lbl } ' Must Be A String\" ) lbl = lbl . lower () tag_obj = self . _client . get_by_fields ( name = lbl , search = 'tags' ) # Get the tag object if not tag_obj : raise ValueError ( f \"Tag ' { lbl } ' Does Not Exist To Delete\" ) # We can assume that only one tag has the name params = { 'name' : tag_obj [ 'name' ] } response = self . _client . http_delete ( url , params = params , cookies = self . _client . cookies , headers = self . headers ) # Find the tag in the tags list and delete it, then return the deleted object objects . append ( self . _client . delete_from_local_state ( search = 'tags' , etag = tag_obj [ 'etag' ])) self . _client . sync () if len ( objects ) == 1 : return objects [ 0 ] else : return objects merge ( self , label , merged ) \u00b6 Merges the tasks of the passed tags into the argument merged and deletes all the tags except merged Args can be individual label strings, or a list of strings Parameters: Name Type Description Default label str or list Single Tag (str) : The label string of the tag to merge. Multiple Tags (list) : The label strings of the tags to merge in a list. required merged str The label of the tag that will remain after the merge. required Returns: Type Description dict The tag dictionary object that remains after the merge. Exceptions: Type Description TypeError If merged is not a str or if label is not a str or list. ValueError If any of the labels do not exist. RuntimeError If the merge could not be successfully completed. Merging Tags Merging Two Tags Merging two tags requires the label of the tag that you want kept after the merge, and the label of the tag that will be merged. Lets assume that we have two tags: \"Work\" and \"School\". I want to merge the tag \"School\" into \"Work\". What should happen is that any tasks that are tagged \"School\", will be updated to have the tag \"Work\", and the \"School\" tag will be deleted. merged_tags = client . tag . merge ( \"School\" , \"Work\" ) Result The tag that remains after the merge is returned. { 'name' : 'work' , 'label' : 'Work' , 'sortOrder' : 2199023255552 , 'sortType' : 'project' , 'color' : '#3876E4' , 'etag' : 'eeh8zrup' } Before \"School\" has two tasks that have it's tag. \"Work\" has no tasks. After \"School\" has been deleted. The tasks that used to be tagged with \"School\" are now tagged with \"Work\". Merging Three Or More Tags Merging multiple tags into a single tag requires passing the labels of the tags to merge in a list. Lets assume that we have three tags: \"Work\", \"School\", and \"Hobbies\" . I want to merge the tag \"School\" and the tag \"Hobbies\" into \"Work\". What should happen is that any tasks that are tagged with \"School\" or \"Hobbies\", will be updated to have the tag \"Work\", and the \"School\" and \"Hobbies\" tags will be deleted. merge_tags = [ \"School\" , \"Hobbies\" ] result = client . tag . merge ( merge_tags , \"Work\" ) Result The tag that remains after the merge is returned. { 'name' : 'work' , 'label' : 'Work' , 'sortOrder' : 2199023255552 , 'sortType' : 'project' , 'color' : '#3876E4' , 'etag' : 'ke23lp06' } Before \"School\" has two tasks. \"Hobbies\" has two tasks. \"Work\" has one task. After \"Work\" has five tasks now, and the tags \"School\" and \"Hobbies\" have been deleted. Source code in managers/tags.py def merge ( self , label , merged : str ): \"\"\" Merges the tasks of the passed tags into the argument `merged` and deletes all the tags except `merged` Args can be individual label strings, or a list of strings Arguments: label (str or list): **Single Tag (str)**: The label string of the tag to merge. **Multiple Tags (list)**: The label strings of the tags to merge in a list. merged: The label of the tag that will remain after the merge. Returns: dict: The tag dictionary object that remains after the merge. Raises: TypeError: If `merged` is not a str or if `label` is not a str or list. ValueError: If any of the labels do not exist. RuntimeError: If the merge could not be successfully completed. !!! example \"Merging Tags\" === \"Merging Two Tags\" Merging two tags requires the label of the tag that you want kept after the merge, and the label of the tag that will be merged. Lets assume that we have two tags: \"Work\" and \"School\". I want to merge the tag \"School\" into \"Work\". What should happen is that any tasks that are tagged \"School\", will be updated to have the tag \"Work\", and the \"School\" tag will be deleted. ```python merged_tags = client.tag.merge(\"School\", \"Work\") ``` ??? success \"Result\" The tag that remains after the merge is returned. ```python {'name': 'work', 'label': 'Work', 'sortOrder': 2199023255552, 'sortType': 'project', 'color': '#3876E4', 'etag': 'eeh8zrup'} ``` **Before** \"School\" has two tasks that have it's tag. ![image](https://user-images.githubusercontent.com/56806733/104680244-45c38980-56a4-11eb-968d-884160c77247.png) \"Work\" has no tasks. ![image](https://user-images.githubusercontent.com/56806733/104680366-90dd9c80-56a4-11eb-975f-5e769e9ea491.png) **After** \"School\" has been deleted. The tasks that used to be tagged with \"School\" are now tagged with \"Work\". ![image](https://user-images.githubusercontent.com/56806733/104680576-0c3f4e00-56a5-11eb-9536-ef3a7fcf20ec.png) === \"Merging Three Or More Tags\" Merging multiple tags into a single tag requires passing the labels of the tags to merge in a list. Lets assume that we have three tags: \"Work\", \"School\", and \"Hobbies\" . I want to merge the tag \"School\" and the tag \"Hobbies\" into \"Work\". What should happen is that any tasks that are tagged with \"School\" or \"Hobbies\", will be updated to have the tag \"Work\", and the \"School\" and \"Hobbies\" tags will be deleted. ```python merge_tags = [\"School\", \"Hobbies\"] result = client.tag.merge(merge_tags, \"Work\") ``` ??? success \"Result\" The tag that remains after the merge is returned. ```python {'name': 'work', 'label': 'Work', 'sortOrder': 2199023255552, 'sortType': 'project', 'color': '#3876E4', 'etag': 'ke23lp06'} ``` **Before** \"School\" has two tasks. ![image](https://user-images.githubusercontent.com/56806733/104681135-7ad0db80-56a6-11eb-81dd-03e4a151cfd9.png) \"Hobbies\" has two tasks. ![image](https://user-images.githubusercontent.com/56806733/104681104-67257500-56a6-11eb-99b0-57bbb876a59e.png) \"Work\" has one task. ![image](https://user-images.githubusercontent.com/56806733/104681164-89b78e00-56a6-11eb-99a8-c85ef418d2a0.png) **After** \"Work\" has five tasks now, and the tags \"School\" and \"Hobbies\" have been deleted. ![image](https://user-images.githubusercontent.com/56806733/104681239-b7043c00-56a6-11eb-9b45-5522b9c69cb0.png) \"\"\" # Make sure merged is a string if not isinstance ( merged , str ): raise ValueError ( 'Merged Must Be A String' ) # Make sure label is a string or list if not isinstance ( label , str ) and not isinstance ( label , list ): raise ValueError ( f \"Label must be a string or a list.\" ) # Lowercase merged merged = merged . lower () # Make sure merged exists kept_obj = self . _client . get_by_fields ( name = merged , search = 'tags' ) if not kept_obj : raise ValueError ( f \"Kept Tag ' { merged } ' Does Not Exist To Merge\" ) merge_queue = [] # Verify all args are valid, and add them to a list if isinstance ( label , str ): string = label . lower () # Make sure it exists retrieved = self . _client . get_by_fields ( name = string , search = 'tags' ) if not retrieved : raise ValueError ( f \"Tag ' { label } ' Does Not Exist To Merge\" ) merge_queue . append ( retrieved ) else : for item in label : # Loop through the items in the list and check items are a string and exist # Make sure the item is a string if not isinstance ( item , str ): raise ValueError ( f \"Item ' { item } ' Must Be A String\" ) string = item . lower () # Make sure it exists found = self . _client . get_by_fields ( name = string , search = 'tags' ) if not found : raise ValueError ( f \"Tag ' { item } ' Does Not Exist To Merge\" ) merge_queue . append ( found ) for labels in merge_queue : # Merge url = self . _client . BASE_URL + 'tag/merge' payload = { 'name' : labels [ 'name' ], 'newName' : kept_obj [ 'name' ] } self . _client . http_put ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () return kept_obj nesting ( self , child , parent ) \u00b6 Update tag nesting. Move an already created tag to be nested underneath a parent tag - or ungroup an already nested tag. Nesting Tags More Than One Level Does Not Work Example Nesting Explanation Parent Tag -> Level Zero Child Tag 1 -> Level One: This is the most nesting that is allowed by TickTick for tags. Child Tag 2 -> Level Two: Not allowed Parameters: Name Type Description Default child str Label of the tag to become the child required parent str Label of the tag that will become the parent. required Returns: Type Description dict The updated tag object dictionary. Exceptions: Type Description TypeError If child and parent are not strings ValueError If child does not exist to update. ValueError If parent does not exist. RuntimeError If setting the parent was unsuccessful. Nesting Nesting A Tag To nest a tag underneath another tag, pass in the labels of the child and parent. # Lets assume that we have a tag named \"Movies\" # We have another tag named \"Hobbies\" that we want to make the parent to \"Movies\" child = \"Movies\" parent = \"Hobbies\" nesting_update = client . tag . nesting ( child , parent ) Result The updated child tag dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : 'ee34aft9' , 'parent' : 'hobbies' } Before After Changing The Parent Of An Already Nested Tag If the tag is already nested, changing the parent is still no different. # We have a tag named \"Movies\" that is already nested underneath \"Hobbies\" # We want to nest \"Movies\" underneath the tag \"Fun\" instead. child = \"Movies\" parent = \"Fun\" nesting_update = client . tag . nesting ( child , parent ) Result The updated child tag dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : '91qpuq71' , 'parent' : 'fun' } Before After Un-grouping A Child Tag If the tag is nested and you want to ungroup it, pass in None for parent . # We have a tag named \"Movies\" that is nested underneath \"Fun\" # We don't want to have \"Movies\" nested anymore. child = \"Movies\" parent = None nesting_update = client . tag . nesting ( child , parent ) Result The updated child tag dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : 'jcoc94p6' } Before After Source code in managers/tags.py def nesting ( self , child : str , parent : str ) -> dict : \"\"\" Update tag nesting. Move an already created tag to be nested underneath a parent tag - or ungroup an already nested tag. !!! warning \"Nesting Tags More Than One Level Does Not Work\" !!! example === \"Nesting Explanation\" ```md Parent Tag -> Level Zero Child Tag 1 -> Level One: This is the most nesting that is allowed by TickTick for tags. Child Tag 2 -> Level Two: Not allowed ``` Arguments: child: Label of the tag to become the child parent: Label of the tag that will become the parent. Returns: The updated tag object dictionary. Raises: TypeError: If `child` and `parent` are not strings ValueError: If `child` does not exist to update. ValueError: If `parent` does not exist. RuntimeError: If setting the parent was unsuccessful. !!! example \"Nesting\" === \"Nesting A Tag\" To nest a tag underneath another tag, pass in the labels of the child and parent. ```python # Lets assume that we have a tag named \"Movies\" # We have another tag named \"Hobbies\" that we want to make the parent to \"Movies\" child = \"Movies\" parent = \"Hobbies\" nesting_update = client.tag.nesting(child, parent) ``` ??? success \"Result\" The updated child tag dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'dueDate', 'color': '#134397', 'etag': 'ee34aft9', 'parent': 'hobbies'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104665300-da6abf00-5685-11eb-947f-889187cec008.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104665366-f706f700-5685-11eb-93eb-9316befec5fc.png) === \"Changing The Parent Of An Already Nested Tag\" If the tag is already nested, changing the parent is still no different. ```python # We have a tag named \"Movies\" that is already nested underneath \"Hobbies\" # We want to nest \"Movies\" underneath the tag \"Fun\" instead. child = \"Movies\" parent = \"Fun\" nesting_update = client.tag.nesting(child, parent) ``` ??? success \"Result\" The updated child tag dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'dueDate', 'color': '#134397', 'etag': '91qpuq71', 'parent': 'fun'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104665599-ab088200-5686-11eb-8b36-5ee873289db7.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104665821-35e97c80-5687-11eb-8098-426816970f3e.png) === \"Un-grouping A Child Tag\" If the tag is nested and you want to ungroup it, pass in `None` for `parent`. ```python # We have a tag named \"Movies\" that is nested underneath \"Fun\" # We don't want to have \"Movies\" nested anymore. child = \"Movies\" parent = None nesting_update = client.tag.nesting(child, parent) ``` ??? success \"Result\" The updated child tag dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'dueDate', 'color': '#134397', 'etag': 'jcoc94p6'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104666038-be681d00-5687-11eb-8490-83c370977267.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104666080-dcce1880-5687-11eb-9ca8-5abcdb4109ba.png) \"\"\" if not isinstance ( child , str ): raise TypeError ( 'Inputs Must Be Strings' ) if parent is not None : if not isinstance ( parent , str ): raise TypeError ( 'Inputs Must Be Strings' ) # Get the object child = child . lower () obj = self . _client . get_by_fields ( name = child , search = 'tags' ) if not obj : raise ValueError ( f \"Tag ' { child } ' Does Not Exist To Update\" ) # Four Cases # Case 1: No Parent -> Want a Parent # Case 2: No Parent -> Doesn't Want a Parent # Case 3: Has Parent -> Wants a Different Parent # Case 4: Has Parent -> Doesn't Want a Parent # Case 1: Determine if the object has a parent try : if obj [ 'parent' ]: # It has a parent if parent is not None : # Case 3 # check if the parent is already the same, if it is just return if obj [ 'parent' ] == parent . lower (): return obj else : new_p = parent . lower () obj [ 'parent' ] = new_p else : new_p = obj [ 'parent' ] # Case 4 obj [ 'parent' ] = '' elif obj [ 'parent' ] is None : raise ValueError ( 'Parent Does Not Exist' ) except KeyError : # It does not have a parent if parent is not None : # Wants a different parent new_p = parent . lower () # -> Case 1 obj [ 'parent' ] = new_p else : # Doesn't want a parent -> Case 2 return obj # We don't have to do anything if no parent and doesn't want a parent # Have to find the project pobj = self . _client . get_by_fields ( name = new_p , search = 'tags' ) if not pobj : raise ValueError ( f \"Tag ' { parent } ' Does Not Exist To Set As Parent\" ) url = self . _client . BASE_URL + 'batch/tag' payload = { 'update' : [ pobj , obj ] } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () return self . _client . get_by_etag ( response [ 'id2etag' ][ obj [ 'name' ]], search = 'tags' ) rename ( self , old , new ) \u00b6 Renames a tag. Parameters: Name Type Description Default old str Current label of the tag to be changed. required new str Desired new label of the tag. required Returns: Type Description dict The tag object with the updated label. Exceptions: Type Description TypeError If old and new are not strings. ValueError If the old tag label does not exist. ValueError If the new tag label already exists. RuntimeError If the renaming was unsuccessful. Changing a Tag's Label Pass in the current label of the tag, and the desired new label of the tag. # Lets assume that we have a tag that already exists named \"Movie\" old_label = \"Movie\" new_label = \"Movies\" updated_tag = client . tag . rename ( old_label , new_label ) Result The updated tag object dictionary is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#134397' , 'etag' : 'qer1jygy' } Before After Source code in managers/tags.py def rename ( self , old : str , new : str ) -> dict : \"\"\" Renames a tag. Arguments: old: Current label of the tag to be changed. new: Desired new label of the tag. Returns: The tag object with the updated label. Raises: TypeError: If `old` and `new` are not strings. ValueError: If the `old` tag label does not exist. ValueError: If the `new` tag label already exists. RuntimeError: If the renaming was unsuccessful. !!! example \"Changing a Tag's Label\" Pass in the current label of the tag, and the desired new label of the tag. ```python # Lets assume that we have a tag that already exists named \"Movie\" old_label = \"Movie\" new_label = \"Movies\" updated_tag = client.tag.rename(old_label, new_label) ``` ??? success \"Result\" The updated tag object dictionary is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'project', 'color': '#134397', 'etag': 'qer1jygy'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104661255-fcac0f00-567c-11eb-9f10-69af8b50e0b4.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104661299-19e0dd80-567d-11eb-825f-758d83178295.png) \"\"\" # Check that both old and new are strings if not isinstance ( old , str ) or not isinstance ( new , str ): raise TypeError ( 'Old and New Must Be Strings' ) # Make sure the old tag exists old = old . lower () # Check if the tag object exists obj = self . _client . get_by_fields ( name = old , search = 'tags' ) if not obj : raise ValueError ( f \"Tag ' { old } ' Does Not Exist To Rename\" ) # Make sure the new tag does not exist temp_new = new . lower () # Check if the tag object exists found = self . _client . get_by_fields ( name = temp_new , search = 'tags' ) if found : raise ValueError ( f \"Name ' { new } ' Already Exists -> Cannot Duplicate Name\" ) url = self . _client . BASE_URL + 'tag/rename' payload = { 'name' : obj [ 'name' ], 'newName' : new } response = self . _client . http_put ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () # Response from TickTick does not return the new etag of the object, we must find it ourselves new_obj = self . _client . get_by_fields ( name = temp_new , search = 'tags' ) # Return the etag of the updated object return self . _client . get_by_etag ( new_obj [ 'etag' ], search = 'tags' ) sorting ( self , label , sort ) \u00b6 Change the sort type of a tag. For batch changing sort types, see update . Parameters: Name Type Description Default label str The label of the tag to be changed. required sort int The new sort type specified by an integer 0-3. See sort dictionary . required Returns: Type Description dict The updated tag dictionary object. Exceptions: Type Description TypeError If label is not a string or if sort is not an int. ValueError If the tag label does not exist. RuntimeError If the updating was unsuccessful. Changing the Sort Type # Lets assume that we have a tag named \"Movies\" with the sort type \"project\" changed_sort_type = client . tag . sorting ( \"Movies\" , 1 ) # Sort by 'dueDate' Result The updated task dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : 'fflj8iy0' } Before After Source code in managers/tags.py def sorting ( self , label : str , sort : int ) -> dict : \"\"\" Change the sort type of a tag. For batch changing sort types, see [update][managers.tags.TagsManager.update]. Arguments: label: The label of the tag to be changed. sort: The new sort type specified by an integer 0-3. See [sort dictionary](tags.md#sort-dictionary). Returns: The updated tag dictionary object. Raises: TypeError: If `label` is not a string or if `sort` is not an int. ValueError: If the tag `label` does not exist. RuntimeError: If the updating was unsuccessful. !!! example \"Changing the Sort Type\" ```python # Lets assume that we have a tag named \"Movies\" with the sort type \"project\" changed_sort_type = client.tag.sorting(\"Movies\", 1) # Sort by 'dueDate' ``` ??? success \"Result\" The updated task dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'dueDate', 'color': '#134397', 'etag': 'fflj8iy0'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104663625-3f241a80-5682-11eb-93a7-73d280c59b3e.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104663663-5531db00-5682-11eb-9440-5673a70840b4.png) \"\"\" if not isinstance ( label , str ) or not isinstance ( sort , int ): raise TypeError ( 'Label Must Be A String and Sort Must Be An Int' ) # Get the object label = label . lower () obj = self . _client . get_by_fields ( name = label , search = 'tags' ) if not obj : raise ValueError ( f \"Tag ' { label } ' Does Not Exist To Update\" ) sort = self . _sort_string_value ( sort ) # Get the sort string for the value obj [ 'sortType' ] = sort # set the object field url = self . _client . BASE_URL + 'batch/tag' payload = { 'update' : [ obj ] } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () return self . _client . get_by_etag ( response [ 'id2etag' ][ obj [ 'name' ]]) update ( self , obj ) \u00b6 Generic update method. Supports single and batch tag update. Important Updating tag properties like parent and renaming tags must be completed through their respective class methods to work: nesting and renaming . These updates use different endpoints to the traditional updating. Important You are able to batch update sorting and color of tag objects through this method. If you only need to update single tags, it is recommended you use the class methods: sorting and color Info More information on Tag Object properties here Parameters: Name Type Description Default obj dict or list Single Tag (dict) : The tag dictionary object to update. Multiple Tags (list) : The tag dictionaries to update in a list. required Returns: Type Description dict or list Single Tag (dict) : The updated tag dictionary object. Multiple Tags (list) : The updated tag dictionaries in a list. Exceptions: Type Description TypeError If obj is not a dict or list. RuntimeError If the updating was unsuccessful. Updating Tags Single Tag Update Change a field directly in the task object then pass it to the method. See above for more information about what can actually be successfully changed through this method. # Lets say we have a tag named \"Fun\" that we want to change the color of. # We can change the color by updating the field directly. fun_tag = client . get_by_fields ( label = 'Fun' , search = 'tags' ) # Get the tag object new_color = '#d00000' fun_tag [ 'color' ] = new_color # Change the color updated_fun_tag = client . tag . update ( fun_tag ) # Pass the object to update. Result The updated tag dictionary object is returned. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 2199023255552 , 'sortType' : 'project' , 'color' : '#d00000' , 'etag' : 'i85c8ijo' } Before After Multiple Tag Update Changing the fields is the same as with updating a single tag, except you will need to pass the objects in a list to the method. # Lets update the colors for three tags: \"Fun\", \"Hobbies\", and \"Productivity\" fun_tag = client . get_by_fields ( label = \"Fun\" , search = 'tags' ) hobbies_tag = client . get_by_fields ( label = \"Hobbies\" , search = 'tags' ) productivity_tag = client . get_by_fields ( label = \"Productivity\" , search = 'tags' ) fun_color_new = \"#951a63\" hobbies_color_new = \"#0f8a1f\" productivity_color_new = \"#493293\" # Change the fields directly fun_tag [ 'color' ] = fun_color_new hobbies_tag [ 'color' ] = hobbies_color_new productivity_tag [ 'color' ] = productivity_color_new # The objects must be passed in a list update_tag_list = [ fun_tag , hobbies_tag , productivity_tag ] updated_tags = client . tag . update ( update_tag_list ) Result The updated task dictionary objects are returned in a list. [{ 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : - 1099511627776 , 'sortType' : 'project' , 'color' : '#951a63' , 'etag' : 'n543ajq2' }, { 'name' : 'hobbies' , 'label' : 'Hobbies' , 'sortOrder' : - 549755813888 , 'sortType' : 'project' , 'color' : '#0f8a1f' , 'etag' : 'j4nspkg4' }, { 'name' : 'productivity' , 'label' : 'Productivity' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#493293' , 'etag' : '34qz9bzq' }] Before After Source code in managers/tags.py def update ( self , obj ): \"\"\" Generic update method. Supports single and batch tag update. !!! important Updating tag properties like `parent` and renaming tags must be completed through their respective class methods to work: [nesting][managers.tags.TagsManager.nesting] and [renaming][managers.tags.TagsManager.rename]. These updates use different endpoints to the traditional updating. !!! important You are able to batch update sorting and color of tag objects through this method. If you only need to update single tags, it is recommended you use the class methods: [sorting][managers.tags.TagsManager.sorting] and [color][managers.tags.TagsManager.color] !!! info More information on Tag Object properties [here](tags.md#example-ticktick-tag-dictionary) Arguments: obj (dict or list): **Single Tag (dict)**: The tag dictionary object to update. **Multiple Tags (list)**: The tag dictionaries to update in a list. Returns: dict or list: **Single Tag (dict)**: The updated tag dictionary object. **Multiple Tags (list)**: The updated tag dictionaries in a list. Raises: TypeError: If `obj` is not a dict or list. RuntimeError: If the updating was unsuccessful. !!! example \"Updating Tags\" === \"Single Tag Update\" Change a field directly in the task object then pass it to the method. See above for more information about what can actually be successfully changed through this method. ```python # Lets say we have a tag named \"Fun\" that we want to change the color of. # We can change the color by updating the field directly. fun_tag = client.get_by_fields(label='Fun', search='tags') # Get the tag object new_color = '#d00000' fun_tag['color'] = new_color # Change the color updated_fun_tag = client.tag.update(fun_tag) # Pass the object to update. ``` ??? success \"Result\" The updated tag dictionary object is returned. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 2199023255552, 'sortType': 'project', 'color': '#d00000', 'etag': 'i85c8ijo'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104669635-4aca0e00-568f-11eb-8bc6-9572a432b623.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104669824-ac8a7800-568f-11eb-93d6-ac40235bcd3f.png) === \"Multiple Tag Update\" Changing the fields is the same as with updating a single tag, except you will need to pass the objects in a list to the method. ```python # Lets update the colors for three tags: \"Fun\", \"Hobbies\", and \"Productivity\" fun_tag = client.get_by_fields(label=\"Fun\", search='tags') hobbies_tag = client.get_by_fields(label=\"Hobbies\", search='tags') productivity_tag = client.get_by_fields(label=\"Productivity\", search='tags') fun_color_new = \"#951a63\" hobbies_color_new = \"#0f8a1f\" productivity_color_new = \"#493293\" # Change the fields directly fun_tag['color'] = fun_color_new hobbies_tag['color'] = hobbies_color_new productivity_tag['color'] = productivity_color_new # The objects must be passed in a list update_tag_list = [fun_tag, hobbies_tag, productivity_tag] updated_tags = client.tag.update(update_tag_list) ``` ??? success \"Result\" The updated task dictionary objects are returned in a list. ```python [{'name': 'fun', 'label': 'Fun', 'sortOrder': -1099511627776, 'sortType': 'project', 'color': '#951a63', 'etag': 'n543ajq2'}, {'name': 'hobbies', 'label': 'Hobbies', 'sortOrder': -549755813888, 'sortType': 'project', 'color': '#0f8a1f', 'etag': 'j4nspkg4'}, {'name': 'productivity', 'label': 'Productivity', 'sortOrder': 0, 'sortType': 'project', 'color': '#493293', 'etag': '34qz9bzq'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104670498-cd070200-5690-11eb-9fdd-0287fa6c7e7b.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104670531-dc864b00-5690-11eb-844a-899031335922.png) \"\"\" batch = False # Bool signifying batch create or not if isinstance ( obj , list ): # Batch tag creation triggered obj_list = obj # Assuming all correct objects batch = True else : if not isinstance ( obj , dict ): raise TypeError ( 'Required Positional Argument Must Be A Dict or List of Tag Objects' ) if not batch : obj_list = [ obj ] url = self . _client . BASE_URL + 'batch/tag' payload = { 'update' : obj_list } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () if not batch : return self . _client . get_by_etag ( self . _client . parse_etag ( response ), search = 'tags' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Tag names are out of order labels = [ x [ 'name' ] for x in obj_list ] # Tag names are in order items = [ '' ] * len ( obj_list ) # Create enough spots for the objects for tag in etag2 : index = labels . index ( tag ) # Object of the index is here actual_etag = etag [ tag ] # Get the actual etag found = self . _client . get_by_etag ( actual_etag , search = 'tags' ) items [ index ] = found # Place at the correct index return items","title":"Tags"},{"location":"usage/tags/#example-ticktick-tag-dictionary","text":"Members Descriptions It is possible that not all possible fields are present in the table. Property Description Example Value Type Useful Values name The lowercase of label 'books' str N/A label The uppercase of name 'Books' str N/A sortOrder A sort ID relative to other tags. 2748779069440 int N/A sortType Sort type of the tag dueDate str dueDate , project , title , priority color Hex color code string #4AA6EF str N/A etag Etag identifier. 'ji35exmv' str N/A parent name field of the parent tag 'friends' str N/A { 'name' : 'test' , 'label' : 'Test' , 'sortOrder' : 2748779069440 , 'sortType' : 'project' , 'color' : '#4AA6EF' , 'etag' : 'zxdvlhqd' , 'parent' : 'friends' }","title":"Example TickTick Tag Dictionary"},{"location":"usage/tags/#sort-dictionary","text":"SORT_DICTIONARY The sort dictionary maps integers to the different sort types possible for tags. It is a public member called SORT_DICTIONARY available through the tag public member of the TickTickClient instance. Descriptions Value Sort Type 0 'project' 1 'dueDate' 2 'title' 3 'priority'","title":"Sort Dictionary"},{"location":"usage/tags/#managers.tags.TagsManager","text":"Handles all interactions for tags.","title":"TagsManager"},{"location":"usage/tags/#managers.tags.TagsManager.builder","text":"Creates and returns a local tag object. Helper method for create to make batch creating projects easier. Note The parent tag must already exist prior to calling this method. Parameters: Name Type Description Default label str Desired label of the tag - tag labels cannot be repeated. required color str Hex color string. A random color will be generated if no color is specified. 'random' parent str The label of the parent tag if desired (include capitals in the label if it exists). None sort int The desired sort type of the tag. Valid integer values are present in the sort dictionary . The default sort value will be by 'project' None Returns: Type Description dict A dictionary containing all the fields necessary to create a tag remotely. Exceptions: Type Description TypeError If any of the types of the arguments are wrong. ValueError Tag label already exists. ValueError Parent tag does not exist. ValueError The hex string color inputted is invalid. Example tag_name = 'Books' # The name for our tag parent_name = 'Productivity' # The desired parent tag -> this should already exist. color_code = '#1387c4' sort_type = 1 # Sort by `dueDate` tag_object = client . tag . builder ( tag_name , parent = parent_name , color = color_code , sort = sort_type ) Result The required fields to create a tag object are created and returned in a dictionary. { 'label' : 'Fiction' , 'color' : '#1387c4' , 'parent' : 'books' , 'sortType' : 'dueDate' , 'name' : 'fiction' } Source code in managers/tags.py def builder ( self , label : str , color : str = 'random' , parent : str = None , sort : int = None ) -> dict : \"\"\" Creates and returns a local tag object. Helper method for [create][managers.tags.TagsManager.create] to make batch creating projects easier. !!! note The parent tag must already exist prior to calling this method. Arguments: label: Desired label of the tag - tag labels cannot be repeated. color: Hex color string. A random color will be generated if no color is specified. parent: The label of the parent tag if desired (include capitals in the label if it exists). sort: The desired sort type of the tag. Valid integer values are present in the [sort dictionary](tags.md#sort-dictionary). The default sort value will be by 'project' Returns: A dictionary containing all the fields necessary to create a tag remotely. Raises: TypeError: If any of the types of the arguments are wrong. ValueError: Tag label already exists. ValueError: Parent tag does not exist. ValueError: The hex string color inputted is invalid. !!! example ```python tag_name = 'Books' # The name for our tag parent_name = 'Productivity' # The desired parent tag -> this should already exist. color_code = '#1387c4' sort_type = 1 # Sort by `dueDate` tag_object = client.tag.builder(tag_name, parent=parent_name, color=color_code, sort=sort_type) ``` ??? success \"Result\" The required fields to create a tag object are created and returned in a dictionary. ```python {'label': 'Fiction', 'color': '#1387c4', 'parent': 'books', 'sortType': 'dueDate', 'name': 'fiction'} ``` \"\"\" # Perform checks return self . _check_fields ( label , color = color , parent_label = parent , sort = sort )","title":"builder()"},{"location":"usage/tags/#managers.tags.TagsManager.color","text":"Change the color of a tag. For batch changing colors, see update . Parameters: Name Type Description Default label str The label of the tag to be changed. required color str The new desired hex color string. required Returns: Type Description dict The updated tag dictionary object. Exceptions: Type Description TypeError If label or color are not strings. ValueError If the tag label does not exist. ValueError If color is not a valid hex color string. RuntimeError If changing the color was not successful. Changing a Tag's Color # Lets assume that we have a tag named \"Movies\" that we want to change the color for. new_color = '#134397' movies_updated = client . tag . color ( 'Movies' , new_color ) Result The updated tag dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#134397' , 'etag' : 'wwb49yfr' } Before After Source code in managers/tags.py def color ( self , label : str , color : str ) -> dict : \"\"\" Change the color of a tag. For batch changing colors, see [update][managers.tags.TagsManager.update]. Arguments: label: The label of the tag to be changed. color: The new desired hex color string. Returns: The updated tag dictionary object. Raises: TypeError: If `label` or `color` are not strings. ValueError: If the tag `label` does not exist. ValueError: If `color` is not a valid hex color string. RuntimeError: If changing the color was not successful. !!! example \"Changing a Tag's Color\" ```python # Lets assume that we have a tag named \"Movies\" that we want to change the color for. new_color = '#134397' movies_updated = client.tag.color('Movies', new_color) ``` ??? success \"Result\" The updated tag dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'project', 'color': '#134397', 'etag': 'wwb49yfr'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104661749-0eda7d00-567e-11eb-836f-3a8851bcf9a5.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104661860-55c87280-567e-11eb-93b5-054fa4f1104a.png) \"\"\" if not isinstance ( label , str ) or not isinstance ( color , str ): raise TypeError ( 'Label and Color Must Be Strings' ) # Get the object label = label . lower () obj = self . _client . get_by_fields ( name = label , search = 'tags' ) if not obj : raise ValueError ( f \"Tag ' { label } ' Does Not Exist To Update\" ) # Check the color if not check_hex_color ( color ): raise ValueError ( f \"Hex Color String ' { color } ' Is Not Valid\" ) obj [ 'color' ] = color # Set the color url = self . _client . BASE_URL + 'batch/tag' payload = { 'update' : [ obj ] } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () return self . _client . get_by_etag ( response [ 'id2etag' ][ obj [ 'name' ]])","title":"color()"},{"location":"usage/tags/#managers.tags.TagsManager.create","text":"Creates a tag remotely. Supports single tag creation or batch tag creation. Tip Allows creation with a label that may normally not be allowed by TickTick for tags. Normal TickTick excluded characters are: \\ / \" # : * ? < > | Space Parameters: Name Type Description Default label str or list Single Tag (str) : The desired label of the tag. Tag labels cannot be repeated. Multiple Tags (list) : A list of tag objects created using the builder method. required color str Hex color string. A random color will be generated if no color is specified. 'random' parent str The label of the parent tag if desired (include capitals in if it exists). None sort int The desired sort type of the tag. Valid integer values are present in the sort dictionary . The default sort value will be by 'project' None Returns: Type Description dict or list Single Tag (dict) : The created tag object dictionary. Multiple Tags (list) : A list of the created tag object dictionaries. Exceptions: Type Description TypeError If any of the types of the arguments are wrong. ValueError Tag label already exists. ValueError Parent tag does not exist. ValueError The hex string color inputted is invalid. RuntimeError The tag(s) could not be created. Single Tag Just A Label tag = client . tag . create ( 'Fun' ) Result The tag object dictionary is returned. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#9b69f3' , 'etag' : '7fc8zb58' } Our tag is created. Specify a Color A random color can be generated using generate_hex_color . However, just not specifying a color will automatically generate a random color (as seen in the previous tab) You can always specify the color that you want. tag = client . tag . create ( 'Fun' , color = '#86bb6d' ) Result The tag object dictionary is returned and our project is created with the color specified. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#86bb6d' , 'etag' : '8bzzdws3' } Specifying a Parent Tag Tags can be nested one level. To create a tag that is nested, include the label of the parent tag. The parent tag should already exist. tag = client . tag . create ( 'Fun' , parent = 'Hobbies' ) Result The tag object dictionary is returned and our tag is created nested under the parent tag. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#d2a6e4' , 'etag' : 'nauticx1' , 'parent' : 'hobbies' } Before After Sort Type You can specify the sort type of the created tag using integer values from the sort dictionary . tag = client . tag . create ( 'Fun' , sort = 2 ) # Sort by `title` Result The tag object dictionary is returned and our tag has the specified sort type. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'title' , 'color' : '#e7e7ba' , 'etag' : 'n4k3pezc' } Multiple Tag Creation (batch) To create multiple tags, build the tag objects first using the builder method. Pass in a list of the project objects to create them remotely. parent_tag = client . tag . create ( 'Hobbies' ) # Create a parent tag. # We will create tag objects using builder that will be nested under the parent tag fun_tag = client . tag . builder ( 'Fun' , sort = 2 , parent = 'Hobbies' ) read_tag = client . tag . builder ( 'Read' , color = '#d2a6e4' , parent = 'Hobbies' ) movie_tag = client . tag . builder ( 'Movies' , parent = 'Hobbies' ) # Create the tags tag_list = [ fun_tag , read_tag , movie_tag ] created_tags = client . tag . create ( tag_list ) Result The tag object dictionaries are returned in a list. [{ 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'title' , 'color' : '#172d1c' , 'etag' : '1tceclp4' , 'parent' : 'hobbies' }, { 'name' : 'read' , 'label' : 'Read' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#d2a6e4' , 'etag' : 'ykdem8dg' , 'parent' : 'hobbies' }, { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#94a5f8' , 'etag' : 'o0nifkbv' , 'parent' : 'hobbies' }] Source code in managers/tags.py def create ( self , label , color : str = 'random' , parent : str = None , sort : int = None ): \"\"\" Creates a tag remotely. Supports single tag creation or batch tag creation. !!! tip Allows creation with a label that may normally not be allowed by `TickTick` for tags. Normal `TickTick` excluded characters are: \\\\ / \" # : * ? < > | Space Arguments: label (str or list): **Single Tag (str)**: The desired label of the tag. Tag labels cannot be repeated. **Multiple Tags (list)**: A list of tag objects created using the [builder][managers.tags.TagsManager.builder] method. color: Hex color string. A random color will be generated if no color is specified. parent: The label of the parent tag if desired (include capitals in if it exists). sort: The desired sort type of the tag. Valid integer values are present in the [sort dictionary](tags.md#sort-dictionary). The default sort value will be by 'project' Returns: dict or list: **Single Tag (dict)**: The created tag object dictionary. **Multiple Tags (list)**: A list of the created tag object dictionaries. Raises: TypeError: If any of the types of the arguments are wrong. ValueError: Tag label already exists. ValueError: Parent tag does not exist. ValueError: The hex string color inputted is invalid. RuntimeError: The tag(s) could not be created. !!! example \"Single Tag\" === \"Just A Label\" ```python tag = client.tag.create('Fun') ``` ??? success \"Result\" The tag object dictionary is returned. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'project', 'color': '#9b69f3', 'etag': '7fc8zb58'} ``` Our tag is created. ![image](https://user-images.githubusercontent.com/56806733/104658773-5bbb5500-5678-11eb-9d44-27214203d70e.png) === \"Specify a Color\" A random color can be generated using [generate_hex_color][helpers.hex_color.generate_hex_color]. However, just not specifying a color will automatically generate a random color (as seen in the previous tab) You can always specify the color that you want. ```python tag = client.tag.create('Fun', color='#86bb6d') ``` ??? success \"Result\" The tag object dictionary is returned and our project is created with the color specified. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'project', 'color': '#86bb6d', 'etag': '8bzzdws3'} ``` ![image](https://user-images.githubusercontent.com/56806733/104659184-0c295900-5679-11eb-9f3c-2cd154c0500c.png) === \"Specifying a Parent Tag\" Tags can be nested one level. To create a tag that is nested, include the label of the parent tag. The parent tag should already exist. ```python tag = client.tag.create('Fun', parent='Hobbies') ``` ??? success \"Result\" The tag object dictionary is returned and our tag is created nested under the parent tag. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'project', 'color': '#d2a6e4', 'etag': 'nauticx1', 'parent': 'hobbies'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104659785-24e63e80-567a-11eb-9a62-01ebca55e649.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104659814-33ccf100-567a-11eb-8dca-c91aea68b4c7.png) === \"Sort Type\" You can specify the sort type of the created tag using integer values from the [sort dictionary](#sort-dictionary). ```python tag = client.tag.create('Fun', sort=2) # Sort by `title` ``` ??? success \"Result\" The tag object dictionary is returned and our tag has the specified sort type. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'title', 'color': '#e7e7ba', 'etag': 'n4k3pezc'} ``` ![image](https://user-images.githubusercontent.com/56806733/104660156-e4d38b80-567a-11eb-8c61-8fb874a515a2.png) !!! example \"Multiple Tag Creation (batch)\" To create multiple tags, build the tag objects first using the [builder][managers.projects.ProjectManager.builder] method. Pass in a list of the project objects to create them remotely. ```python parent_tag = client.tag.create('Hobbies') # Create a parent tag. # We will create tag objects using builder that will be nested under the parent tag fun_tag = client.tag.builder('Fun', sort=2, parent='Hobbies') read_tag = client.tag.builder('Read', color='#d2a6e4', parent='Hobbies') movie_tag = client.tag.builder('Movies', parent='Hobbies') # Create the tags tag_list = [fun_tag, read_tag, movie_tag] created_tags = client.tag.create(tag_list) ``` ??? success \"Result\" The tag object dictionaries are returned in a list. ```python [{'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'title', 'color': '#172d1c', 'etag': '1tceclp4', 'parent': 'hobbies'}, {'name': 'read', 'label': 'Read', 'sortOrder': 0, 'sortType': 'project', 'color': '#d2a6e4', 'etag': 'ykdem8dg', 'parent': 'hobbies'}, {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'project', 'color': '#94a5f8', 'etag': 'o0nifkbv', 'parent': 'hobbies'}] ``` ![image](https://user-images.githubusercontent.com/56806733/104660625-cb7f0f00-567b-11eb-8649-68646870ccfa.png) \"\"\" batch = False # Bool signifying batch create or not if isinstance ( label , list ): # Batch tag creation triggered obj = label # Assuming all correct objects batch = True else : if not isinstance ( label , str ): raise TypeError ( 'Required Positional Argument Must Be A String or List of Tag Objects' ) # Create a single object obj = self . builder ( label = label , color = color , parent = parent , sort = sort ) if not batch : obj = [ obj ] url = self . _client . BASE_URL + 'batch/tag' payload = { 'add' : obj } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () if not batch : return self . _client . get_by_etag ( self . _client . parse_etag ( response ), search = 'tags' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Tag names are out of order labels = [ x [ 'name' ] for x in obj ] # Tag names are in order items = [ '' ] * len ( obj ) # Create enough spots for the objects for tag in etag2 : index = labels . index ( tag ) # Object of the index is here actual_etag = etag [ tag ] # Get the actual etag found = self . _client . get_by_etag ( actual_etag , search = 'tags' ) items [ index ] = found # Place at the correct index if len ( items ) == 1 : return items [ 0 ] else : return items","title":"create()"},{"location":"usage/tags/#managers.tags.TagsManager.delete","text":"Delete tag(s). Supports single tag deletion and \"mock\" batch tag deletion. Info Batch deleting for tags is not supported by TickTick. However, passing in a list of labels to delete will \"mock\" batch deleting - but individual requests will have to be made for each deletion. Parameters: Name Type Description Default label str or list Single Tag (str) : The label of the tag. Multiple Tags (list) : A list of tag label strings. required Returns: Type Description dict or list Single Tag (dict) : The dictionary object of the deleted tag. Multiple Tags (list) : The dictionary objects of the deleted tags in a list. Exceptions: Type Description TypeError If label is not a string or list. ValueError If a label does not exist. RuntimeError If the tag could not be deleted successfully. Tag Deletion Single Tag Deletion Deleting a single tag requires passing in the label string of the tag. # Lets delete a tag named \"Fun\" delete_tag = client . tag . delete ( \"Fun\" ) Result The dictionary object of the deleted tag returned. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : - 3298534883328 , 'sortType' : 'project' , 'color' : '#A9949E' , 'etag' : '32balm5l' } Before \"Fun\" Tag Exists After \"Fun\" Tag Does Not Exist Multiple Tag Deletion Deleting multiple tags requires passing the label strings of the tags in a list. # Lets delete tags named \"Fun\", \"Movies\", and \"Hobbies\" delete_labels = [ \"Fun\" , \"Movies\" , \"Hobbies\" ] deleted_tags = client . tag . delete ( delete_labels ) Result The dictionary object of the deleted tags returned in a list. [{ 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : - 3848290697216 , 'sortType' : 'project' , 'color' : '#FFD966' , 'etag' : '56aa6dva' }, { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : - 2748779069440 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : 's0czro3e' }, { 'name' : 'hobbies' , 'label' : 'Hobbies' , 'sortOrder' : - 2199023255552 , 'sortType' : 'project' , 'color' : '#ABA6B5' , 'etag' : 'shu2xbvq' }] Before All three tags exist. After All three tags don't exist. Source code in managers/tags.py def delete ( self , label ): \"\"\" Delete tag(s). Supports single tag deletion and \"mock\" batch tag deletion. !!! info Batch deleting for tags is not supported by TickTick. However, passing in a list of labels to delete will \"mock\" batch deleting - but individual requests will have to be made for each deletion. Arguments: label (str or list): **Single Tag (str)**: The label of the tag. **Multiple Tags (list)**: A list of tag label strings. Returns: dict or list: **Single Tag (dict)**: The dictionary object of the deleted tag. **Multiple Tags (list)**: The dictionary objects of the deleted tags in a list. Raises: TypeError: If `label` is not a string or list. ValueError: If a label does not exist. RuntimeError: If the tag could not be deleted successfully. !!! example \"Tag Deletion\" === \"Single Tag Deletion\" Deleting a single tag requires passing in the label string of the tag. ```python # Lets delete a tag named \"Fun\" delete_tag = client.tag.delete(\"Fun\") ``` ??? success \"Result\" The dictionary object of the deleted tag returned. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': -3298534883328, 'sortType': 'project', 'color': '#A9949E', 'etag': '32balm5l'} ``` **Before** \"Fun\" Tag Exists ![image](https://user-images.githubusercontent.com/56806733/104668024-2c164800-568c-11eb-853e-5b7eba1f4528.png) **After** \"Fun\" Tag Does Not Exist ![image](https://user-images.githubusercontent.com/56806733/104667768-ac887900-568b-11eb-9bfb-597c752e4c3b.png) === \"Multiple Tag Deletion\" Deleting multiple tags requires passing the label strings of the tags in a list. ```python # Lets delete tags named \"Fun\", \"Movies\", and \"Hobbies\" delete_labels = [\"Fun\", \"Movies\", \"Hobbies\"] deleted_tags = client.tag.delete(delete_labels) ``` ??? success \"Result\" The dictionary object of the deleted tags returned in a list. ```python [{'name': 'fun', 'label': 'Fun', 'sortOrder': -3848290697216, 'sortType': 'project', 'color': '#FFD966', 'etag': '56aa6dva'}, {'name': 'movies', 'label': 'Movies', 'sortOrder': -2748779069440, 'sortType': 'dueDate', 'color': '#134397', 'etag': 's0czro3e'}, {'name': 'hobbies', 'label': 'Hobbies', 'sortOrder': -2199023255552, 'sortType': 'project', 'color': '#ABA6B5', 'etag': 'shu2xbvq'}] ``` **Before** All three tags exist. ![image](https://user-images.githubusercontent.com/56806733/104668135-61bb3100-568c-11eb-8707-314deb42cd1d.png) **After** All three tags don't exist. ![image](https://user-images.githubusercontent.com/56806733/104668185-7b5c7880-568c-11eb-8da0-aaee68d53500.png) \"\"\" # Determine if the tag exists if not isinstance ( label , str ) and not isinstance ( label , list ): raise TypeError ( 'Label Must Be A String or List Of Strings' ) url = self . _client . BASE_URL + 'tag' if isinstance ( label , str ): label = [ label ] # If a singular string we are going to add it to a list objects = [] for lbl in label : if not isinstance ( lbl , str ): raise TypeError ( f \"' { lbl } ' Must Be A String\" ) lbl = lbl . lower () tag_obj = self . _client . get_by_fields ( name = lbl , search = 'tags' ) # Get the tag object if not tag_obj : raise ValueError ( f \"Tag ' { lbl } ' Does Not Exist To Delete\" ) # We can assume that only one tag has the name params = { 'name' : tag_obj [ 'name' ] } response = self . _client . http_delete ( url , params = params , cookies = self . _client . cookies , headers = self . headers ) # Find the tag in the tags list and delete it, then return the deleted object objects . append ( self . _client . delete_from_local_state ( search = 'tags' , etag = tag_obj [ 'etag' ])) self . _client . sync () if len ( objects ) == 1 : return objects [ 0 ] else : return objects","title":"delete()"},{"location":"usage/tags/#managers.tags.TagsManager.merge","text":"Merges the tasks of the passed tags into the argument merged and deletes all the tags except merged Args can be individual label strings, or a list of strings Parameters: Name Type Description Default label str or list Single Tag (str) : The label string of the tag to merge. Multiple Tags (list) : The label strings of the tags to merge in a list. required merged str The label of the tag that will remain after the merge. required Returns: Type Description dict The tag dictionary object that remains after the merge. Exceptions: Type Description TypeError If merged is not a str or if label is not a str or list. ValueError If any of the labels do not exist. RuntimeError If the merge could not be successfully completed. Merging Tags Merging Two Tags Merging two tags requires the label of the tag that you want kept after the merge, and the label of the tag that will be merged. Lets assume that we have two tags: \"Work\" and \"School\". I want to merge the tag \"School\" into \"Work\". What should happen is that any tasks that are tagged \"School\", will be updated to have the tag \"Work\", and the \"School\" tag will be deleted. merged_tags = client . tag . merge ( \"School\" , \"Work\" ) Result The tag that remains after the merge is returned. { 'name' : 'work' , 'label' : 'Work' , 'sortOrder' : 2199023255552 , 'sortType' : 'project' , 'color' : '#3876E4' , 'etag' : 'eeh8zrup' } Before \"School\" has two tasks that have it's tag. \"Work\" has no tasks. After \"School\" has been deleted. The tasks that used to be tagged with \"School\" are now tagged with \"Work\". Merging Three Or More Tags Merging multiple tags into a single tag requires passing the labels of the tags to merge in a list. Lets assume that we have three tags: \"Work\", \"School\", and \"Hobbies\" . I want to merge the tag \"School\" and the tag \"Hobbies\" into \"Work\". What should happen is that any tasks that are tagged with \"School\" or \"Hobbies\", will be updated to have the tag \"Work\", and the \"School\" and \"Hobbies\" tags will be deleted. merge_tags = [ \"School\" , \"Hobbies\" ] result = client . tag . merge ( merge_tags , \"Work\" ) Result The tag that remains after the merge is returned. { 'name' : 'work' , 'label' : 'Work' , 'sortOrder' : 2199023255552 , 'sortType' : 'project' , 'color' : '#3876E4' , 'etag' : 'ke23lp06' } Before \"School\" has two tasks. \"Hobbies\" has two tasks. \"Work\" has one task. After \"Work\" has five tasks now, and the tags \"School\" and \"Hobbies\" have been deleted. Source code in managers/tags.py def merge ( self , label , merged : str ): \"\"\" Merges the tasks of the passed tags into the argument `merged` and deletes all the tags except `merged` Args can be individual label strings, or a list of strings Arguments: label (str or list): **Single Tag (str)**: The label string of the tag to merge. **Multiple Tags (list)**: The label strings of the tags to merge in a list. merged: The label of the tag that will remain after the merge. Returns: dict: The tag dictionary object that remains after the merge. Raises: TypeError: If `merged` is not a str or if `label` is not a str or list. ValueError: If any of the labels do not exist. RuntimeError: If the merge could not be successfully completed. !!! example \"Merging Tags\" === \"Merging Two Tags\" Merging two tags requires the label of the tag that you want kept after the merge, and the label of the tag that will be merged. Lets assume that we have two tags: \"Work\" and \"School\". I want to merge the tag \"School\" into \"Work\". What should happen is that any tasks that are tagged \"School\", will be updated to have the tag \"Work\", and the \"School\" tag will be deleted. ```python merged_tags = client.tag.merge(\"School\", \"Work\") ``` ??? success \"Result\" The tag that remains after the merge is returned. ```python {'name': 'work', 'label': 'Work', 'sortOrder': 2199023255552, 'sortType': 'project', 'color': '#3876E4', 'etag': 'eeh8zrup'} ``` **Before** \"School\" has two tasks that have it's tag. ![image](https://user-images.githubusercontent.com/56806733/104680244-45c38980-56a4-11eb-968d-884160c77247.png) \"Work\" has no tasks. ![image](https://user-images.githubusercontent.com/56806733/104680366-90dd9c80-56a4-11eb-975f-5e769e9ea491.png) **After** \"School\" has been deleted. The tasks that used to be tagged with \"School\" are now tagged with \"Work\". ![image](https://user-images.githubusercontent.com/56806733/104680576-0c3f4e00-56a5-11eb-9536-ef3a7fcf20ec.png) === \"Merging Three Or More Tags\" Merging multiple tags into a single tag requires passing the labels of the tags to merge in a list. Lets assume that we have three tags: \"Work\", \"School\", and \"Hobbies\" . I want to merge the tag \"School\" and the tag \"Hobbies\" into \"Work\". What should happen is that any tasks that are tagged with \"School\" or \"Hobbies\", will be updated to have the tag \"Work\", and the \"School\" and \"Hobbies\" tags will be deleted. ```python merge_tags = [\"School\", \"Hobbies\"] result = client.tag.merge(merge_tags, \"Work\") ``` ??? success \"Result\" The tag that remains after the merge is returned. ```python {'name': 'work', 'label': 'Work', 'sortOrder': 2199023255552, 'sortType': 'project', 'color': '#3876E4', 'etag': 'ke23lp06'} ``` **Before** \"School\" has two tasks. ![image](https://user-images.githubusercontent.com/56806733/104681135-7ad0db80-56a6-11eb-81dd-03e4a151cfd9.png) \"Hobbies\" has two tasks. ![image](https://user-images.githubusercontent.com/56806733/104681104-67257500-56a6-11eb-99b0-57bbb876a59e.png) \"Work\" has one task. ![image](https://user-images.githubusercontent.com/56806733/104681164-89b78e00-56a6-11eb-99a8-c85ef418d2a0.png) **After** \"Work\" has five tasks now, and the tags \"School\" and \"Hobbies\" have been deleted. ![image](https://user-images.githubusercontent.com/56806733/104681239-b7043c00-56a6-11eb-9b45-5522b9c69cb0.png) \"\"\" # Make sure merged is a string if not isinstance ( merged , str ): raise ValueError ( 'Merged Must Be A String' ) # Make sure label is a string or list if not isinstance ( label , str ) and not isinstance ( label , list ): raise ValueError ( f \"Label must be a string or a list.\" ) # Lowercase merged merged = merged . lower () # Make sure merged exists kept_obj = self . _client . get_by_fields ( name = merged , search = 'tags' ) if not kept_obj : raise ValueError ( f \"Kept Tag ' { merged } ' Does Not Exist To Merge\" ) merge_queue = [] # Verify all args are valid, and add them to a list if isinstance ( label , str ): string = label . lower () # Make sure it exists retrieved = self . _client . get_by_fields ( name = string , search = 'tags' ) if not retrieved : raise ValueError ( f \"Tag ' { label } ' Does Not Exist To Merge\" ) merge_queue . append ( retrieved ) else : for item in label : # Loop through the items in the list and check items are a string and exist # Make sure the item is a string if not isinstance ( item , str ): raise ValueError ( f \"Item ' { item } ' Must Be A String\" ) string = item . lower () # Make sure it exists found = self . _client . get_by_fields ( name = string , search = 'tags' ) if not found : raise ValueError ( f \"Tag ' { item } ' Does Not Exist To Merge\" ) merge_queue . append ( found ) for labels in merge_queue : # Merge url = self . _client . BASE_URL + 'tag/merge' payload = { 'name' : labels [ 'name' ], 'newName' : kept_obj [ 'name' ] } self . _client . http_put ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () return kept_obj","title":"merge()"},{"location":"usage/tags/#managers.tags.TagsManager.nesting","text":"Update tag nesting. Move an already created tag to be nested underneath a parent tag - or ungroup an already nested tag. Nesting Tags More Than One Level Does Not Work Example Nesting Explanation Parent Tag -> Level Zero Child Tag 1 -> Level One: This is the most nesting that is allowed by TickTick for tags. Child Tag 2 -> Level Two: Not allowed Parameters: Name Type Description Default child str Label of the tag to become the child required parent str Label of the tag that will become the parent. required Returns: Type Description dict The updated tag object dictionary. Exceptions: Type Description TypeError If child and parent are not strings ValueError If child does not exist to update. ValueError If parent does not exist. RuntimeError If setting the parent was unsuccessful. Nesting Nesting A Tag To nest a tag underneath another tag, pass in the labels of the child and parent. # Lets assume that we have a tag named \"Movies\" # We have another tag named \"Hobbies\" that we want to make the parent to \"Movies\" child = \"Movies\" parent = \"Hobbies\" nesting_update = client . tag . nesting ( child , parent ) Result The updated child tag dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : 'ee34aft9' , 'parent' : 'hobbies' } Before After Changing The Parent Of An Already Nested Tag If the tag is already nested, changing the parent is still no different. # We have a tag named \"Movies\" that is already nested underneath \"Hobbies\" # We want to nest \"Movies\" underneath the tag \"Fun\" instead. child = \"Movies\" parent = \"Fun\" nesting_update = client . tag . nesting ( child , parent ) Result The updated child tag dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : '91qpuq71' , 'parent' : 'fun' } Before After Un-grouping A Child Tag If the tag is nested and you want to ungroup it, pass in None for parent . # We have a tag named \"Movies\" that is nested underneath \"Fun\" # We don't want to have \"Movies\" nested anymore. child = \"Movies\" parent = None nesting_update = client . tag . nesting ( child , parent ) Result The updated child tag dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : 'jcoc94p6' } Before After Source code in managers/tags.py def nesting ( self , child : str , parent : str ) -> dict : \"\"\" Update tag nesting. Move an already created tag to be nested underneath a parent tag - or ungroup an already nested tag. !!! warning \"Nesting Tags More Than One Level Does Not Work\" !!! example === \"Nesting Explanation\" ```md Parent Tag -> Level Zero Child Tag 1 -> Level One: This is the most nesting that is allowed by TickTick for tags. Child Tag 2 -> Level Two: Not allowed ``` Arguments: child: Label of the tag to become the child parent: Label of the tag that will become the parent. Returns: The updated tag object dictionary. Raises: TypeError: If `child` and `parent` are not strings ValueError: If `child` does not exist to update. ValueError: If `parent` does not exist. RuntimeError: If setting the parent was unsuccessful. !!! example \"Nesting\" === \"Nesting A Tag\" To nest a tag underneath another tag, pass in the labels of the child and parent. ```python # Lets assume that we have a tag named \"Movies\" # We have another tag named \"Hobbies\" that we want to make the parent to \"Movies\" child = \"Movies\" parent = \"Hobbies\" nesting_update = client.tag.nesting(child, parent) ``` ??? success \"Result\" The updated child tag dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'dueDate', 'color': '#134397', 'etag': 'ee34aft9', 'parent': 'hobbies'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104665300-da6abf00-5685-11eb-947f-889187cec008.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104665366-f706f700-5685-11eb-93eb-9316befec5fc.png) === \"Changing The Parent Of An Already Nested Tag\" If the tag is already nested, changing the parent is still no different. ```python # We have a tag named \"Movies\" that is already nested underneath \"Hobbies\" # We want to nest \"Movies\" underneath the tag \"Fun\" instead. child = \"Movies\" parent = \"Fun\" nesting_update = client.tag.nesting(child, parent) ``` ??? success \"Result\" The updated child tag dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'dueDate', 'color': '#134397', 'etag': '91qpuq71', 'parent': 'fun'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104665599-ab088200-5686-11eb-8b36-5ee873289db7.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104665821-35e97c80-5687-11eb-8098-426816970f3e.png) === \"Un-grouping A Child Tag\" If the tag is nested and you want to ungroup it, pass in `None` for `parent`. ```python # We have a tag named \"Movies\" that is nested underneath \"Fun\" # We don't want to have \"Movies\" nested anymore. child = \"Movies\" parent = None nesting_update = client.tag.nesting(child, parent) ``` ??? success \"Result\" The updated child tag dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'dueDate', 'color': '#134397', 'etag': 'jcoc94p6'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104666038-be681d00-5687-11eb-8490-83c370977267.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104666080-dcce1880-5687-11eb-9ca8-5abcdb4109ba.png) \"\"\" if not isinstance ( child , str ): raise TypeError ( 'Inputs Must Be Strings' ) if parent is not None : if not isinstance ( parent , str ): raise TypeError ( 'Inputs Must Be Strings' ) # Get the object child = child . lower () obj = self . _client . get_by_fields ( name = child , search = 'tags' ) if not obj : raise ValueError ( f \"Tag ' { child } ' Does Not Exist To Update\" ) # Four Cases # Case 1: No Parent -> Want a Parent # Case 2: No Parent -> Doesn't Want a Parent # Case 3: Has Parent -> Wants a Different Parent # Case 4: Has Parent -> Doesn't Want a Parent # Case 1: Determine if the object has a parent try : if obj [ 'parent' ]: # It has a parent if parent is not None : # Case 3 # check if the parent is already the same, if it is just return if obj [ 'parent' ] == parent . lower (): return obj else : new_p = parent . lower () obj [ 'parent' ] = new_p else : new_p = obj [ 'parent' ] # Case 4 obj [ 'parent' ] = '' elif obj [ 'parent' ] is None : raise ValueError ( 'Parent Does Not Exist' ) except KeyError : # It does not have a parent if parent is not None : # Wants a different parent new_p = parent . lower () # -> Case 1 obj [ 'parent' ] = new_p else : # Doesn't want a parent -> Case 2 return obj # We don't have to do anything if no parent and doesn't want a parent # Have to find the project pobj = self . _client . get_by_fields ( name = new_p , search = 'tags' ) if not pobj : raise ValueError ( f \"Tag ' { parent } ' Does Not Exist To Set As Parent\" ) url = self . _client . BASE_URL + 'batch/tag' payload = { 'update' : [ pobj , obj ] } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () return self . _client . get_by_etag ( response [ 'id2etag' ][ obj [ 'name' ]], search = 'tags' )","title":"nesting()"},{"location":"usage/tags/#managers.tags.TagsManager.rename","text":"Renames a tag. Parameters: Name Type Description Default old str Current label of the tag to be changed. required new str Desired new label of the tag. required Returns: Type Description dict The tag object with the updated label. Exceptions: Type Description TypeError If old and new are not strings. ValueError If the old tag label does not exist. ValueError If the new tag label already exists. RuntimeError If the renaming was unsuccessful. Changing a Tag's Label Pass in the current label of the tag, and the desired new label of the tag. # Lets assume that we have a tag that already exists named \"Movie\" old_label = \"Movie\" new_label = \"Movies\" updated_tag = client . tag . rename ( old_label , new_label ) Result The updated tag object dictionary is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#134397' , 'etag' : 'qer1jygy' } Before After Source code in managers/tags.py def rename ( self , old : str , new : str ) -> dict : \"\"\" Renames a tag. Arguments: old: Current label of the tag to be changed. new: Desired new label of the tag. Returns: The tag object with the updated label. Raises: TypeError: If `old` and `new` are not strings. ValueError: If the `old` tag label does not exist. ValueError: If the `new` tag label already exists. RuntimeError: If the renaming was unsuccessful. !!! example \"Changing a Tag's Label\" Pass in the current label of the tag, and the desired new label of the tag. ```python # Lets assume that we have a tag that already exists named \"Movie\" old_label = \"Movie\" new_label = \"Movies\" updated_tag = client.tag.rename(old_label, new_label) ``` ??? success \"Result\" The updated tag object dictionary is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'project', 'color': '#134397', 'etag': 'qer1jygy'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104661255-fcac0f00-567c-11eb-9f10-69af8b50e0b4.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104661299-19e0dd80-567d-11eb-825f-758d83178295.png) \"\"\" # Check that both old and new are strings if not isinstance ( old , str ) or not isinstance ( new , str ): raise TypeError ( 'Old and New Must Be Strings' ) # Make sure the old tag exists old = old . lower () # Check if the tag object exists obj = self . _client . get_by_fields ( name = old , search = 'tags' ) if not obj : raise ValueError ( f \"Tag ' { old } ' Does Not Exist To Rename\" ) # Make sure the new tag does not exist temp_new = new . lower () # Check if the tag object exists found = self . _client . get_by_fields ( name = temp_new , search = 'tags' ) if found : raise ValueError ( f \"Name ' { new } ' Already Exists -> Cannot Duplicate Name\" ) url = self . _client . BASE_URL + 'tag/rename' payload = { 'name' : obj [ 'name' ], 'newName' : new } response = self . _client . http_put ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () # Response from TickTick does not return the new etag of the object, we must find it ourselves new_obj = self . _client . get_by_fields ( name = temp_new , search = 'tags' ) # Return the etag of the updated object return self . _client . get_by_etag ( new_obj [ 'etag' ], search = 'tags' )","title":"rename()"},{"location":"usage/tags/#managers.tags.TagsManager.sorting","text":"Change the sort type of a tag. For batch changing sort types, see update . Parameters: Name Type Description Default label str The label of the tag to be changed. required sort int The new sort type specified by an integer 0-3. See sort dictionary . required Returns: Type Description dict The updated tag dictionary object. Exceptions: Type Description TypeError If label is not a string or if sort is not an int. ValueError If the tag label does not exist. RuntimeError If the updating was unsuccessful. Changing the Sort Type # Lets assume that we have a tag named \"Movies\" with the sort type \"project\" changed_sort_type = client . tag . sorting ( \"Movies\" , 1 ) # Sort by 'dueDate' Result The updated task dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : 'fflj8iy0' } Before After Source code in managers/tags.py def sorting ( self , label : str , sort : int ) -> dict : \"\"\" Change the sort type of a tag. For batch changing sort types, see [update][managers.tags.TagsManager.update]. Arguments: label: The label of the tag to be changed. sort: The new sort type specified by an integer 0-3. See [sort dictionary](tags.md#sort-dictionary). Returns: The updated tag dictionary object. Raises: TypeError: If `label` is not a string or if `sort` is not an int. ValueError: If the tag `label` does not exist. RuntimeError: If the updating was unsuccessful. !!! example \"Changing the Sort Type\" ```python # Lets assume that we have a tag named \"Movies\" with the sort type \"project\" changed_sort_type = client.tag.sorting(\"Movies\", 1) # Sort by 'dueDate' ``` ??? success \"Result\" The updated task dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'dueDate', 'color': '#134397', 'etag': 'fflj8iy0'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104663625-3f241a80-5682-11eb-93a7-73d280c59b3e.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104663663-5531db00-5682-11eb-9440-5673a70840b4.png) \"\"\" if not isinstance ( label , str ) or not isinstance ( sort , int ): raise TypeError ( 'Label Must Be A String and Sort Must Be An Int' ) # Get the object label = label . lower () obj = self . _client . get_by_fields ( name = label , search = 'tags' ) if not obj : raise ValueError ( f \"Tag ' { label } ' Does Not Exist To Update\" ) sort = self . _sort_string_value ( sort ) # Get the sort string for the value obj [ 'sortType' ] = sort # set the object field url = self . _client . BASE_URL + 'batch/tag' payload = { 'update' : [ obj ] } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () return self . _client . get_by_etag ( response [ 'id2etag' ][ obj [ 'name' ]])","title":"sorting()"},{"location":"usage/tags/#managers.tags.TagsManager.update","text":"Generic update method. Supports single and batch tag update. Important Updating tag properties like parent and renaming tags must be completed through their respective class methods to work: nesting and renaming . These updates use different endpoints to the traditional updating. Important You are able to batch update sorting and color of tag objects through this method. If you only need to update single tags, it is recommended you use the class methods: sorting and color Info More information on Tag Object properties here Parameters: Name Type Description Default obj dict or list Single Tag (dict) : The tag dictionary object to update. Multiple Tags (list) : The tag dictionaries to update in a list. required Returns: Type Description dict or list Single Tag (dict) : The updated tag dictionary object. Multiple Tags (list) : The updated tag dictionaries in a list. Exceptions: Type Description TypeError If obj is not a dict or list. RuntimeError If the updating was unsuccessful. Updating Tags Single Tag Update Change a field directly in the task object then pass it to the method. See above for more information about what can actually be successfully changed through this method. # Lets say we have a tag named \"Fun\" that we want to change the color of. # We can change the color by updating the field directly. fun_tag = client . get_by_fields ( label = 'Fun' , search = 'tags' ) # Get the tag object new_color = '#d00000' fun_tag [ 'color' ] = new_color # Change the color updated_fun_tag = client . tag . update ( fun_tag ) # Pass the object to update. Result The updated tag dictionary object is returned. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 2199023255552 , 'sortType' : 'project' , 'color' : '#d00000' , 'etag' : 'i85c8ijo' } Before After Multiple Tag Update Changing the fields is the same as with updating a single tag, except you will need to pass the objects in a list to the method. # Lets update the colors for three tags: \"Fun\", \"Hobbies\", and \"Productivity\" fun_tag = client . get_by_fields ( label = \"Fun\" , search = 'tags' ) hobbies_tag = client . get_by_fields ( label = \"Hobbies\" , search = 'tags' ) productivity_tag = client . get_by_fields ( label = \"Productivity\" , search = 'tags' ) fun_color_new = \"#951a63\" hobbies_color_new = \"#0f8a1f\" productivity_color_new = \"#493293\" # Change the fields directly fun_tag [ 'color' ] = fun_color_new hobbies_tag [ 'color' ] = hobbies_color_new productivity_tag [ 'color' ] = productivity_color_new # The objects must be passed in a list update_tag_list = [ fun_tag , hobbies_tag , productivity_tag ] updated_tags = client . tag . update ( update_tag_list ) Result The updated task dictionary objects are returned in a list. [{ 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : - 1099511627776 , 'sortType' : 'project' , 'color' : '#951a63' , 'etag' : 'n543ajq2' }, { 'name' : 'hobbies' , 'label' : 'Hobbies' , 'sortOrder' : - 549755813888 , 'sortType' : 'project' , 'color' : '#0f8a1f' , 'etag' : 'j4nspkg4' }, { 'name' : 'productivity' , 'label' : 'Productivity' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#493293' , 'etag' : '34qz9bzq' }] Before After Source code in managers/tags.py def update ( self , obj ): \"\"\" Generic update method. Supports single and batch tag update. !!! important Updating tag properties like `parent` and renaming tags must be completed through their respective class methods to work: [nesting][managers.tags.TagsManager.nesting] and [renaming][managers.tags.TagsManager.rename]. These updates use different endpoints to the traditional updating. !!! important You are able to batch update sorting and color of tag objects through this method. If you only need to update single tags, it is recommended you use the class methods: [sorting][managers.tags.TagsManager.sorting] and [color][managers.tags.TagsManager.color] !!! info More information on Tag Object properties [here](tags.md#example-ticktick-tag-dictionary) Arguments: obj (dict or list): **Single Tag (dict)**: The tag dictionary object to update. **Multiple Tags (list)**: The tag dictionaries to update in a list. Returns: dict or list: **Single Tag (dict)**: The updated tag dictionary object. **Multiple Tags (list)**: The updated tag dictionaries in a list. Raises: TypeError: If `obj` is not a dict or list. RuntimeError: If the updating was unsuccessful. !!! example \"Updating Tags\" === \"Single Tag Update\" Change a field directly in the task object then pass it to the method. See above for more information about what can actually be successfully changed through this method. ```python # Lets say we have a tag named \"Fun\" that we want to change the color of. # We can change the color by updating the field directly. fun_tag = client.get_by_fields(label='Fun', search='tags') # Get the tag object new_color = '#d00000' fun_tag['color'] = new_color # Change the color updated_fun_tag = client.tag.update(fun_tag) # Pass the object to update. ``` ??? success \"Result\" The updated tag dictionary object is returned. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 2199023255552, 'sortType': 'project', 'color': '#d00000', 'etag': 'i85c8ijo'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104669635-4aca0e00-568f-11eb-8bc6-9572a432b623.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104669824-ac8a7800-568f-11eb-93d6-ac40235bcd3f.png) === \"Multiple Tag Update\" Changing the fields is the same as with updating a single tag, except you will need to pass the objects in a list to the method. ```python # Lets update the colors for three tags: \"Fun\", \"Hobbies\", and \"Productivity\" fun_tag = client.get_by_fields(label=\"Fun\", search='tags') hobbies_tag = client.get_by_fields(label=\"Hobbies\", search='tags') productivity_tag = client.get_by_fields(label=\"Productivity\", search='tags') fun_color_new = \"#951a63\" hobbies_color_new = \"#0f8a1f\" productivity_color_new = \"#493293\" # Change the fields directly fun_tag['color'] = fun_color_new hobbies_tag['color'] = hobbies_color_new productivity_tag['color'] = productivity_color_new # The objects must be passed in a list update_tag_list = [fun_tag, hobbies_tag, productivity_tag] updated_tags = client.tag.update(update_tag_list) ``` ??? success \"Result\" The updated task dictionary objects are returned in a list. ```python [{'name': 'fun', 'label': 'Fun', 'sortOrder': -1099511627776, 'sortType': 'project', 'color': '#951a63', 'etag': 'n543ajq2'}, {'name': 'hobbies', 'label': 'Hobbies', 'sortOrder': -549755813888, 'sortType': 'project', 'color': '#0f8a1f', 'etag': 'j4nspkg4'}, {'name': 'productivity', 'label': 'Productivity', 'sortOrder': 0, 'sortType': 'project', 'color': '#493293', 'etag': '34qz9bzq'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104670498-cd070200-5690-11eb-9fdd-0287fa6c7e7b.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104670531-dc864b00-5690-11eb-844a-899031335922.png) \"\"\" batch = False # Bool signifying batch create or not if isinstance ( obj , list ): # Batch tag creation triggered obj_list = obj # Assuming all correct objects batch = True else : if not isinstance ( obj , dict ): raise TypeError ( 'Required Positional Argument Must Be A Dict or List of Tag Objects' ) if not batch : obj_list = [ obj ] url = self . _client . BASE_URL + 'batch/tag' payload = { 'update' : obj_list } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () if not batch : return self . _client . get_by_etag ( self . _client . parse_etag ( response ), search = 'tags' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Tag names are out of order labels = [ x [ 'name' ] for x in obj_list ] # Tag names are in order items = [ '' ] * len ( obj_list ) # Create enough spots for the objects for tag in etag2 : index = labels . index ( tag ) # Object of the index is here actual_etag = etag [ tag ] # Get the actual etag found = self . _client . get_by_etag ( actual_etag , search = 'tags' ) items [ index ] = found # Place at the correct index return items","title":"update()"},{"location":"usage/tasks/","text":"Info Task methods are accessed through the task public member of your TickTickClient instance. # Assumes that 'client' is the name that references the TickTickClient instance. task = client . task . method () Tip All supported methods are documented below with usage examples, take a look! All usage examples assume that client is the name referencing the TickTickClient instance Important! The datetime module must be imported to use dates. First Way: import datetime date = datetime . datetime ( 2021 , 1 , 1 ) Second Way: from datetime import datetime date = datetime ( 2021 , 1 , 1 ) Example TickTick Task Dictionary \u00b6 Members { \"id\" : \"String\" , \"projectId\" : \"String\" , \"title\" : \"Task Title\" , \"content\" : \"Task Content\" , \"desc\" : \"Task Description\" , \"allDay\" : True , \"startDate\" : \"2019-11-13T03:00:00+0000\" , \"dueDate\" : \"2019-11-14T03:00:00+0000\" , \"timeZone\" : \"America/Los_Angeles\" , \"reminders\" : [ \"TRIGGER:P0DT9H0M0S\" , \"TRIGGER:PT0S\" ], \"repeat\" : \"RRULE:FREQ=DAILY;INTERVAL=1\" , \"priority\" : 1 , \"status\" : 0 , \"completedTime\" : \"2019-11-13T03:00:00+0000\" , \"sortOrder\" : 12345 , \"items\" : [{ \"id\" : \"String\" , \"status\" : 1 , \"title\" : \"Subtask Title\" , \"sortOrder\" : 12345 , \"startDate\" : \"2019-11-13T03:00:00+0000\" , \"isAllDay\" : False , \"timeZone\" : \"America/Los_Angeles\" , \"completedTime\" : \"2019-11-13T03:00:00+0000\" } Subtask Items \u00b6 Name Description Schema id Subtask identifier string title Subtask title string status The completion status of subtask Value : Normal: 0, Completed: 1 integer (int32) completedTime Subtask completed time in \"yyyy-MM-dd'T'HH:mm:ssZ\" Example : \"2019-11-13T03:00:00+0000\" string (date-time) isAllDay All day boolean sortOrder Subtask sort order Example : 234444 integer (int64) startDate Subtask start date time in \"yyyy-MM-dd'T'HH:mm:ssZ\" Example : \"2019-11-13T03:00:00+0000\" string (date-time) timeZone Subtask timezone Example : \"America/Los_Angeles\" string Task Items \u00b6 Name Description Schema id Task identifier string projectId Task project id string title Task title string allDay All day boolean completedTime Task completed time in \"yyyy-MM-dd'T'HH:mm:ssZ\" Example : \"2019-11-13T03:00:00+0000\" string (date-time) content Task content string desc Task description of checklist string dueDate Task due date time in \"yyyy-MM-dd'T'HH:mm:ssZ\" Example : \"2019-11-13T03:00:00+0000\" string (date-time) items Subtasks of Task < ChecklistItem > array priority Task priority Value : None:0, Low:1, Medium:3, High5 integer (int32) reminders List of reminder triggers Example : [ \"TRIGGER:P0DT9H0M0S\", \"TRIGGER:PT0S\" ] < string > array repeat Recurring rules of task Example : \"RRULE:FREQ=DAILY;INTERVAL=1\" string sortOrder Task sort order Example : 12345 integer (int64) startDate Start date time in \"yyyy-MM-dd'T'HH:mm:ssZ\" Example : \"2019-11-13T03:00:00+0000\" string (date-time) status Task completion status Value : Normal: 0, Completed: 1 integer (int32) timeZone Task timezone Example : \"America/Los_Angeles\" string TaskManager \u00b6 Handles all interactions for tasks. builder ( self , title = '' , projectId = None , content = None , desc = None , allDay = None , startDate = None , dueDate = None , timeZone = None , reminders = None , repeat = None , priority = None , sortOrder = None , items = None ) \u00b6 Builds a task dictionary with the passed fields. This is a helper method for task creation. Parameters: Name Type Description Default title str Desired name of the task '' projectId str ID string of the project None content str Content body of the task None desc str Description of the task checklist None allDay bool Boolean for whether the task is all day or not None startDate datetime.datetime Start time of the task None dueDate datetime.datetime End time of the task None timeZone str Time zone for the task None reminders list List of reminder triggers None repeat str Recurring rules for the task None priority int None:0, Low:1, Medium:3, High5 None sortOrder int Task sort order None items list Subtasks of task None Returns: Type Description dict A dictionary containing the fields necessary for task creation. Example Building a local task object with a title, start, and due time. start = datetime ( 2027 , 5 , 2 ) end = datetime ( 2027 , 5 , 7 ) title = 'Festival' task_dict = client . task . builder ( title , startDate = start , dueDate = end ) Result { 'startDate' : '2027-05-02T07:00:00+0000' , 'dueDate' : '2027-05-08T07:00:00+0000' , 'allDay' : True , 'title' : 'Festival' } Source code in managers/tasks.py def builder ( self , title : str = '' , projectId : str = None , content : str = None , desc : str = None , allDay : bool = None , startDate : datetime . datetime = None , dueDate : datetime . datetime = None , timeZone : str = None , reminders : list = None , repeat : str = None , priority : int = None , sortOrder : int = None , items : list = None ): \"\"\" Builds a task dictionary with the passed fields. This is a helper method for task creation. Arguments: title (str): Desired name of the task projectId (str): ID string of the project content (str): Content body of the task desc (str): Description of the task checklist allDay (bool): Boolean for whether the task is all day or not startDate (datetime.datetime): Start time of the task dueDate (datetime.datetime): End time of the task timeZone (str): Time zone for the task reminders (list): List of reminder triggers repeat (str): Recurring rules for the task priority (int): None:0, Low:1, Medium:3, High5 sortOrder (int): Task sort order items (list): Subtasks of task Returns: dict: A dictionary containing the fields necessary for task creation. !!! example Building a local task object with a title, start, and due time. ```python start = datetime(2027, 5, 2) end = datetime(2027, 5, 7) title = 'Festival' task_dict = client.task.builder(title, startDate=start, dueDate=end) ``` ??? Result ```python {'startDate': '2027-05-02T07:00:00+0000', 'dueDate': '2027-05-08T07:00:00+0000', 'allDay': True, 'title': 'Festival'} ``` \"\"\" task = { 'title' : title } if projectId is not None : task [ 'projectId' ] = projectId if content is not None : task [ 'content' ] = content if desc is not None : task [ 'desc' ] = desc if allDay is not None : task [ 'allDay' ] = allDay if reminders is not None : task [ 'reminders' ] = reminders if repeat is not None : task [ 'repeat' ] = repeat if priority is not None : task [ 'priority' ] = priority if sortOrder is not None : task [ 'sortOrder' ] = sortOrder if items is not None : task [ 'items' ] = items dates = {} # date conversions if startDate is not None : dates = self . dates ( startDate , dueDate , timeZone ) # merge dicts return { ** dates , ** task } complete ( self , task ) \u00b6 Marks a task as complete. Pass in the task dictionary to be marked as completed. Note The task should already be created Parameters: Name Type Description Default task dict The task dictionary object. required Returns: Type Description dict The original passed in task. Task Completing # Lets assume that we have a task named \"Dentist\" that we want to mark as complete. dentist_task = client . get_by_fields ( title = 'Dentist' , search = 'tasks' ) complete_task = client . task . complete ( dentist_task ) # Pass the task dictionary Result The task is completed and the dictionary object returned. { 'id' : '5fff5009b04b355792c79397' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 99230924406784 , 'title' : 'Go To Dentist' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T19:56:11.000+0000' , 'etag' : 'djiiqso6' , 'deleted' : 0 , 'createdTime' : '2021-01-13T19:54:49.000+0000' , 'creator' : 6147345572 , 'kind' : 'TEXT' } Before After Source code in managers/tasks.py def complete ( self , task : dict ): \"\"\" Marks a task as complete. Pass in the task dictionary to be marked as completed. !!! note The task should already be created Arguments: task (dict): The task dictionary object. Returns: dict: The original passed in task. !!! example \"Task Completing\" ```python # Lets assume that we have a task named \"Dentist\" that we want to mark as complete. dentist_task = client.get_by_fields(title='Dentist', search='tasks') complete_task = client.task.complete(dentist_task) # Pass the task dictionary ``` ??? success \"Result\" The task is completed and the dictionary object returned. ```python {'id': '5fff5009b04b355792c79397', 'projectId': 'inbox115781412', 'sortOrder': -99230924406784, 'title': 'Go To Dentist', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T19:56:11.000+0000', 'etag': 'djiiqso6', 'deleted': 0, 'createdTime': '2021-01-13T19:54:49.000+0000', 'creator': 6147345572, 'kind': 'TEXT'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104503673-39510b00-5596-11eb-88df-88eeee9ab4b0.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104504069-c4ca9c00-5596-11eb-96c9-5698e19989ea.png) \"\"\" # generate url url = self . _generate_mark_complete_url ( task [ 'projectId' ], task [ 'id' ]) # make request response = self . _client . http_post ( url = url , json = task , headers = self . oauth_headers ) # sync local state self . _client . sync () if response == '' : return task # return response return response create ( self , task ) \u00b6 Create a task. Use builder for easy task dictionary creation. Warning Creating tasks with tags is not functional but will be implemented in a future update. Parameters: Name Type Description Default task dict Task dictionary to be created. required Returns: Type Description dict Dictionary of created task object. Note that the task object is a \"simplified\" version of the full task object. Use get_by_id for the full task object. Creating Tasks Just A Name title = \"Molly's Birthday\" task = client . task . builder ( title ) # Local dictionary molly = client . task . create ( task ) # Create task remotely Result { 'id' : '60ca9dbc8f08516d9dd56324' , 'projectId' : 'inbox115781412' , 'title' : \"Molly's Birthday\" , 'timeZone' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'sortOrder' : - 1336456383561728 , 'items' : []} Dates and Descriptions title = \"Molly's Birthday Party\" start_time = datetime ( 2027 , 7 , 5 , 14 , 30 ) # 7/5/2027 @ 2:30PM end_time = datetime ( 2027 , 7 , 5 , 19 , 30 ) # 7/5/2027 @ 7:30PM content = \"Bring Cake\" task = client . task . builder ( title , startDate = start_time , dueDate = end_time , content = content ) mollys_party = client . task . create ( task ) Result { 'id' : '60ca9fe58f08fe31011862f2' , 'projectId' : 'inbox115781412' , 'title' : \"Molly's Birthday Party\" , 'content' : 'Bring Cake' , 'timeZone' : '' , 'startDate' : '2027-07-05T21:30:00.000+0000' , 'dueDate' : '2027-07-06T02:30:00.000+0000' , 'priority' : 0 , 'status' : 0 , 'sortOrder' : - 1337555895189504 , 'items' : [], 'allDay' : False } Different Project # Get the project object events = client . get_by_fields ( name = \"Events\" , search = 'projects' ) events_id = events [ 'id' ] # Need the project object id title = \"Molly's Birthday\" task = client . task . builder ( title , projectId = events_id ) mollys_birthday = client . task . create ( task ) Result { 'id' : '60caa2278f08fe3101187002' , 'projectId' : '60caa20d8f08fe3101186f74' , 'title' : \"Molly's Birthday\" , 'timeZone' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'sortOrder' : - 1099511627776 , 'items' : []} Source code in managers/tasks.py def create ( self , task ): \"\"\" Create a task. Use [`builder`][managers.tasks.TaskManager.builder] for easy task dictionary creation. !!! warning Creating tasks with tags is not functional but will be implemented in a future update. Arguments: task (dict): Task dictionary to be created. Returns: dict: Dictionary of created task object. Note that the task object is a \"simplified\" version of the full task object. Use [`get_by_id`][api.TickTickClient.get_by_id] for the full task object. !!! example \"Creating Tasks\" === \"Just A Name\" ```python title = \"Molly's Birthday\" task = client.task.builder(title) # Local dictionary molly = client.task.create(task) # Create task remotely ``` ??? success \"Result\" ```python {'id': '60ca9dbc8f08516d9dd56324', 'projectId': 'inbox115781412', 'title': \"Molly's Birthday\", 'timeZone': '', 'reminders': [], 'priority': 0, 'status': 0, 'sortOrder': -1336456383561728, 'items': []} ``` ![image](https://user-images.githubusercontent.com/56806733/122314079-5898ef00-cecc-11eb-8614-72b070b306c6.png) === \"Dates and Descriptions\" ```python title = \"Molly's Birthday Party\" start_time = datetime(2027, 7, 5, 14, 30) # 7/5/2027 @ 2:30PM end_time = datetime(2027, 7, 5, 19, 30) # 7/5/2027 @ 7:30PM content = \"Bring Cake\" task = client.task.builder(title, startDate=start_time, dueDate=end_time, content=content) mollys_party = client.task.create(task) ``` ??? success \"Result\" ```python {'id': '60ca9fe58f08fe31011862f2', 'projectId': 'inbox115781412', 'title': \"Molly's Birthday Party\", 'content': 'Bring Cake', 'timeZone': '', 'startDate': '2027-07-05T21:30:00.000+0000', 'dueDate': '2027-07-06T02:30:00.000+0000', 'priority': 0, 'status': 0, 'sortOrder': -1337555895189504, 'items': [], 'allDay': False} ``` ![image](https://user-images.githubusercontent.com/56806733/122314760-a4986380-cecd-11eb-88af-9562d352470f.png) === \"Different Project\" ```python # Get the project object events = client.get_by_fields(name=\"Events\", search='projects') events_id = events['id'] # Need the project object id title = \"Molly's Birthday\" task = client.task.builder(title, projectId=events_id) mollys_birthday = client.task.create(task) ``` ??? success \"Result\" ```python {'id': '60caa2278f08fe3101187002', 'projectId': '60caa20d8f08fe3101186f74', 'title': \"Molly's Birthday\", 'timeZone': '', 'reminders': [], 'priority': 0, 'status': 0, 'sortOrder': -1099511627776, 'items': []} ``` ![image](https://user-images.githubusercontent.com/56806733/122315454-eece1480-cece-11eb-8394-94a2aec1ba70.png) \"\"\" # generate url url = self . _generate_create_url () # make request response = self . _client . http_post ( url = url , json = task , headers = self . oauth_headers ) # sync local state self . _client . sync () # TODO: Figure out tags # since the openapi does not explicitly support tag creation - lets create a new tag for the new task # try: # tags = task['tag'] # if isinstance(tags, str): # # single tag -> check to see if it exists before creating another one # search = self._client.get_by_fields(name=tags, search='tags') # elif: # isinstance(tags, list) # # multiple tags # pass # except KeyError: # pass # set 'inbox' to be the actual inbox id if response [ 'projectId' ] == 'inbox' : response [ 'projectId' ] = self . _client . inbox_id # return response return response dates ( self , start , due = None , tz = None ) \u00b6 Performs necessary date conversions from datetime objects to strings. This method allows for more natural input of data to the builder method. Parameters: Name Type Description Default start datetime Desired start time required due datetime Desired end time None tz str Time zone string if the desired time zone is not the account default. None Returns: Type Description dict Contains 'startDate', 'endDate', 'timeZone', and 'allDay' when applicable. All Day Start Time (single day task) All Day Start and End Time (multi-day range) Specific Start Time (specific time task) Specific Start and End Time (specific start and end task) Last Day Of The Month start = datetime ( 2027 , 3 , 27 ) end = datetime ( 2027 , 3 , 31 ) dates = client . task . dates ( start , end ) Result {'startDate': '2027-03-27T07:00:00+0000', 'dueDate': '2027-04-01T07:00:00+0000', 'allDay': True} Source code in managers/tasks.py def dates ( self , start , due = None , tz = None ): \"\"\" Performs necessary date conversions from datetime objects to strings. This method allows for more natural input of data to the [`builder`][managers.tasks.TaskManager.builder] method. Arguments: start (datetime): Desired start time due (datetime): Desired end time tz (str): Time zone string if the desired time zone is not the account default. Returns: dict: Contains 'startDate', 'endDate', 'timeZone', and 'allDay' when applicable. 1. All Day Start Time (single day task) 2. All Day Start and End Time (multi-day range) 3. Specific Start Time (specific time task) 4. Specific Start and End Time (specific start and end task) !!! example \"Last Day Of The Month\" ```python start = datetime(2027, 3, 27) end = datetime(2027, 3, 31) dates = client.task.dates(start, end) ``` ??? success \"Result\" ``` {'startDate': '2027-03-27T07:00:00+0000', 'dueDate': '2027-04-01T07:00:00+0000', 'allDay': True} ``` \"\"\" dates = {} # Set time zone if tz is not None : dates [ 'timeZone' ] = tz else : tz = self . _client . time_zone # Check if just start date if due is None : if start . hour != 0 or start . minute != 0 or start . second != 0 or start . microsecond != 0 : dates [ 'startDate' ] = convert_date_to_tick_tick_format ( start , tz ) dates [ 'allDay' ] = False else : dates [ 'startDate' ] = convert_date_to_tick_tick_format ( start , tz ) dates [ 'allDay' ] = True return dates # Check all day for both if ( start . hour != 0 or start . minute != 0 or start . second != 0 or start . microsecond != 0 or due . hour != 0 or due . minute != 0 or due . second != 0 or due . microsecond != 0 ): # Just convert the dates and return dates [ 'startDate' ] = convert_date_to_tick_tick_format ( start , tz ) dates [ 'dueDate' ] = convert_date_to_tick_tick_format ( due , tz ) dates [ 'allDay' ] = False return dates # All day is true, however normally right now if we were to use a date like Jan 1 - Jan 3, # TickTick would create a task that is only Jan 1 - Jan 2 since the date would be up to Jan 3 # Lets account for that by making the date actually be one more than the current end date # This will allow for more natural date input for all day tasks days = monthrange ( due . year , due . month ) if due . day + 1 > days [ 1 ]: # Last day of the month if due . month + 1 > 12 : # Last month of the year year = due . year + 1 # Both last day of month and last day of year day = 1 month = 1 else : # Not last month of year, just reset the day and increment the month year = due . year month = due . month + 1 day = 1 else : # Dont have to worry about incrementing year or month year = due . year day = due . day + 1 month = due . month due = datetime . datetime ( year , month , day ) # No hours, mins, or seconds needed dates [ 'startDate' ] = convert_date_to_tick_tick_format ( start , tz ) dates [ 'dueDate' ] = convert_date_to_tick_tick_format ( due , tz ) dates [ 'allDay' ] = True return dates delete ( self , task ) \u00b6 Deletes a task. Supports single task deletion, and batch task deletion. For a single task pass in the task dictionary. For multiple tasks pass in a list of task dictionaries. Parameters: Name Type Description Default task str or list Single Task (dict) : Task dictionary to be deleted Multiple Tasks (list) : List of task dictionaries to be deleted required Returns: Type Description dict or list Single Task (dict) : Task dictionary that was deleted Multiple Tasks (list) : List of task dictionaries that were deleted Task Deletion Single Task Deletion # Get the task task = client . get_by_fields ( title = \"Molly's Birthday\" , search = \"tasks\" ) # Delete the task deleted = client . task . delete ( task ) Result { 'id' : '60caa2278f08fe3101187002' , 'projectId' : '60caa20d8f08fe3101186f74' , 'sortOrder' : - 1099511627776 , 'title' : \"Molly's Birthday\" , 'content' : '' , 'startDate' : '2027-05-06T07:00:00.000+0000' , 'dueDate' : '2027-05-06T07:00:00.000+0000' , 'timeZone' : '' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'repeatFirstDate' : '2027-05-05T07:00:00.000+0000' , 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-06-17T01:25:19.000+0000' , 'etag' : 'rrn4paqp' , 'deleted' : 0 , 'createdTime' : '2021-06-17T01:15:19.365+0000' , 'creator' : 119784412 , 'kind' : 'TEXT' } Multiple Task Deletion # Get the tasks wash_car = client . get_by_fields ( title = \"Wash Car\" , search = \"tasks\" ) do_dishes = client . get_by_fields ( title = \"Do Dishes\" , search = \"tasks\" ) # Make a list for the tasks to_delete = [ wash_car , do_dishes ] # Delete the tasks deleted = client . task . delete ( to_delete ) Before Result [{ 'id' : '60caa8e714f7103cef35765a' , 'projectId' : '60caa20d8f08fe3101186f74' , 'sortOrder' : - 1099511627776 , 'title' : 'Wash Car' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-06-17T01:44:07.000+0000' , 'etag' : '8372m61k' , 'deleted' : 0 , 'createdTime' : '2021-06-17T01:44:07.000+0000' , 'creator' : 115761422 , 'tags' : [], 'kind' : 'TEXT' }, { 'id' : '60caa8ea14f7103cef35765f' , 'projectId' : '60caa20d8f08fe3101186f74' , 'sortOrder' : - 2199023255552 , 'title' : 'Do Dishes' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-06-17T01:44:10.000+0000' , 'etag' : 'sfka0mvn' , 'deleted' : 0 , 'createdTime' : '2021-06-17T01:44:10.000+0000' , 'creator' : 1155481312 , 'tags' : [], 'kind' : 'TEXT' }] Source code in managers/tasks.py def delete ( self , task ): \"\"\" Deletes a task. Supports single task deletion, and batch task deletion. For a single task pass in the task dictionary. For multiple tasks pass in a list of task dictionaries. Arguments: task (str or list): **Single Task (dict)**: Task dictionary to be deleted **Multiple Tasks (list)**: List of task dictionaries to be deleted Returns: dict or list: **Single Task (dict)**: Task dictionary that was deleted **Multiple Tasks (list)**: List of task dictionaries that were deleted !!! example \"Task Deletion\" === \"Single Task Deletion\" ```python # Get the task task = client.get_by_fields(title=\"Molly's Birthday\", search=\"tasks\") # Delete the task deleted = client.task.delete(task) ``` ??? success \"Result\" ``` python {'id': '60caa2278f08fe3101187002', 'projectId': '60caa20d8f08fe3101186f74', 'sortOrder': -1099511627776, 'title': \"Molly's Birthday\", 'content': '', 'startDate': '2027-05-06T07:00:00.000+0000', 'dueDate': '2027-05-06T07:00:00.000+0000', 'timeZone': '', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'repeatFirstDate': '2027-05-05T07:00:00.000+0000', 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-06-17T01:25:19.000+0000', 'etag': 'rrn4paqp', 'deleted': 0, 'createdTime': '2021-06-17T01:15:19.365+0000', 'creator': 119784412, 'kind': 'TEXT'} ``` === \"Multiple Task Deletion\" ``` python # Get the tasks wash_car = client.get_by_fields(title=\"Wash Car\", search=\"tasks\") do_dishes = client.get_by_fields(title=\"Do Dishes\", search=\"tasks\") # Make a list for the tasks to_delete = [wash_car, do_dishes] # Delete the tasks deleted = client.task.delete(to_delete) ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/122317746-e11a8e00-ced2-11eb-8449-519615de5935.png) ??? success \"Result\" ```python [{'id': '60caa8e714f7103cef35765a', 'projectId': '60caa20d8f08fe3101186f74', 'sortOrder': -1099511627776, 'title': 'Wash Car', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-06-17T01:44:07.000+0000', 'etag': '8372m61k', 'deleted': 0, 'createdTime': '2021-06-17T01:44:07.000+0000', 'creator': 115761422, 'tags': [], 'kind': 'TEXT'}, {'id': '60caa8ea14f7103cef35765f', 'projectId': '60caa20d8f08fe3101186f74', 'sortOrder': -2199023255552, 'title': 'Do Dishes', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-06-17T01:44:10.000+0000', 'etag': 'sfka0mvn', 'deleted': 0, 'createdTime': '2021-06-17T01:44:10.000+0000', 'creator': 1155481312, 'tags': [], 'kind': 'TEXT'}] ``` ![image](https://user-images.githubusercontent.com/56806733/122317923-2212a280-ced3-11eb-8a6b-8a32fa8426ce.png) \"\"\" # generate url url = self . _generate_delete_url () to_delete = [] # if its just a dict then we are going to have to make a list object for it if isinstance ( task , dict ): # ticktick returns for the 'projectId': 'inbox' instead of the actual inbox id - which is required for # proper deletion if task [ 'projectId' ] == 'inbox' : task [ 'projectId' ] = self . _client . inbox_id delete_dict = { 'projectId' : task [ 'projectId' ], 'taskId' : task [ 'id' ]} to_delete . append ( delete_dict ) # iterate through \"task\" else : for item in task : if item [ 'projectId' ] == 'inbox' : item [ 'projectId' ] = self . _client . inbox_id delete_dict = { 'projectId' : item [ 'projectId' ], 'taskId' : item [ 'id' ]} to_delete . append ( delete_dict ) payload = { 'delete' : to_delete } # make request self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) # sync local state self . _client . sync () # return input return task get_completed ( self , start , end = None , full = True , tz = None ) \u00b6 Obtains all completed tasks from the given start date and end date. Note There is a limit of 100 items for the request Parameters: Name Type Description Default start datetime Start time datetime object. required end datetime End time datetime object. None full bool Boolean specifying whether hours, minutes, and seconds are to be taken into account for the query. True tz str String specifying a specific time zone, however this will default to your accounts normal time zone. None Returns: Type Description list A list containing all the completed tasks based on the times. Exceptions: Type Description TypeError If the proper types are not used. ValueError If start occurs after end. KeyError If the time zone string passed is not a valid time zone string. RuntimeError If getting the tasks is unsuccessful. Getting Completed Tasks Completed Tasks In A Single Day Getting the tasks for a full, complete day requires passing in the datetime object corresponding to the day that you want. # Get the tasks for 1/11/2021 tasks = client . task . get_completed ( datetime ( 2021 , 1 , 11 )) Result The list of completed tasks is returned. [{ 'id' : '5ffca35f4c201114702a0607' , 'projectId' : '004847faa60015487be444cb' , 'sortOrder' : - 50027779063826 , 'title' : 'Shoulders and Arms' , 'content' : '' , 'desc' : '' , 'startDate' : '2021-01-11T08:00:00.000+0000' , 'dueDate' : '2021-01-11T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'repeatFlag' : '' , 'exDate' : [], 'completedTime' : '2021-01-11T23:25:46.000+0000' , 'completedUserId' : 185769383 , 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-11T23:25:41.000+0000' , 'etag' : '6hlk4e8t' , 'deleted' : 0 , 'createdTime' : '2021-01-11T19:13:35.000+0000' , 'creator' : 185769383 , 'tags' : [ 'fitness' ], 'commentCount' : 0 , 'pomodoroSummaries' : [{ 'userId' : 185769383 , 'count' : 0 , 'estimatedPomo' : 0 , 'duration' : 0 }], 'focusSummaries' : [{ 'userId' : 185769383 , 'pomoCount' : 0 , 'estimatedPomo' : 0 , 'estimatedDuration' : 0 , 'pomoDuration' : 0 , 'stopwatchDuration' : 3720 }], 'kind' : 'TEXT' }] Completed Tasks Over A Range Of Days Getting the tasks for a range of days requires passing in datetime objects for the start day, and the end day that you want. # Get the tasks between 8/7/18 and 8/10/18 start = datetime ( 2018 , 8 , 7 ) end = datetime ( 2018 , 8 , 10 ) tasks = client . task . get_completed ( start , end ) Result Completed tasks in a list are returned. [{ 'id' : '5ffffebab04b355792c79e38' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 7696581394432 , 'title' : 'Ride Bike' , 'content' : '' , 'startDate' : '2021-01-14T08:00:00.000+0000' , 'dueDate' : '2021-01-14T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'completedTime' : '2018-08-09T07:20:11.000+0000' , 'completedUserId' : 185769383 , 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T08:21:01.000+0000' , 'etag' : 'mhjyig4y' , 'deleted' : 0 , 'createdTime' : '2021-01-14T08:20:10.000+0000' , 'creator' : 185769383 , 'kind' : 'TEXT' }, { 'id' : '5ffffeaab04b355792c79d89' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 6597069766656 , 'title' : 'Read Book' , 'content' : '' , 'startDate' : '2021-01-14T08:00:00.000+0000' , 'dueDate' : '2021-01-14T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'completedTime' : '2018-08-08T07:20:12.000+0000' , 'completedUserId' : 185769383 , 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T08:20:46.000+0000' , 'etag' : 'tzd4coms' , 'deleted' : 0 , 'createdTime' : '2021-01-14T08:19:54.000+0000' , 'creator' : 185769383 , 'kind' : 'TEXT' }] Completed Tasks Over A Specific Duration Of Time You can also get completed tasks that were completed in a specific time duration. Include specific hours, minutes, and seconds for the datetime objects, and specify full to be false -> meaning that the specific times will be put into effect. # Get the tasks completed between 12PM and 5PM on 12/15/2020 start = datetime ( 2020 , 12 , 15 , 12 ) # 12PM 12/15/2020 end = datetime ( 2020 , 12 , 15 , 17 ) # 5PM 12/15/2020 tasks = client . task . get_completed ( start , end , full = False ) Source code in managers/tasks.py def get_completed ( self , start , end = None , full : bool = True , tz : str = None ) -> list : \"\"\" Obtains all completed tasks from the given start date and end date. !!! note There is a limit of 100 items for the request Arguments: start (datetime): Start time datetime object. end (datetime): End time datetime object. full: Boolean specifying whether hours, minutes, and seconds are to be taken into account for the query. tz: String specifying a specific time zone, however this will default to your accounts normal time zone. Returns: A list containing all the completed tasks based on the times. Raises: TypeError: If the proper types are not used. ValueError: If start occurs after end. KeyError: If the time zone string passed is not a valid time zone string. RuntimeError: If getting the tasks is unsuccessful. !!! example \"Getting Completed Tasks\" === \"Completed Tasks In A Single Day\" Getting the tasks for a full, complete day requires passing in the datetime object corresponding to the day that you want. ```python # Get the tasks for 1/11/2021 tasks = client.task.get_completed(datetime(2021, 1, 11)) ``` ??? success \"Result\" The list of completed tasks is returned. ```python [{'id': '5ffca35f4c201114702a0607', 'projectId': '004847faa60015487be444cb', 'sortOrder': -50027779063826, 'title': 'Shoulders and Arms', 'content': '', 'desc': '', 'startDate': '2021-01-11T08:00:00.000+0000', 'dueDate': '2021-01-11T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'repeatFlag': '', 'exDate': [], 'completedTime': '2021-01-11T23:25:46.000+0000', 'completedUserId': 185769383, 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-11T23:25:41.000+0000', 'etag': '6hlk4e8t', 'deleted': 0, 'createdTime': '2021-01-11T19:13:35.000+0000', 'creator': 185769383, 'tags': ['fitness'], 'commentCount': 0, 'pomodoroSummaries': [{'userId': 185769383, 'count': 0, 'estimatedPomo': 0, 'duration': 0}], 'focusSummaries': [{'userId': 185769383, 'pomoCount': 0, 'estimatedPomo': 0, 'estimatedDuration': 0, 'pomoDuration': 0, 'stopwatchDuration': 3720}], 'kind': 'TEXT'}] ``` ![image](https://user-images.githubusercontent.com/56806733/104562952-e1e68580-55fd-11eb-9e09-f432caa8616b.png) === \"Completed Tasks Over A Range Of Days\" Getting the tasks for a range of days requires passing in datetime objects for the start day, and the end day that you want. ```python # Get the tasks between 8/7/18 and 8/10/18 start = datetime(2018, 8, 7) end = datetime(2018, 8, 10) tasks = client.task.get_completed(start, end) ``` ??? success \"Result\" Completed tasks in a list are returned. ```python [{'id': '5ffffebab04b355792c79e38', 'projectId': 'inbox115781412', 'sortOrder': -7696581394432, 'title': 'Ride Bike', 'content': '', 'startDate': '2021-01-14T08:00:00.000+0000', 'dueDate': '2021-01-14T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'completedTime': '2018-08-09T07:20:11.000+0000', 'completedUserId': 185769383, 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T08:21:01.000+0000', 'etag': 'mhjyig4y', 'deleted': 0, 'createdTime': '2021-01-14T08:20:10.000+0000', 'creator': 185769383, 'kind': 'TEXT'}, {'id': '5ffffeaab04b355792c79d89', 'projectId': 'inbox115781412', 'sortOrder': -6597069766656, 'title': 'Read Book', 'content': '', 'startDate': '2021-01-14T08:00:00.000+0000', 'dueDate': '2021-01-14T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'completedTime': '2018-08-08T07:20:12.000+0000', 'completedUserId': 185769383, 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T08:20:46.000+0000', 'etag': 'tzd4coms', 'deleted': 0, 'createdTime': '2021-01-14T08:19:54.000+0000', 'creator': 185769383, 'kind': 'TEXT'}] ``` ![image](https://user-images.githubusercontent.com/56806733/104563478-8c5ea880-55fe-11eb-9bcf-91bc44c02083.png) === \"Completed Tasks Over A Specific Duration Of Time\" You can also get completed tasks that were completed in a specific time duration. Include specific hours, minutes, and seconds for the datetime objects, and specify `full` to be false -> meaning that the specific times will be put into effect. ```python # Get the tasks completed between 12PM and 5PM on 12/15/2020 start = datetime(2020, 12, 15, 12) # 12PM 12/15/2020 end = datetime(2020, 12, 15, 17) # 5PM 12/15/2020 tasks = client.task.get_completed(start, end, full=False) ``` \"\"\" url = self . _client . BASE_URL + 'project/all/completed' if tz is None : tz = self . _client . time_zone if not isinstance ( start , datetime . datetime ): raise TypeError ( 'Start Must Be A Datetime Object' ) if not isinstance ( end , datetime . datetime ) and end is not None : raise TypeError ( 'End Must Be A Datetime Object' ) # Handles case when start_date occurs after end_date if end is not None and start > end : raise ValueError ( 'Invalid Date Range: Start Date Occurs After End Date' ) # Handles invalid timezone argument if tz not in pytz . all_timezones_set : raise KeyError ( 'Invalid Time Zone' ) # Single Day Entry if end is None : start = datetime . datetime ( start . year , start . month , start . day , 0 , 0 , 0 ) end = datetime . datetime ( start . year , start . month , start . day , 23 , 59 , 59 ) # Multi DAy -> Full Day Entry elif full is True and end is not None : start = datetime . datetime ( start . year , start . month , start . day , 0 , 0 , 0 ) end = datetime . datetime ( end . year , end . month , end . day , 23 , 59 , 59 ) # Convert Local Time to UTC time based off the time_zone string specified start = convert_local_time_to_utc ( start , tz ) end = convert_local_time_to_utc ( end , tz ) parameters = { 'from' : start . strftime ( DATE_FORMAT ), 'to' : end . strftime ( DATE_FORMAT ), 'limit' : 100 } response = self . _client . http_get ( url , params = parameters , cookies = self . _client . cookies , headers = self . headers ) return response get_from_project ( self , project ) \u00b6 Obtains the tasks that are contained in the project. Parameters: Name Type Description Default project str ID string of the project to get the tasks from. required Returns: Type Description dict or list Single Task In Project (dict) : The single task object dictionary. Multiple Tasks In Project (list) : A list of task object dictionaries. No Tasks Found (list) : Empty list. Exceptions: Type Description ValueError If the project ID does not exist. Getting Uncompleted Tasks From The Inbox tasks = client . task . get_from_project ( client . inbox_id ) Result See Returns for the different return values based on the amount of tasks present in the project. [{ 'id' : '5ffe93efb04b35082bbce7af' , 'projectId' : 'inbox115781412' , 'sortOrder' : 2199023255552 , 'title' : 'Go To Library' , 'content' : '' , 'startDate' : '2021-01-12T08:00:00.000+0000' , 'dueDate' : '2021-01-12T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T06:32:15.000+0000' , 'etag' : 'kkh0w1jk' , 'deleted' : 0 , 'createdTime' : '2021-01-13T06:32:15.000+0000' , 'creator' : 447666584 , 'tags' : [], 'kind' : 'TEXT' }, { 'id' : '5ffe93f3b04b35082bbce7b0' , 'projectId' : 'inbox115781412' , 'sortOrder' : 1099511627776 , 'title' : 'Deposit Funds' , 'content' : '' , 'startDate' : '2021-01-12T08:00:00.000+0000' , 'dueDate' : '2021-01-12T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T06:32:19.000+0000' , 'etag' : 'w4hj21wf' , 'deleted' : 0 , 'createdTime' : '2021-01-13T06:32:19.000+0000' , 'creator' : 447666584 , 'tags' : [], 'kind' : 'TEXT' }] Source code in managers/tasks.py def get_from_project ( self , project : str ): \"\"\" Obtains the tasks that are contained in the project. Arguments: project: ID string of the project to get the tasks from. Returns: dict or list: **Single Task In Project (dict)**: The single task object dictionary. **Multiple Tasks In Project (list)**: A list of task object dictionaries. **No Tasks Found (list)**: Empty list. Raises: ValueError: If the project ID does not exist. !!! example \"Getting Uncompleted Tasks From The Inbox\" ```python tasks = client.task.get_from_project(client.inbox_id) ``` ??? success \"Result\" See `Returns` for the different return values based on the amount of tasks present in the project. ```python [{'id': '5ffe93efb04b35082bbce7af', 'projectId': 'inbox115781412', 'sortOrder': 2199023255552, 'title': 'Go To Library', 'content': '', 'startDate': '2021-01-12T08:00:00.000+0000', 'dueDate': '2021-01-12T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T06:32:15.000+0000', 'etag': 'kkh0w1jk', 'deleted': 0, 'createdTime': '2021-01-13T06:32:15.000+0000', 'creator': 447666584, 'tags': [], 'kind': 'TEXT'}, {'id': '5ffe93f3b04b35082bbce7b0', 'projectId': 'inbox115781412', 'sortOrder': 1099511627776, 'title': 'Deposit Funds', 'content': '', 'startDate': '2021-01-12T08:00:00.000+0000', 'dueDate': '2021-01-12T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T06:32:19.000+0000', 'etag': 'w4hj21wf', 'deleted': 0, 'createdTime': '2021-01-13T06:32:19.000+0000', 'creator': 447666584, 'tags': [], 'kind': 'TEXT'}] ``` ![image](https://user-images.githubusercontent.com/56806733/104415494-f86ddd80-5526-11eb-8b84-75bf3886ba46.png) \"\"\" # Make sure the project exists if project != self . _client . inbox_id : obj = self . _client . get_by_fields ( id = project , search = 'projects' ) if not obj : raise ValueError ( f \"List Id ' { project } ' Does Not Exist\" ) # Get the list of tasks that share the project id tasks = self . _client . get_by_fields ( projectId = project , search = 'tasks' ) if isinstance ( tasks , dict ): return [ tasks ] else : return tasks make_subtask ( self , obj , parent ) \u00b6 Makes the passed task(s) sub-tasks to the parent task. Important All of the tasks should already be created prior to using this method. Furthermore, the tasks should already be present in the same project as the parent task. Parameters: Name Type Description Default obj dict Single Sub-Task (dict) : The task object dictionary. Multiple Sub-Tasks (list) : A list of task object dictionaries. required parent str The ID of the task that will be the parent task. required Returns: Type Description dict Single Sub-Task (dict) : Created sub-task dictionary. Multiple Sub-Tasks (list) : List of created sub-task dictionaries. Exceptions: Type Description TypeError obj must be a dictionary or list of dictionaries. parent must be a string. ValueError If parent task doesn't exist. ValueError If obj does not share the same project as parent. RuntimeError If the creation was unsuccessful. Creating Sub-Tasks Single Sub-Task Creation Pass the task object that will be made a sub-task to the parent with the passed ID. # Lets make a task in our inbox named \"Read\" with a sub-task \"50 Pages\" read_task = client . task . create ( 'Read' ) pages_task = client . task . create ( '50 pages' ) now_subtask = client . task . make_subtask ( pages_task , read_task [ 'id' ]) Result The dictionary of the sub-task is returned. { 'id' : '5ffff4968f08af50b4654c6b' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 3298534883328 , 'title' : '50 pages' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-14T07:37:36.487+0000' , 'etag' : 'xv5cjzoz' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:36:54.751+0000' , 'creator' : 115781412 , 'parentId' : '5ffff4968f08af50b4654c62' , 'kind' : 'TEXT' } Before After Multiple Sub-Task Creation Pass all the tasks you want to make sub-tasks in a list. # Lets make a task in our inbox named \"Read\" with a sub-tasks \"50 Pages\", \"100 Pages\", and \"200 Pages\" read_task = client . task . create ( \"Read\" ) # Lets batch create our sub-tasks fifty_pages = client . task . builder ( '50 Pages' ) hundred_pages = client . task . builder ( '100 Pages' ) two_hundred_pages = client . task . builder ( '200 Pages' ) page_tasks = client . task . create ([ fifty_pages , hundred_pages , two_hundred_pages ]) # Make the page tasks sub-tasks to read_task subtasks = client . task . make_subtask ( page_tasks , read_task [ 'id' ]) Result A list of the sub-tasks is returned. [{ 'id' : '5ffff6348f082c11cc0da84d' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 5497558138880 , 'title' : '50 Pages' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-14T07:45:04.032+0000' , 'etag' : 'avqm3u6o' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:43:48.858+0000' , 'creator' : 567893575 , 'parentId' : '5ffff6348f082c11cc0da84a' , 'kind' : 'TEXT' }, { 'id' : '5ffff6348f082c11cc0da84e' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 5497558138880 , 'title' : '100 Pages' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-14T07:45:04.035+0000' , 'etag' : '6295mmmu' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:43:49.286+0000' , 'creator' : 567893575 , 'parentId' : '5ffff6348f082c11cc0da84a' , 'kind' : 'TEXT' }, { 'id' : '5ffff6348f082c11cc0da84f' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 5497558138880 , 'title' : '200 Pages' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-14T07:45:04.038+0000' , 'etag' : 'du59zwck' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:43:49.315+0000' , 'creator' : 567893575 , 'parentId' : '5ffff6348f082c11cc0da84a' , 'kind' : 'TEXT' }] Before After Source code in managers/tasks.py def make_subtask ( self , obj , parent : str ): \"\"\" Makes the passed task(s) sub-tasks to the parent task. !!! note \"Important\" All of the tasks should already be created prior to using this method. Furthermore, the tasks should already be present in the same project as the parent task. Arguments: obj (dict): **Single Sub-Task (dict)**: The task object dictionary. **Multiple Sub-Tasks (list)**: A list of task object dictionaries. parent (str): The ID of the task that will be the parent task. Returns: dict: **Single Sub-Task (dict)**: Created sub-task dictionary. **Multiple Sub-Tasks (list)**: List of created sub-task dictionaries. Raises: TypeError: `obj` must be a dictionary or list of dictionaries. `parent` must be a string. ValueError: If `parent` task doesn't exist. ValueError: If `obj` does not share the same project as parent. RuntimeError: If the creation was unsuccessful. !!! example \"Creating Sub-Tasks\" === \"Single Sub-Task Creation\" Pass the task object that will be made a sub-task to the parent with the passed ID. ```python # Lets make a task in our inbox named \"Read\" with a sub-task \"50 Pages\" read_task = client.task.create('Read') pages_task = client.task.create('50 pages') now_subtask = client.task.make_subtask(pages_task, read_task['id']) ``` ??? success \"Result\" The dictionary of the sub-task is returned. ```python {'id': '5ffff4968f08af50b4654c6b', 'projectId': 'inbox115781412', 'sortOrder': -3298534883328, 'title': '50 pages', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-14T07:37:36.487+0000', 'etag': 'xv5cjzoz', 'deleted': 0, 'createdTime': '2021-01-14T07:36:54.751+0000', 'creator': 115781412, 'parentId': '5ffff4968f08af50b4654c62', 'kind': 'TEXT'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104558809-4272c400-55f8-11eb-8c55-e2f77c9d1ac8.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104558849-55859400-55f8-11eb-9692-c3e01aa73233.png) === \"Multiple Sub-Task Creation\" Pass all the tasks you want to make sub-tasks in a list. ```python # Lets make a task in our inbox named \"Read\" with a sub-tasks \"50 Pages\", \"100 Pages\", and \"200 Pages\" read_task = client.task.create(\"Read\") # Lets batch create our sub-tasks fifty_pages = client.task.builder('50 Pages') hundred_pages = client.task.builder('100 Pages') two_hundred_pages = client.task.builder('200 Pages') page_tasks = client.task.create([fifty_pages, hundred_pages, two_hundred_pages]) # Make the page tasks sub-tasks to read_task subtasks = client.task.make_subtask(page_tasks, read_task['id']) ``` ??? success \"Result\" A list of the sub-tasks is returned. ```python [{'id': '5ffff6348f082c11cc0da84d', 'projectId': 'inbox115781412', 'sortOrder': -5497558138880, 'title': '50 Pages', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-14T07:45:04.032+0000', 'etag': 'avqm3u6o', 'deleted': 0, 'createdTime': '2021-01-14T07:43:48.858+0000', 'creator': 567893575, 'parentId': '5ffff6348f082c11cc0da84a', 'kind': 'TEXT'}, {'id': '5ffff6348f082c11cc0da84e', 'projectId': 'inbox115781412', 'sortOrder': -5497558138880, 'title': '100 Pages', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-14T07:45:04.035+0000', 'etag': '6295mmmu', 'deleted': 0, 'createdTime': '2021-01-14T07:43:49.286+0000', 'creator': 567893575, 'parentId': '5ffff6348f082c11cc0da84a', 'kind': 'TEXT'}, {'id': '5ffff6348f082c11cc0da84f', 'projectId': 'inbox115781412', 'sortOrder': -5497558138880, 'title': '200 Pages', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-14T07:45:04.038+0000', 'etag': 'du59zwck', 'deleted': 0, 'createdTime': '2021-01-14T07:43:49.315+0000', 'creator': 567893575, 'parentId': '5ffff6348f082c11cc0da84a', 'kind': 'TEXT'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104559418-36d3cd00-55f9-11eb-9004-177671a92474.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104559535-64207b00-55f9-11eb-84cf-ca4f989ea075.png) \"\"\" if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( 'obj must be a dictionary or list of dictionaries' ) if not isinstance ( parent , str ): raise TypeError ( 'parent must be a string' ) if isinstance ( obj , dict ): obj = [ obj ] parent_obj = self . _client . get_by_id ( search = 'tasks' , obj_id = parent ) if not parent_obj : raise ValueError ( \"Parent task must exist before creating sub-tasks\" ) ids = [] # Go through obj and if the projects are different make them the same as parent for o in obj : if o [ 'projectId' ] != parent_obj [ 'projectId' ]: raise ValueError ( \"All tasks must be in the same project as the parent\" ) ids . append ( o [ 'id' ]) subtasks = [] for i in ids : # Create the object dictionaries for setting the subtask temp = { 'parentId' : parent , 'projectId' : parent_obj [ 'projectId' ], 'taskId' : i } subtasks . append ( temp ) url = self . _client . BASE_URL + 'batch/taskParent' response = self . _client . http_post ( url , json = subtasks , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () # Find and return the updated child objects subtasks = [] for task_id in ids : subtasks . append ( self . _client . get_by_id ( task_id , search = 'tasks' )) if len ( subtasks ) == 1 : return subtasks [ 0 ] # Return just the dictionary object if its a single task else : return subtasks move ( self , obj , new ) \u00b6 Moves task(s) from their current project to the new project. It will move the specified tasks with obj to the new project. Important If moving multiple tasks, they must all be from the same project. Parameters: Name Type Description Default obj dict or list Single Task (dict) : Pass the single task dictionary object to move. Multiple Tasks (list) : Pass a list of task dictionary objects to move. required new str The ID string of the project that the task(s) should be moved to. required Returns: Type Description dict or list Single Task (dict) : Returns the dictionary of the moved task. Multiple Tasks (list) : Returns a list of dictionaries for the moved tasks. Exceptions: Type Description TypeError If obj is not a dict or list or if new is not a str. ValueError For multiple tasks, if the projects are not all the same. ValueError If the new project does not exist. RuntimeError If the task(s) could not be successfully moved. Move Examples Moving A Single Task Pass in the task object, and the ID of the project the task should be moved to. # Lets assume that we have a task 'Read' that exists in a project named \"Work\" # Lets move that task to the inbox read_task = client . get_by_fields ( title = 'Read' , search = 'tasks' ) move_read_task = client . task . move ( read_task , client . inbox_id ) Result The dictionary object of the moved task is returned. { 'id' : '5fffed61b04b355792c799a8' , 'projectId' : 'inbox115781412' , 'sortOrder' : 0 , 'title' : 'Read' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T07:08:15.875+0000' , 'etag' : 'twrmcr55' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:06:09.000+0000' , 'creator' : 47593756 , 'tags' : [], 'kind' : 'TEXT' } Before After Moving Multiple Tasks Pass in the task objects in a list, and the ID of the project that tasks should be moved to. Again, the tasks in the list should all be from the same project. # Lets move two tasks: 'Read' and 'Write' that exist in a project named \"Work\" # Lets move the tasks to another project named \"Hobbies\" that already exists. hobbies_project = client . get_by_fields ( name = 'Hobbies' , search = 'projects' ) hobbies_id = hobbies_project [ 'id' ] # Id of the hobbies project read_task = client . get_by_fields ( title = 'Read' , search = 'tasks' ) write_task = client . get_by_fields ( title = 'Write' , search = 'tasks' ) move_tasks = client . task . move ([ read_task , write_task ], hobbies_id ) # Task objects in a list Result The tasks that were moved are returned in a list. [{ 'id' : '5ffff003b04b355792c799d3' , 'projectId' : '5fffeff68f08654c982c141a' , 'sortOrder' : 0 , 'title' : 'Read' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T07:19:28.595+0000' , 'etag' : 'co8jfqyn' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:17:23.000+0000' , 'creator' : 768495743 , 'kind' : 'TEXT' }, { 'id' : '5ffff004b04b355792c799d4' , 'projectId' : '5fffeff68f08654c982c141a' , 'sortOrder' : 0 , 'title' : 'Write' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T07:19:28.596+0000' , 'etag' : '5unkf7xg' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:17:24.000+0000' , 'creator' : 768495743 , 'tags' : [], 'kind' : 'TEXT' }] Before After Source code in managers/tasks.py def move ( self , obj , new : str ): \"\"\" Moves task(s) from their current project to the new project. It will move the specified tasks with `obj` to the new project. !!! important If moving multiple tasks, they must all be from the same project. Arguments: obj (dict or list): **Single Task (dict)**: Pass the single task dictionary object to move. **Multiple Tasks (list)**: Pass a list of task dictionary objects to move. new: The ID string of the project that the task(s) should be moved to. Returns: dict or list: **Single Task (dict)**: Returns the dictionary of the moved task. **Multiple Tasks (list)**: Returns a list of dictionaries for the moved tasks. Raises: TypeError: If `obj` is not a dict or list or if `new` is not a str. ValueError: For multiple tasks, if the projects are not all the same. ValueError: If the new project does not exist. RuntimeError: If the task(s) could not be successfully moved. !!! example \"Move Examples\" === \"Moving A Single Task\" Pass in the task object, and the ID of the project the task should be moved to. ```python # Lets assume that we have a task 'Read' that exists in a project named \"Work\" # Lets move that task to the inbox read_task = client.get_by_fields(title='Read', search='tasks') move_read_task = client.task.move(read_task, client.inbox_id) ``` ??? success \"Result\" The dictionary object of the moved task is returned. ```python {'id': '5fffed61b04b355792c799a8', 'projectId': 'inbox115781412', 'sortOrder': 0, 'title': 'Read', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T07:08:15.875+0000', 'etag': 'twrmcr55', 'deleted': 0, 'createdTime': '2021-01-14T07:06:09.000+0000', 'creator': 47593756, 'tags': [], 'kind': 'TEXT'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104556170-f1f96780-55f3-11eb-9a35-aecc3beea105.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104556336-46044c00-55f4-11eb-98c1-4cffcf4bd006.png) === \"Moving Multiple Tasks\" Pass in the task objects in a list, and the ID of the project that tasks should be moved to. Again, the tasks in the list should all be from the same project. ```python # Lets move two tasks: 'Read' and 'Write' that exist in a project named \"Work\" # Lets move the tasks to another project named \"Hobbies\" that already exists. hobbies_project = client.get_by_fields(name='Hobbies', search='projects') hobbies_id = hobbies_project['id'] # Id of the hobbies project read_task = client.get_by_fields(title='Read', search='tasks') write_task = client.get_by_fields(title='Write', search='tasks') move_tasks = client.task.move([read_task, write_task], hobbies_id) # Task objects in a list ``` ??? success \"Result\" The tasks that were moved are returned in a list. ```python [{'id': '5ffff003b04b355792c799d3', 'projectId': '5fffeff68f08654c982c141a', 'sortOrder': 0, 'title': 'Read', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T07:19:28.595+0000', 'etag': 'co8jfqyn', 'deleted': 0, 'createdTime': '2021-01-14T07:17:23.000+0000', 'creator': 768495743, 'kind': 'TEXT'}, {'id': '5ffff004b04b355792c799d4', 'projectId': '5fffeff68f08654c982c141a', 'sortOrder': 0, 'title': 'Write', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T07:19:28.596+0000', 'etag': '5unkf7xg', 'deleted': 0, 'createdTime': '2021-01-14T07:17:24.000+0000', 'creator': 768495743, 'tags': [], 'kind': 'TEXT'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104557103-857f6800-55f5-11eb-8b92-cf51bc159745.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104557388-063e6400-55f6-11eb-8ba4-aa64f3f739bd.png) \"\"\" # Type errors if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( 'obj should be a dict or list of dicts' ) if not isinstance ( new , str ): raise TypeError ( 'new should be a string' ) # Get the parent project if new != self . _client . inbox_id : project = self . _client . get_by_id ( new , search = 'projects' ) if not project : raise ValueError ( 'The ID for the new project does not exist' ) if isinstance ( obj , dict ): obj = [ obj ] # Go through and check that the projects are all the same move_tasks = [] project_id = obj [ 0 ][ 'projectId' ] for task in obj : if task [ 'projectId' ] != project_id : raise ValueError ( 'All the tasks must come from the same project' ) else : move_tasks . append ({ 'fromProjectId' : project_id , 'taskId' : task [ 'id' ], 'toProjectId' : new }) url = self . _client . BASE_URL + 'batch/taskProject' self . _client . http_post ( url , json = move_tasks , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () # Return the tasks in the new list ids = [ x [ 'id' ] for x in obj ] return_list = [] for i in ids : return_list . append ( self . _client . get_by_id ( i )) if len ( return_list ) == 1 : return return_list [ 0 ] else : return return_list move_all ( self , old , new ) \u00b6 Moves all the tasks from the old project to the new project. Parameters: Name Type Description Default old str ID of the old project. required new str ID of the new project. required Returns: Type Description list The tasks contained in the new project. Exceptions: Type Description ValueError If either the old or new projects do not exist. RuntimeError If the movement was unsuccessful. Example Lets assume that we have a project named \"School\", and another project named \"Work\". To move all the tasks from \"School\" to \"Work\": # Get the projects school_project = client . get_by_fields ( name = 'School' , search = 'projects' ) work_project = client . get_by_fields ( name = 'Work' , search = 'projects' ) # Call the method moved_tasks = client . task . move_all ( school_project [ 'id' ], work_project [ 'id' ]) Result The tasks that were moved are returned. [{ 'id' : '5ffea9afe4b062d60dd62aef' , 'projectId' : '5ffea9afe4b062d60dd62aea' , 'sortOrder' : 0 , 'title' : 'Finish documentation for project' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-13T08:06:31.407+0000' , 'etag' : 'ogclghmd' , 'deleted' : 0 , 'createdTime' : '2021-01-13T08:05:03.901+0000' , 'creator' : 447666584 , 'kind' : 'TEXT' }, { 'id' : '5ffea9b0e4b062d60dd62af4' , 'projectId' : '5ffea9afe4b062d60dd62aea' , 'sortOrder' : 0 , 'title' : 'Call the boss man' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-13T08:06:31.409+0000' , 'etag' : '65c73q8i' , 'deleted' : 0 , 'createdTime' : '2021-01-13T08:05:04.117+0000' , 'creator' : 447666584 , 'kind' : 'TEXT' }] Before : Two tasks are contained in the \"School\" project After : The two tasks are moved to the 'Work' project Source code in managers/tasks.py def move_all ( self , old : str , new : str ) -> list : \"\"\" Moves all the tasks from the old project to the new project. Arguments: old: ID of the old project. new: ID of the new project. Returns: The tasks contained in the new project. Raises: ValueError: If either the old or new projects do not exist. RuntimeError: If the movement was unsuccessful. !!! example Lets assume that we have a project named \"School\", and another project named \"Work\". To move all the tasks from \"School\" to \"Work\": ```python # Get the projects school_project = client.get_by_fields(name='School', search='projects') work_project = client.get_by_fields(name='Work', search='projects') # Call the method moved_tasks = client.task.move_all(school_project['id'], work_project['id']) ``` ??? success \"Result\" The tasks that were moved are returned. ```python [{'id': '5ffea9afe4b062d60dd62aef', 'projectId': '5ffea9afe4b062d60dd62aea', 'sortOrder': 0, 'title': 'Finish documentation for project', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-13T08:06:31.407+0000', 'etag': 'ogclghmd', 'deleted': 0, 'createdTime': '2021-01-13T08:05:03.901+0000', 'creator': 447666584, 'kind': 'TEXT'}, {'id': '5ffea9b0e4b062d60dd62af4', 'projectId': '5ffea9afe4b062d60dd62aea', 'sortOrder': 0, 'title': 'Call the boss man', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-13T08:06:31.409+0000', 'etag': '65c73q8i', 'deleted': 0, 'createdTime': '2021-01-13T08:05:04.117+0000', 'creator': 447666584, 'kind': 'TEXT'}] ``` **Before**: Two tasks are contained in the \"School\" project ![image](https://user-images.githubusercontent.com/56806733/104423574-1e997a80-5533-11eb-9417-34c31e603d21.png) **After**: The two tasks are moved to the 'Work' project ![image](https://user-images.githubusercontent.com/56806733/104423710-4a1c6500-5533-11eb-90f3-2c3d024280af.png) \"\"\" # Make sure that old and new id's exist if old != self . _client . inbox_id : old_list = self . _client . get_by_fields ( id = old , search = 'projects' ) if not old_list : raise ValueError ( f \"Project Id ' { old } ' Does Not Exist\" ) if new != self . _client . inbox_id : new_list = self . _client . get_by_fields ( id = new , search = 'projects' ) if not new_list : raise ValueError ( f \"Project Id ' { new } ' Does Not Exist\" ) # Get the tasks from the old list tasks = self . get_from_project ( old ) if not tasks : return tasks # No tasks to move so just return the empty list task_project = [] # List containing all the tasks that will be updated for task in tasks : task_project . append ({ 'fromProjectId' : old , 'taskId' : task [ 'id' ], 'toProjectId' : new }) url = self . _client . BASE_URL + 'batch/taskProject' # Make the initial call to move the tasks self . _client . http_post ( url , json = task_project , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () # Return the tasks in the new list return self . _client . task . get_from_project ( new ) update ( self , task ) \u00b6 Update a task. The task should already be created. To update a task, change any field in it's dictionary directly then pass to the method. Warning Creating tasks with tags is not functional but will be implemented in a future update. Parameters: Name Type Description Default task dict Task dictionary to be updated required Returns: Type Description dict The updated task dictionary object Formatting Dates Help TickTick uses a certain syntax for their dates. To convert a datetime object to a compatible string to be used for updating dates, see convert_date_to_tick_tick_format Changing The Date # Get the task mollys_birthday = client . get_by_fields ( title = \"Molly's Birthday\" , search = \"tasks\" ) # New Date new_date = datetime ( 2027 , 5 , 6 ) # Get the new date string new_date_string = convert_date_to_tick_tick_format ( new_date , tz = client . time_zone ) # Update the task dictionary mollys_birthday [ 'startDate' ] = new_date_string # Update the task molly_updated = client . task . update ( mollys_birthday ) Original Task Result { 'id' : '60caa2278f08fe3101187002' , 'projectId' : '60caa20d8f08fe3101186f74' , 'title' : \"Molly's Birthday\" , 'content' : '' , 'timeZone' : '' , 'startDate' : '2027-05-06T07:00:00.000+0000' , 'dueDate' : '2027-05-05T07:00:00.000+0000' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'sortOrder' : - 1099511627776 , 'items' : [], 'allDay' : True } Source code in managers/tasks.py def update ( self , task ): \"\"\" Update a task. The task should already be created. To update a task, change any field in it's dictionary directly then pass to the method. !!! warning Creating tasks with tags is not functional but will be implemented in a future update. Arguments: task (dict): Task dictionary to be updated Returns: dict: The updated task dictionary object !!! tip \"Formatting Dates Help\" TickTick uses a certain syntax for their dates. To convert a datetime object to a compatible string to be used for updating dates, see [convert_date_to_tick_tick_format][helpers.time_methods.convert_date_to_tick_tick_format] !!! example \"Changing The Date\" ```python # Get the task mollys_birthday = client.get_by_fields(title=\"Molly's Birthday\", search=\"tasks\") # New Date new_date = datetime(2027, 5, 6) # Get the new date string new_date_string = convert_date_to_tick_tick_format(new_date, tz=client.time_zone) # Update the task dictionary mollys_birthday['startDate'] = new_date_string # Update the task molly_updated = client.task.update(mollys_birthday) ``` **Original Task** ![image](https://user-images.githubusercontent.com/56806733/122316205-49b43b80-ced0-11eb-8d14-61fa5bb5b10a.png) ??? success \"Result\" ```python {'id': '60caa2278f08fe3101187002', 'projectId': '60caa20d8f08fe3101186f74', 'title': \"Molly's Birthday\", 'content': '', 'timeZone': '', 'startDate': '2027-05-06T07:00:00.000+0000', 'dueDate': '2027-05-05T07:00:00.000+0000', 'reminders': [], 'priority': 0, 'status': 0, 'sortOrder': -1099511627776, 'items': [], 'allDay': True} ``` ![image](https://user-images.githubusercontent.com/56806733/122316408-ad3e6900-ced0-11eb-89f9-6d980b5cc954.png) \"\"\" # TODO: Make tags work # generate url url = self . _generate_update_url ( task [ 'id' ]) # make request response = self . _client . http_post ( url = url , json = task , headers = self . oauth_headers ) # sync local state self . _client . sync () # return response return response","title":"Tasks"},{"location":"usage/tasks/#example-ticktick-task-dictionary","text":"Members { \"id\" : \"String\" , \"projectId\" : \"String\" , \"title\" : \"Task Title\" , \"content\" : \"Task Content\" , \"desc\" : \"Task Description\" , \"allDay\" : True , \"startDate\" : \"2019-11-13T03:00:00+0000\" , \"dueDate\" : \"2019-11-14T03:00:00+0000\" , \"timeZone\" : \"America/Los_Angeles\" , \"reminders\" : [ \"TRIGGER:P0DT9H0M0S\" , \"TRIGGER:PT0S\" ], \"repeat\" : \"RRULE:FREQ=DAILY;INTERVAL=1\" , \"priority\" : 1 , \"status\" : 0 , \"completedTime\" : \"2019-11-13T03:00:00+0000\" , \"sortOrder\" : 12345 , \"items\" : [{ \"id\" : \"String\" , \"status\" : 1 , \"title\" : \"Subtask Title\" , \"sortOrder\" : 12345 , \"startDate\" : \"2019-11-13T03:00:00+0000\" , \"isAllDay\" : False , \"timeZone\" : \"America/Los_Angeles\" , \"completedTime\" : \"2019-11-13T03:00:00+0000\" }","title":"Example TickTick Task Dictionary"},{"location":"usage/tasks/#subtask-items","text":"Name Description Schema id Subtask identifier string title Subtask title string status The completion status of subtask Value : Normal: 0, Completed: 1 integer (int32) completedTime Subtask completed time in \"yyyy-MM-dd'T'HH:mm:ssZ\" Example : \"2019-11-13T03:00:00+0000\" string (date-time) isAllDay All day boolean sortOrder Subtask sort order Example : 234444 integer (int64) startDate Subtask start date time in \"yyyy-MM-dd'T'HH:mm:ssZ\" Example : \"2019-11-13T03:00:00+0000\" string (date-time) timeZone Subtask timezone Example : \"America/Los_Angeles\" string","title":"Subtask Items"},{"location":"usage/tasks/#task-items","text":"Name Description Schema id Task identifier string projectId Task project id string title Task title string allDay All day boolean completedTime Task completed time in \"yyyy-MM-dd'T'HH:mm:ssZ\" Example : \"2019-11-13T03:00:00+0000\" string (date-time) content Task content string desc Task description of checklist string dueDate Task due date time in \"yyyy-MM-dd'T'HH:mm:ssZ\" Example : \"2019-11-13T03:00:00+0000\" string (date-time) items Subtasks of Task < ChecklistItem > array priority Task priority Value : None:0, Low:1, Medium:3, High5 integer (int32) reminders List of reminder triggers Example : [ \"TRIGGER:P0DT9H0M0S\", \"TRIGGER:PT0S\" ] < string > array repeat Recurring rules of task Example : \"RRULE:FREQ=DAILY;INTERVAL=1\" string sortOrder Task sort order Example : 12345 integer (int64) startDate Start date time in \"yyyy-MM-dd'T'HH:mm:ssZ\" Example : \"2019-11-13T03:00:00+0000\" string (date-time) status Task completion status Value : Normal: 0, Completed: 1 integer (int32) timeZone Task timezone Example : \"America/Los_Angeles\" string","title":"Task Items"},{"location":"usage/tasks/#managers.tasks.TaskManager","text":"Handles all interactions for tasks.","title":"TaskManager"},{"location":"usage/tasks/#managers.tasks.TaskManager.builder","text":"Builds a task dictionary with the passed fields. This is a helper method for task creation. Parameters: Name Type Description Default title str Desired name of the task '' projectId str ID string of the project None content str Content body of the task None desc str Description of the task checklist None allDay bool Boolean for whether the task is all day or not None startDate datetime.datetime Start time of the task None dueDate datetime.datetime End time of the task None timeZone str Time zone for the task None reminders list List of reminder triggers None repeat str Recurring rules for the task None priority int None:0, Low:1, Medium:3, High5 None sortOrder int Task sort order None items list Subtasks of task None Returns: Type Description dict A dictionary containing the fields necessary for task creation. Example Building a local task object with a title, start, and due time. start = datetime ( 2027 , 5 , 2 ) end = datetime ( 2027 , 5 , 7 ) title = 'Festival' task_dict = client . task . builder ( title , startDate = start , dueDate = end ) Result { 'startDate' : '2027-05-02T07:00:00+0000' , 'dueDate' : '2027-05-08T07:00:00+0000' , 'allDay' : True , 'title' : 'Festival' } Source code in managers/tasks.py def builder ( self , title : str = '' , projectId : str = None , content : str = None , desc : str = None , allDay : bool = None , startDate : datetime . datetime = None , dueDate : datetime . datetime = None , timeZone : str = None , reminders : list = None , repeat : str = None , priority : int = None , sortOrder : int = None , items : list = None ): \"\"\" Builds a task dictionary with the passed fields. This is a helper method for task creation. Arguments: title (str): Desired name of the task projectId (str): ID string of the project content (str): Content body of the task desc (str): Description of the task checklist allDay (bool): Boolean for whether the task is all day or not startDate (datetime.datetime): Start time of the task dueDate (datetime.datetime): End time of the task timeZone (str): Time zone for the task reminders (list): List of reminder triggers repeat (str): Recurring rules for the task priority (int): None:0, Low:1, Medium:3, High5 sortOrder (int): Task sort order items (list): Subtasks of task Returns: dict: A dictionary containing the fields necessary for task creation. !!! example Building a local task object with a title, start, and due time. ```python start = datetime(2027, 5, 2) end = datetime(2027, 5, 7) title = 'Festival' task_dict = client.task.builder(title, startDate=start, dueDate=end) ``` ??? Result ```python {'startDate': '2027-05-02T07:00:00+0000', 'dueDate': '2027-05-08T07:00:00+0000', 'allDay': True, 'title': 'Festival'} ``` \"\"\" task = { 'title' : title } if projectId is not None : task [ 'projectId' ] = projectId if content is not None : task [ 'content' ] = content if desc is not None : task [ 'desc' ] = desc if allDay is not None : task [ 'allDay' ] = allDay if reminders is not None : task [ 'reminders' ] = reminders if repeat is not None : task [ 'repeat' ] = repeat if priority is not None : task [ 'priority' ] = priority if sortOrder is not None : task [ 'sortOrder' ] = sortOrder if items is not None : task [ 'items' ] = items dates = {} # date conversions if startDate is not None : dates = self . dates ( startDate , dueDate , timeZone ) # merge dicts return { ** dates , ** task }","title":"builder()"},{"location":"usage/tasks/#managers.tasks.TaskManager.complete","text":"Marks a task as complete. Pass in the task dictionary to be marked as completed. Note The task should already be created Parameters: Name Type Description Default task dict The task dictionary object. required Returns: Type Description dict The original passed in task. Task Completing # Lets assume that we have a task named \"Dentist\" that we want to mark as complete. dentist_task = client . get_by_fields ( title = 'Dentist' , search = 'tasks' ) complete_task = client . task . complete ( dentist_task ) # Pass the task dictionary Result The task is completed and the dictionary object returned. { 'id' : '5fff5009b04b355792c79397' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 99230924406784 , 'title' : 'Go To Dentist' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T19:56:11.000+0000' , 'etag' : 'djiiqso6' , 'deleted' : 0 , 'createdTime' : '2021-01-13T19:54:49.000+0000' , 'creator' : 6147345572 , 'kind' : 'TEXT' } Before After Source code in managers/tasks.py def complete ( self , task : dict ): \"\"\" Marks a task as complete. Pass in the task dictionary to be marked as completed. !!! note The task should already be created Arguments: task (dict): The task dictionary object. Returns: dict: The original passed in task. !!! example \"Task Completing\" ```python # Lets assume that we have a task named \"Dentist\" that we want to mark as complete. dentist_task = client.get_by_fields(title='Dentist', search='tasks') complete_task = client.task.complete(dentist_task) # Pass the task dictionary ``` ??? success \"Result\" The task is completed and the dictionary object returned. ```python {'id': '5fff5009b04b355792c79397', 'projectId': 'inbox115781412', 'sortOrder': -99230924406784, 'title': 'Go To Dentist', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T19:56:11.000+0000', 'etag': 'djiiqso6', 'deleted': 0, 'createdTime': '2021-01-13T19:54:49.000+0000', 'creator': 6147345572, 'kind': 'TEXT'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104503673-39510b00-5596-11eb-88df-88eeee9ab4b0.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104504069-c4ca9c00-5596-11eb-96c9-5698e19989ea.png) \"\"\" # generate url url = self . _generate_mark_complete_url ( task [ 'projectId' ], task [ 'id' ]) # make request response = self . _client . http_post ( url = url , json = task , headers = self . oauth_headers ) # sync local state self . _client . sync () if response == '' : return task # return response return response","title":"complete()"},{"location":"usage/tasks/#managers.tasks.TaskManager.create","text":"Create a task. Use builder for easy task dictionary creation. Warning Creating tasks with tags is not functional but will be implemented in a future update. Parameters: Name Type Description Default task dict Task dictionary to be created. required Returns: Type Description dict Dictionary of created task object. Note that the task object is a \"simplified\" version of the full task object. Use get_by_id for the full task object. Creating Tasks Just A Name title = \"Molly's Birthday\" task = client . task . builder ( title ) # Local dictionary molly = client . task . create ( task ) # Create task remotely Result { 'id' : '60ca9dbc8f08516d9dd56324' , 'projectId' : 'inbox115781412' , 'title' : \"Molly's Birthday\" , 'timeZone' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'sortOrder' : - 1336456383561728 , 'items' : []} Dates and Descriptions title = \"Molly's Birthday Party\" start_time = datetime ( 2027 , 7 , 5 , 14 , 30 ) # 7/5/2027 @ 2:30PM end_time = datetime ( 2027 , 7 , 5 , 19 , 30 ) # 7/5/2027 @ 7:30PM content = \"Bring Cake\" task = client . task . builder ( title , startDate = start_time , dueDate = end_time , content = content ) mollys_party = client . task . create ( task ) Result { 'id' : '60ca9fe58f08fe31011862f2' , 'projectId' : 'inbox115781412' , 'title' : \"Molly's Birthday Party\" , 'content' : 'Bring Cake' , 'timeZone' : '' , 'startDate' : '2027-07-05T21:30:00.000+0000' , 'dueDate' : '2027-07-06T02:30:00.000+0000' , 'priority' : 0 , 'status' : 0 , 'sortOrder' : - 1337555895189504 , 'items' : [], 'allDay' : False } Different Project # Get the project object events = client . get_by_fields ( name = \"Events\" , search = 'projects' ) events_id = events [ 'id' ] # Need the project object id title = \"Molly's Birthday\" task = client . task . builder ( title , projectId = events_id ) mollys_birthday = client . task . create ( task ) Result { 'id' : '60caa2278f08fe3101187002' , 'projectId' : '60caa20d8f08fe3101186f74' , 'title' : \"Molly's Birthday\" , 'timeZone' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'sortOrder' : - 1099511627776 , 'items' : []} Source code in managers/tasks.py def create ( self , task ): \"\"\" Create a task. Use [`builder`][managers.tasks.TaskManager.builder] for easy task dictionary creation. !!! warning Creating tasks with tags is not functional but will be implemented in a future update. Arguments: task (dict): Task dictionary to be created. Returns: dict: Dictionary of created task object. Note that the task object is a \"simplified\" version of the full task object. Use [`get_by_id`][api.TickTickClient.get_by_id] for the full task object. !!! example \"Creating Tasks\" === \"Just A Name\" ```python title = \"Molly's Birthday\" task = client.task.builder(title) # Local dictionary molly = client.task.create(task) # Create task remotely ``` ??? success \"Result\" ```python {'id': '60ca9dbc8f08516d9dd56324', 'projectId': 'inbox115781412', 'title': \"Molly's Birthday\", 'timeZone': '', 'reminders': [], 'priority': 0, 'status': 0, 'sortOrder': -1336456383561728, 'items': []} ``` ![image](https://user-images.githubusercontent.com/56806733/122314079-5898ef00-cecc-11eb-8614-72b070b306c6.png) === \"Dates and Descriptions\" ```python title = \"Molly's Birthday Party\" start_time = datetime(2027, 7, 5, 14, 30) # 7/5/2027 @ 2:30PM end_time = datetime(2027, 7, 5, 19, 30) # 7/5/2027 @ 7:30PM content = \"Bring Cake\" task = client.task.builder(title, startDate=start_time, dueDate=end_time, content=content) mollys_party = client.task.create(task) ``` ??? success \"Result\" ```python {'id': '60ca9fe58f08fe31011862f2', 'projectId': 'inbox115781412', 'title': \"Molly's Birthday Party\", 'content': 'Bring Cake', 'timeZone': '', 'startDate': '2027-07-05T21:30:00.000+0000', 'dueDate': '2027-07-06T02:30:00.000+0000', 'priority': 0, 'status': 0, 'sortOrder': -1337555895189504, 'items': [], 'allDay': False} ``` ![image](https://user-images.githubusercontent.com/56806733/122314760-a4986380-cecd-11eb-88af-9562d352470f.png) === \"Different Project\" ```python # Get the project object events = client.get_by_fields(name=\"Events\", search='projects') events_id = events['id'] # Need the project object id title = \"Molly's Birthday\" task = client.task.builder(title, projectId=events_id) mollys_birthday = client.task.create(task) ``` ??? success \"Result\" ```python {'id': '60caa2278f08fe3101187002', 'projectId': '60caa20d8f08fe3101186f74', 'title': \"Molly's Birthday\", 'timeZone': '', 'reminders': [], 'priority': 0, 'status': 0, 'sortOrder': -1099511627776, 'items': []} ``` ![image](https://user-images.githubusercontent.com/56806733/122315454-eece1480-cece-11eb-8394-94a2aec1ba70.png) \"\"\" # generate url url = self . _generate_create_url () # make request response = self . _client . http_post ( url = url , json = task , headers = self . oauth_headers ) # sync local state self . _client . sync () # TODO: Figure out tags # since the openapi does not explicitly support tag creation - lets create a new tag for the new task # try: # tags = task['tag'] # if isinstance(tags, str): # # single tag -> check to see if it exists before creating another one # search = self._client.get_by_fields(name=tags, search='tags') # elif: # isinstance(tags, list) # # multiple tags # pass # except KeyError: # pass # set 'inbox' to be the actual inbox id if response [ 'projectId' ] == 'inbox' : response [ 'projectId' ] = self . _client . inbox_id # return response return response","title":"create()"},{"location":"usage/tasks/#managers.tasks.TaskManager.dates","text":"Performs necessary date conversions from datetime objects to strings. This method allows for more natural input of data to the builder method. Parameters: Name Type Description Default start datetime Desired start time required due datetime Desired end time None tz str Time zone string if the desired time zone is not the account default. None Returns: Type Description dict Contains 'startDate', 'endDate', 'timeZone', and 'allDay' when applicable. All Day Start Time (single day task) All Day Start and End Time (multi-day range) Specific Start Time (specific time task) Specific Start and End Time (specific start and end task) Last Day Of The Month start = datetime ( 2027 , 3 , 27 ) end = datetime ( 2027 , 3 , 31 ) dates = client . task . dates ( start , end ) Result {'startDate': '2027-03-27T07:00:00+0000', 'dueDate': '2027-04-01T07:00:00+0000', 'allDay': True} Source code in managers/tasks.py def dates ( self , start , due = None , tz = None ): \"\"\" Performs necessary date conversions from datetime objects to strings. This method allows for more natural input of data to the [`builder`][managers.tasks.TaskManager.builder] method. Arguments: start (datetime): Desired start time due (datetime): Desired end time tz (str): Time zone string if the desired time zone is not the account default. Returns: dict: Contains 'startDate', 'endDate', 'timeZone', and 'allDay' when applicable. 1. All Day Start Time (single day task) 2. All Day Start and End Time (multi-day range) 3. Specific Start Time (specific time task) 4. Specific Start and End Time (specific start and end task) !!! example \"Last Day Of The Month\" ```python start = datetime(2027, 3, 27) end = datetime(2027, 3, 31) dates = client.task.dates(start, end) ``` ??? success \"Result\" ``` {'startDate': '2027-03-27T07:00:00+0000', 'dueDate': '2027-04-01T07:00:00+0000', 'allDay': True} ``` \"\"\" dates = {} # Set time zone if tz is not None : dates [ 'timeZone' ] = tz else : tz = self . _client . time_zone # Check if just start date if due is None : if start . hour != 0 or start . minute != 0 or start . second != 0 or start . microsecond != 0 : dates [ 'startDate' ] = convert_date_to_tick_tick_format ( start , tz ) dates [ 'allDay' ] = False else : dates [ 'startDate' ] = convert_date_to_tick_tick_format ( start , tz ) dates [ 'allDay' ] = True return dates # Check all day for both if ( start . hour != 0 or start . minute != 0 or start . second != 0 or start . microsecond != 0 or due . hour != 0 or due . minute != 0 or due . second != 0 or due . microsecond != 0 ): # Just convert the dates and return dates [ 'startDate' ] = convert_date_to_tick_tick_format ( start , tz ) dates [ 'dueDate' ] = convert_date_to_tick_tick_format ( due , tz ) dates [ 'allDay' ] = False return dates # All day is true, however normally right now if we were to use a date like Jan 1 - Jan 3, # TickTick would create a task that is only Jan 1 - Jan 2 since the date would be up to Jan 3 # Lets account for that by making the date actually be one more than the current end date # This will allow for more natural date input for all day tasks days = monthrange ( due . year , due . month ) if due . day + 1 > days [ 1 ]: # Last day of the month if due . month + 1 > 12 : # Last month of the year year = due . year + 1 # Both last day of month and last day of year day = 1 month = 1 else : # Not last month of year, just reset the day and increment the month year = due . year month = due . month + 1 day = 1 else : # Dont have to worry about incrementing year or month year = due . year day = due . day + 1 month = due . month due = datetime . datetime ( year , month , day ) # No hours, mins, or seconds needed dates [ 'startDate' ] = convert_date_to_tick_tick_format ( start , tz ) dates [ 'dueDate' ] = convert_date_to_tick_tick_format ( due , tz ) dates [ 'allDay' ] = True return dates","title":"dates()"},{"location":"usage/tasks/#managers.tasks.TaskManager.delete","text":"Deletes a task. Supports single task deletion, and batch task deletion. For a single task pass in the task dictionary. For multiple tasks pass in a list of task dictionaries. Parameters: Name Type Description Default task str or list Single Task (dict) : Task dictionary to be deleted Multiple Tasks (list) : List of task dictionaries to be deleted required Returns: Type Description dict or list Single Task (dict) : Task dictionary that was deleted Multiple Tasks (list) : List of task dictionaries that were deleted Task Deletion Single Task Deletion # Get the task task = client . get_by_fields ( title = \"Molly's Birthday\" , search = \"tasks\" ) # Delete the task deleted = client . task . delete ( task ) Result { 'id' : '60caa2278f08fe3101187002' , 'projectId' : '60caa20d8f08fe3101186f74' , 'sortOrder' : - 1099511627776 , 'title' : \"Molly's Birthday\" , 'content' : '' , 'startDate' : '2027-05-06T07:00:00.000+0000' , 'dueDate' : '2027-05-06T07:00:00.000+0000' , 'timeZone' : '' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'repeatFirstDate' : '2027-05-05T07:00:00.000+0000' , 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-06-17T01:25:19.000+0000' , 'etag' : 'rrn4paqp' , 'deleted' : 0 , 'createdTime' : '2021-06-17T01:15:19.365+0000' , 'creator' : 119784412 , 'kind' : 'TEXT' } Multiple Task Deletion # Get the tasks wash_car = client . get_by_fields ( title = \"Wash Car\" , search = \"tasks\" ) do_dishes = client . get_by_fields ( title = \"Do Dishes\" , search = \"tasks\" ) # Make a list for the tasks to_delete = [ wash_car , do_dishes ] # Delete the tasks deleted = client . task . delete ( to_delete ) Before Result [{ 'id' : '60caa8e714f7103cef35765a' , 'projectId' : '60caa20d8f08fe3101186f74' , 'sortOrder' : - 1099511627776 , 'title' : 'Wash Car' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-06-17T01:44:07.000+0000' , 'etag' : '8372m61k' , 'deleted' : 0 , 'createdTime' : '2021-06-17T01:44:07.000+0000' , 'creator' : 115761422 , 'tags' : [], 'kind' : 'TEXT' }, { 'id' : '60caa8ea14f7103cef35765f' , 'projectId' : '60caa20d8f08fe3101186f74' , 'sortOrder' : - 2199023255552 , 'title' : 'Do Dishes' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-06-17T01:44:10.000+0000' , 'etag' : 'sfka0mvn' , 'deleted' : 0 , 'createdTime' : '2021-06-17T01:44:10.000+0000' , 'creator' : 1155481312 , 'tags' : [], 'kind' : 'TEXT' }] Source code in managers/tasks.py def delete ( self , task ): \"\"\" Deletes a task. Supports single task deletion, and batch task deletion. For a single task pass in the task dictionary. For multiple tasks pass in a list of task dictionaries. Arguments: task (str or list): **Single Task (dict)**: Task dictionary to be deleted **Multiple Tasks (list)**: List of task dictionaries to be deleted Returns: dict or list: **Single Task (dict)**: Task dictionary that was deleted **Multiple Tasks (list)**: List of task dictionaries that were deleted !!! example \"Task Deletion\" === \"Single Task Deletion\" ```python # Get the task task = client.get_by_fields(title=\"Molly's Birthday\", search=\"tasks\") # Delete the task deleted = client.task.delete(task) ``` ??? success \"Result\" ``` python {'id': '60caa2278f08fe3101187002', 'projectId': '60caa20d8f08fe3101186f74', 'sortOrder': -1099511627776, 'title': \"Molly's Birthday\", 'content': '', 'startDate': '2027-05-06T07:00:00.000+0000', 'dueDate': '2027-05-06T07:00:00.000+0000', 'timeZone': '', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'repeatFirstDate': '2027-05-05T07:00:00.000+0000', 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-06-17T01:25:19.000+0000', 'etag': 'rrn4paqp', 'deleted': 0, 'createdTime': '2021-06-17T01:15:19.365+0000', 'creator': 119784412, 'kind': 'TEXT'} ``` === \"Multiple Task Deletion\" ``` python # Get the tasks wash_car = client.get_by_fields(title=\"Wash Car\", search=\"tasks\") do_dishes = client.get_by_fields(title=\"Do Dishes\", search=\"tasks\") # Make a list for the tasks to_delete = [wash_car, do_dishes] # Delete the tasks deleted = client.task.delete(to_delete) ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/122317746-e11a8e00-ced2-11eb-8449-519615de5935.png) ??? success \"Result\" ```python [{'id': '60caa8e714f7103cef35765a', 'projectId': '60caa20d8f08fe3101186f74', 'sortOrder': -1099511627776, 'title': 'Wash Car', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-06-17T01:44:07.000+0000', 'etag': '8372m61k', 'deleted': 0, 'createdTime': '2021-06-17T01:44:07.000+0000', 'creator': 115761422, 'tags': [], 'kind': 'TEXT'}, {'id': '60caa8ea14f7103cef35765f', 'projectId': '60caa20d8f08fe3101186f74', 'sortOrder': -2199023255552, 'title': 'Do Dishes', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-06-17T01:44:10.000+0000', 'etag': 'sfka0mvn', 'deleted': 0, 'createdTime': '2021-06-17T01:44:10.000+0000', 'creator': 1155481312, 'tags': [], 'kind': 'TEXT'}] ``` ![image](https://user-images.githubusercontent.com/56806733/122317923-2212a280-ced3-11eb-8a6b-8a32fa8426ce.png) \"\"\" # generate url url = self . _generate_delete_url () to_delete = [] # if its just a dict then we are going to have to make a list object for it if isinstance ( task , dict ): # ticktick returns for the 'projectId': 'inbox' instead of the actual inbox id - which is required for # proper deletion if task [ 'projectId' ] == 'inbox' : task [ 'projectId' ] = self . _client . inbox_id delete_dict = { 'projectId' : task [ 'projectId' ], 'taskId' : task [ 'id' ]} to_delete . append ( delete_dict ) # iterate through \"task\" else : for item in task : if item [ 'projectId' ] == 'inbox' : item [ 'projectId' ] = self . _client . inbox_id delete_dict = { 'projectId' : item [ 'projectId' ], 'taskId' : item [ 'id' ]} to_delete . append ( delete_dict ) payload = { 'delete' : to_delete } # make request self . _client . http_post ( url , json = payload , cookies = self . _client . cookies , headers = self . headers ) # sync local state self . _client . sync () # return input return task","title":"delete()"},{"location":"usage/tasks/#managers.tasks.TaskManager.get_completed","text":"Obtains all completed tasks from the given start date and end date. Note There is a limit of 100 items for the request Parameters: Name Type Description Default start datetime Start time datetime object. required end datetime End time datetime object. None full bool Boolean specifying whether hours, minutes, and seconds are to be taken into account for the query. True tz str String specifying a specific time zone, however this will default to your accounts normal time zone. None Returns: Type Description list A list containing all the completed tasks based on the times. Exceptions: Type Description TypeError If the proper types are not used. ValueError If start occurs after end. KeyError If the time zone string passed is not a valid time zone string. RuntimeError If getting the tasks is unsuccessful. Getting Completed Tasks Completed Tasks In A Single Day Getting the tasks for a full, complete day requires passing in the datetime object corresponding to the day that you want. # Get the tasks for 1/11/2021 tasks = client . task . get_completed ( datetime ( 2021 , 1 , 11 )) Result The list of completed tasks is returned. [{ 'id' : '5ffca35f4c201114702a0607' , 'projectId' : '004847faa60015487be444cb' , 'sortOrder' : - 50027779063826 , 'title' : 'Shoulders and Arms' , 'content' : '' , 'desc' : '' , 'startDate' : '2021-01-11T08:00:00.000+0000' , 'dueDate' : '2021-01-11T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'repeatFlag' : '' , 'exDate' : [], 'completedTime' : '2021-01-11T23:25:46.000+0000' , 'completedUserId' : 185769383 , 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-11T23:25:41.000+0000' , 'etag' : '6hlk4e8t' , 'deleted' : 0 , 'createdTime' : '2021-01-11T19:13:35.000+0000' , 'creator' : 185769383 , 'tags' : [ 'fitness' ], 'commentCount' : 0 , 'pomodoroSummaries' : [{ 'userId' : 185769383 , 'count' : 0 , 'estimatedPomo' : 0 , 'duration' : 0 }], 'focusSummaries' : [{ 'userId' : 185769383 , 'pomoCount' : 0 , 'estimatedPomo' : 0 , 'estimatedDuration' : 0 , 'pomoDuration' : 0 , 'stopwatchDuration' : 3720 }], 'kind' : 'TEXT' }] Completed Tasks Over A Range Of Days Getting the tasks for a range of days requires passing in datetime objects for the start day, and the end day that you want. # Get the tasks between 8/7/18 and 8/10/18 start = datetime ( 2018 , 8 , 7 ) end = datetime ( 2018 , 8 , 10 ) tasks = client . task . get_completed ( start , end ) Result Completed tasks in a list are returned. [{ 'id' : '5ffffebab04b355792c79e38' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 7696581394432 , 'title' : 'Ride Bike' , 'content' : '' , 'startDate' : '2021-01-14T08:00:00.000+0000' , 'dueDate' : '2021-01-14T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'completedTime' : '2018-08-09T07:20:11.000+0000' , 'completedUserId' : 185769383 , 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T08:21:01.000+0000' , 'etag' : 'mhjyig4y' , 'deleted' : 0 , 'createdTime' : '2021-01-14T08:20:10.000+0000' , 'creator' : 185769383 , 'kind' : 'TEXT' }, { 'id' : '5ffffeaab04b355792c79d89' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 6597069766656 , 'title' : 'Read Book' , 'content' : '' , 'startDate' : '2021-01-14T08:00:00.000+0000' , 'dueDate' : '2021-01-14T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'completedTime' : '2018-08-08T07:20:12.000+0000' , 'completedUserId' : 185769383 , 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T08:20:46.000+0000' , 'etag' : 'tzd4coms' , 'deleted' : 0 , 'createdTime' : '2021-01-14T08:19:54.000+0000' , 'creator' : 185769383 , 'kind' : 'TEXT' }] Completed Tasks Over A Specific Duration Of Time You can also get completed tasks that were completed in a specific time duration. Include specific hours, minutes, and seconds for the datetime objects, and specify full to be false -> meaning that the specific times will be put into effect. # Get the tasks completed between 12PM and 5PM on 12/15/2020 start = datetime ( 2020 , 12 , 15 , 12 ) # 12PM 12/15/2020 end = datetime ( 2020 , 12 , 15 , 17 ) # 5PM 12/15/2020 tasks = client . task . get_completed ( start , end , full = False ) Source code in managers/tasks.py def get_completed ( self , start , end = None , full : bool = True , tz : str = None ) -> list : \"\"\" Obtains all completed tasks from the given start date and end date. !!! note There is a limit of 100 items for the request Arguments: start (datetime): Start time datetime object. end (datetime): End time datetime object. full: Boolean specifying whether hours, minutes, and seconds are to be taken into account for the query. tz: String specifying a specific time zone, however this will default to your accounts normal time zone. Returns: A list containing all the completed tasks based on the times. Raises: TypeError: If the proper types are not used. ValueError: If start occurs after end. KeyError: If the time zone string passed is not a valid time zone string. RuntimeError: If getting the tasks is unsuccessful. !!! example \"Getting Completed Tasks\" === \"Completed Tasks In A Single Day\" Getting the tasks for a full, complete day requires passing in the datetime object corresponding to the day that you want. ```python # Get the tasks for 1/11/2021 tasks = client.task.get_completed(datetime(2021, 1, 11)) ``` ??? success \"Result\" The list of completed tasks is returned. ```python [{'id': '5ffca35f4c201114702a0607', 'projectId': '004847faa60015487be444cb', 'sortOrder': -50027779063826, 'title': 'Shoulders and Arms', 'content': '', 'desc': '', 'startDate': '2021-01-11T08:00:00.000+0000', 'dueDate': '2021-01-11T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'repeatFlag': '', 'exDate': [], 'completedTime': '2021-01-11T23:25:46.000+0000', 'completedUserId': 185769383, 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-11T23:25:41.000+0000', 'etag': '6hlk4e8t', 'deleted': 0, 'createdTime': '2021-01-11T19:13:35.000+0000', 'creator': 185769383, 'tags': ['fitness'], 'commentCount': 0, 'pomodoroSummaries': [{'userId': 185769383, 'count': 0, 'estimatedPomo': 0, 'duration': 0}], 'focusSummaries': [{'userId': 185769383, 'pomoCount': 0, 'estimatedPomo': 0, 'estimatedDuration': 0, 'pomoDuration': 0, 'stopwatchDuration': 3720}], 'kind': 'TEXT'}] ``` ![image](https://user-images.githubusercontent.com/56806733/104562952-e1e68580-55fd-11eb-9e09-f432caa8616b.png) === \"Completed Tasks Over A Range Of Days\" Getting the tasks for a range of days requires passing in datetime objects for the start day, and the end day that you want. ```python # Get the tasks between 8/7/18 and 8/10/18 start = datetime(2018, 8, 7) end = datetime(2018, 8, 10) tasks = client.task.get_completed(start, end) ``` ??? success \"Result\" Completed tasks in a list are returned. ```python [{'id': '5ffffebab04b355792c79e38', 'projectId': 'inbox115781412', 'sortOrder': -7696581394432, 'title': 'Ride Bike', 'content': '', 'startDate': '2021-01-14T08:00:00.000+0000', 'dueDate': '2021-01-14T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'completedTime': '2018-08-09T07:20:11.000+0000', 'completedUserId': 185769383, 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T08:21:01.000+0000', 'etag': 'mhjyig4y', 'deleted': 0, 'createdTime': '2021-01-14T08:20:10.000+0000', 'creator': 185769383, 'kind': 'TEXT'}, {'id': '5ffffeaab04b355792c79d89', 'projectId': 'inbox115781412', 'sortOrder': -6597069766656, 'title': 'Read Book', 'content': '', 'startDate': '2021-01-14T08:00:00.000+0000', 'dueDate': '2021-01-14T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'completedTime': '2018-08-08T07:20:12.000+0000', 'completedUserId': 185769383, 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T08:20:46.000+0000', 'etag': 'tzd4coms', 'deleted': 0, 'createdTime': '2021-01-14T08:19:54.000+0000', 'creator': 185769383, 'kind': 'TEXT'}] ``` ![image](https://user-images.githubusercontent.com/56806733/104563478-8c5ea880-55fe-11eb-9bcf-91bc44c02083.png) === \"Completed Tasks Over A Specific Duration Of Time\" You can also get completed tasks that were completed in a specific time duration. Include specific hours, minutes, and seconds for the datetime objects, and specify `full` to be false -> meaning that the specific times will be put into effect. ```python # Get the tasks completed between 12PM and 5PM on 12/15/2020 start = datetime(2020, 12, 15, 12) # 12PM 12/15/2020 end = datetime(2020, 12, 15, 17) # 5PM 12/15/2020 tasks = client.task.get_completed(start, end, full=False) ``` \"\"\" url = self . _client . BASE_URL + 'project/all/completed' if tz is None : tz = self . _client . time_zone if not isinstance ( start , datetime . datetime ): raise TypeError ( 'Start Must Be A Datetime Object' ) if not isinstance ( end , datetime . datetime ) and end is not None : raise TypeError ( 'End Must Be A Datetime Object' ) # Handles case when start_date occurs after end_date if end is not None and start > end : raise ValueError ( 'Invalid Date Range: Start Date Occurs After End Date' ) # Handles invalid timezone argument if tz not in pytz . all_timezones_set : raise KeyError ( 'Invalid Time Zone' ) # Single Day Entry if end is None : start = datetime . datetime ( start . year , start . month , start . day , 0 , 0 , 0 ) end = datetime . datetime ( start . year , start . month , start . day , 23 , 59 , 59 ) # Multi DAy -> Full Day Entry elif full is True and end is not None : start = datetime . datetime ( start . year , start . month , start . day , 0 , 0 , 0 ) end = datetime . datetime ( end . year , end . month , end . day , 23 , 59 , 59 ) # Convert Local Time to UTC time based off the time_zone string specified start = convert_local_time_to_utc ( start , tz ) end = convert_local_time_to_utc ( end , tz ) parameters = { 'from' : start . strftime ( DATE_FORMAT ), 'to' : end . strftime ( DATE_FORMAT ), 'limit' : 100 } response = self . _client . http_get ( url , params = parameters , cookies = self . _client . cookies , headers = self . headers ) return response","title":"get_completed()"},{"location":"usage/tasks/#managers.tasks.TaskManager.get_from_project","text":"Obtains the tasks that are contained in the project. Parameters: Name Type Description Default project str ID string of the project to get the tasks from. required Returns: Type Description dict or list Single Task In Project (dict) : The single task object dictionary. Multiple Tasks In Project (list) : A list of task object dictionaries. No Tasks Found (list) : Empty list. Exceptions: Type Description ValueError If the project ID does not exist. Getting Uncompleted Tasks From The Inbox tasks = client . task . get_from_project ( client . inbox_id ) Result See Returns for the different return values based on the amount of tasks present in the project. [{ 'id' : '5ffe93efb04b35082bbce7af' , 'projectId' : 'inbox115781412' , 'sortOrder' : 2199023255552 , 'title' : 'Go To Library' , 'content' : '' , 'startDate' : '2021-01-12T08:00:00.000+0000' , 'dueDate' : '2021-01-12T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T06:32:15.000+0000' , 'etag' : 'kkh0w1jk' , 'deleted' : 0 , 'createdTime' : '2021-01-13T06:32:15.000+0000' , 'creator' : 447666584 , 'tags' : [], 'kind' : 'TEXT' }, { 'id' : '5ffe93f3b04b35082bbce7b0' , 'projectId' : 'inbox115781412' , 'sortOrder' : 1099511627776 , 'title' : 'Deposit Funds' , 'content' : '' , 'startDate' : '2021-01-12T08:00:00.000+0000' , 'dueDate' : '2021-01-12T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T06:32:19.000+0000' , 'etag' : 'w4hj21wf' , 'deleted' : 0 , 'createdTime' : '2021-01-13T06:32:19.000+0000' , 'creator' : 447666584 , 'tags' : [], 'kind' : 'TEXT' }] Source code in managers/tasks.py def get_from_project ( self , project : str ): \"\"\" Obtains the tasks that are contained in the project. Arguments: project: ID string of the project to get the tasks from. Returns: dict or list: **Single Task In Project (dict)**: The single task object dictionary. **Multiple Tasks In Project (list)**: A list of task object dictionaries. **No Tasks Found (list)**: Empty list. Raises: ValueError: If the project ID does not exist. !!! example \"Getting Uncompleted Tasks From The Inbox\" ```python tasks = client.task.get_from_project(client.inbox_id) ``` ??? success \"Result\" See `Returns` for the different return values based on the amount of tasks present in the project. ```python [{'id': '5ffe93efb04b35082bbce7af', 'projectId': 'inbox115781412', 'sortOrder': 2199023255552, 'title': 'Go To Library', 'content': '', 'startDate': '2021-01-12T08:00:00.000+0000', 'dueDate': '2021-01-12T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T06:32:15.000+0000', 'etag': 'kkh0w1jk', 'deleted': 0, 'createdTime': '2021-01-13T06:32:15.000+0000', 'creator': 447666584, 'tags': [], 'kind': 'TEXT'}, {'id': '5ffe93f3b04b35082bbce7b0', 'projectId': 'inbox115781412', 'sortOrder': 1099511627776, 'title': 'Deposit Funds', 'content': '', 'startDate': '2021-01-12T08:00:00.000+0000', 'dueDate': '2021-01-12T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T06:32:19.000+0000', 'etag': 'w4hj21wf', 'deleted': 0, 'createdTime': '2021-01-13T06:32:19.000+0000', 'creator': 447666584, 'tags': [], 'kind': 'TEXT'}] ``` ![image](https://user-images.githubusercontent.com/56806733/104415494-f86ddd80-5526-11eb-8b84-75bf3886ba46.png) \"\"\" # Make sure the project exists if project != self . _client . inbox_id : obj = self . _client . get_by_fields ( id = project , search = 'projects' ) if not obj : raise ValueError ( f \"List Id ' { project } ' Does Not Exist\" ) # Get the list of tasks that share the project id tasks = self . _client . get_by_fields ( projectId = project , search = 'tasks' ) if isinstance ( tasks , dict ): return [ tasks ] else : return tasks","title":"get_from_project()"},{"location":"usage/tasks/#managers.tasks.TaskManager.make_subtask","text":"Makes the passed task(s) sub-tasks to the parent task. Important All of the tasks should already be created prior to using this method. Furthermore, the tasks should already be present in the same project as the parent task. Parameters: Name Type Description Default obj dict Single Sub-Task (dict) : The task object dictionary. Multiple Sub-Tasks (list) : A list of task object dictionaries. required parent str The ID of the task that will be the parent task. required Returns: Type Description dict Single Sub-Task (dict) : Created sub-task dictionary. Multiple Sub-Tasks (list) : List of created sub-task dictionaries. Exceptions: Type Description TypeError obj must be a dictionary or list of dictionaries. parent must be a string. ValueError If parent task doesn't exist. ValueError If obj does not share the same project as parent. RuntimeError If the creation was unsuccessful. Creating Sub-Tasks Single Sub-Task Creation Pass the task object that will be made a sub-task to the parent with the passed ID. # Lets make a task in our inbox named \"Read\" with a sub-task \"50 Pages\" read_task = client . task . create ( 'Read' ) pages_task = client . task . create ( '50 pages' ) now_subtask = client . task . make_subtask ( pages_task , read_task [ 'id' ]) Result The dictionary of the sub-task is returned. { 'id' : '5ffff4968f08af50b4654c6b' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 3298534883328 , 'title' : '50 pages' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-14T07:37:36.487+0000' , 'etag' : 'xv5cjzoz' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:36:54.751+0000' , 'creator' : 115781412 , 'parentId' : '5ffff4968f08af50b4654c62' , 'kind' : 'TEXT' } Before After Multiple Sub-Task Creation Pass all the tasks you want to make sub-tasks in a list. # Lets make a task in our inbox named \"Read\" with a sub-tasks \"50 Pages\", \"100 Pages\", and \"200 Pages\" read_task = client . task . create ( \"Read\" ) # Lets batch create our sub-tasks fifty_pages = client . task . builder ( '50 Pages' ) hundred_pages = client . task . builder ( '100 Pages' ) two_hundred_pages = client . task . builder ( '200 Pages' ) page_tasks = client . task . create ([ fifty_pages , hundred_pages , two_hundred_pages ]) # Make the page tasks sub-tasks to read_task subtasks = client . task . make_subtask ( page_tasks , read_task [ 'id' ]) Result A list of the sub-tasks is returned. [{ 'id' : '5ffff6348f082c11cc0da84d' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 5497558138880 , 'title' : '50 Pages' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-14T07:45:04.032+0000' , 'etag' : 'avqm3u6o' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:43:48.858+0000' , 'creator' : 567893575 , 'parentId' : '5ffff6348f082c11cc0da84a' , 'kind' : 'TEXT' }, { 'id' : '5ffff6348f082c11cc0da84e' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 5497558138880 , 'title' : '100 Pages' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-14T07:45:04.035+0000' , 'etag' : '6295mmmu' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:43:49.286+0000' , 'creator' : 567893575 , 'parentId' : '5ffff6348f082c11cc0da84a' , 'kind' : 'TEXT' }, { 'id' : '5ffff6348f082c11cc0da84f' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 5497558138880 , 'title' : '200 Pages' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-14T07:45:04.038+0000' , 'etag' : 'du59zwck' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:43:49.315+0000' , 'creator' : 567893575 , 'parentId' : '5ffff6348f082c11cc0da84a' , 'kind' : 'TEXT' }] Before After Source code in managers/tasks.py def make_subtask ( self , obj , parent : str ): \"\"\" Makes the passed task(s) sub-tasks to the parent task. !!! note \"Important\" All of the tasks should already be created prior to using this method. Furthermore, the tasks should already be present in the same project as the parent task. Arguments: obj (dict): **Single Sub-Task (dict)**: The task object dictionary. **Multiple Sub-Tasks (list)**: A list of task object dictionaries. parent (str): The ID of the task that will be the parent task. Returns: dict: **Single Sub-Task (dict)**: Created sub-task dictionary. **Multiple Sub-Tasks (list)**: List of created sub-task dictionaries. Raises: TypeError: `obj` must be a dictionary or list of dictionaries. `parent` must be a string. ValueError: If `parent` task doesn't exist. ValueError: If `obj` does not share the same project as parent. RuntimeError: If the creation was unsuccessful. !!! example \"Creating Sub-Tasks\" === \"Single Sub-Task Creation\" Pass the task object that will be made a sub-task to the parent with the passed ID. ```python # Lets make a task in our inbox named \"Read\" with a sub-task \"50 Pages\" read_task = client.task.create('Read') pages_task = client.task.create('50 pages') now_subtask = client.task.make_subtask(pages_task, read_task['id']) ``` ??? success \"Result\" The dictionary of the sub-task is returned. ```python {'id': '5ffff4968f08af50b4654c6b', 'projectId': 'inbox115781412', 'sortOrder': -3298534883328, 'title': '50 pages', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-14T07:37:36.487+0000', 'etag': 'xv5cjzoz', 'deleted': 0, 'createdTime': '2021-01-14T07:36:54.751+0000', 'creator': 115781412, 'parentId': '5ffff4968f08af50b4654c62', 'kind': 'TEXT'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104558809-4272c400-55f8-11eb-8c55-e2f77c9d1ac8.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104558849-55859400-55f8-11eb-9692-c3e01aa73233.png) === \"Multiple Sub-Task Creation\" Pass all the tasks you want to make sub-tasks in a list. ```python # Lets make a task in our inbox named \"Read\" with a sub-tasks \"50 Pages\", \"100 Pages\", and \"200 Pages\" read_task = client.task.create(\"Read\") # Lets batch create our sub-tasks fifty_pages = client.task.builder('50 Pages') hundred_pages = client.task.builder('100 Pages') two_hundred_pages = client.task.builder('200 Pages') page_tasks = client.task.create([fifty_pages, hundred_pages, two_hundred_pages]) # Make the page tasks sub-tasks to read_task subtasks = client.task.make_subtask(page_tasks, read_task['id']) ``` ??? success \"Result\" A list of the sub-tasks is returned. ```python [{'id': '5ffff6348f082c11cc0da84d', 'projectId': 'inbox115781412', 'sortOrder': -5497558138880, 'title': '50 Pages', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-14T07:45:04.032+0000', 'etag': 'avqm3u6o', 'deleted': 0, 'createdTime': '2021-01-14T07:43:48.858+0000', 'creator': 567893575, 'parentId': '5ffff6348f082c11cc0da84a', 'kind': 'TEXT'}, {'id': '5ffff6348f082c11cc0da84e', 'projectId': 'inbox115781412', 'sortOrder': -5497558138880, 'title': '100 Pages', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-14T07:45:04.035+0000', 'etag': '6295mmmu', 'deleted': 0, 'createdTime': '2021-01-14T07:43:49.286+0000', 'creator': 567893575, 'parentId': '5ffff6348f082c11cc0da84a', 'kind': 'TEXT'}, {'id': '5ffff6348f082c11cc0da84f', 'projectId': 'inbox115781412', 'sortOrder': -5497558138880, 'title': '200 Pages', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-14T07:45:04.038+0000', 'etag': 'du59zwck', 'deleted': 0, 'createdTime': '2021-01-14T07:43:49.315+0000', 'creator': 567893575, 'parentId': '5ffff6348f082c11cc0da84a', 'kind': 'TEXT'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104559418-36d3cd00-55f9-11eb-9004-177671a92474.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104559535-64207b00-55f9-11eb-84cf-ca4f989ea075.png) \"\"\" if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( 'obj must be a dictionary or list of dictionaries' ) if not isinstance ( parent , str ): raise TypeError ( 'parent must be a string' ) if isinstance ( obj , dict ): obj = [ obj ] parent_obj = self . _client . get_by_id ( search = 'tasks' , obj_id = parent ) if not parent_obj : raise ValueError ( \"Parent task must exist before creating sub-tasks\" ) ids = [] # Go through obj and if the projects are different make them the same as parent for o in obj : if o [ 'projectId' ] != parent_obj [ 'projectId' ]: raise ValueError ( \"All tasks must be in the same project as the parent\" ) ids . append ( o [ 'id' ]) subtasks = [] for i in ids : # Create the object dictionaries for setting the subtask temp = { 'parentId' : parent , 'projectId' : parent_obj [ 'projectId' ], 'taskId' : i } subtasks . append ( temp ) url = self . _client . BASE_URL + 'batch/taskParent' response = self . _client . http_post ( url , json = subtasks , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () # Find and return the updated child objects subtasks = [] for task_id in ids : subtasks . append ( self . _client . get_by_id ( task_id , search = 'tasks' )) if len ( subtasks ) == 1 : return subtasks [ 0 ] # Return just the dictionary object if its a single task else : return subtasks","title":"make_subtask()"},{"location":"usage/tasks/#managers.tasks.TaskManager.move","text":"Moves task(s) from their current project to the new project. It will move the specified tasks with obj to the new project. Important If moving multiple tasks, they must all be from the same project. Parameters: Name Type Description Default obj dict or list Single Task (dict) : Pass the single task dictionary object to move. Multiple Tasks (list) : Pass a list of task dictionary objects to move. required new str The ID string of the project that the task(s) should be moved to. required Returns: Type Description dict or list Single Task (dict) : Returns the dictionary of the moved task. Multiple Tasks (list) : Returns a list of dictionaries for the moved tasks. Exceptions: Type Description TypeError If obj is not a dict or list or if new is not a str. ValueError For multiple tasks, if the projects are not all the same. ValueError If the new project does not exist. RuntimeError If the task(s) could not be successfully moved. Move Examples Moving A Single Task Pass in the task object, and the ID of the project the task should be moved to. # Lets assume that we have a task 'Read' that exists in a project named \"Work\" # Lets move that task to the inbox read_task = client . get_by_fields ( title = 'Read' , search = 'tasks' ) move_read_task = client . task . move ( read_task , client . inbox_id ) Result The dictionary object of the moved task is returned. { 'id' : '5fffed61b04b355792c799a8' , 'projectId' : 'inbox115781412' , 'sortOrder' : 0 , 'title' : 'Read' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T07:08:15.875+0000' , 'etag' : 'twrmcr55' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:06:09.000+0000' , 'creator' : 47593756 , 'tags' : [], 'kind' : 'TEXT' } Before After Moving Multiple Tasks Pass in the task objects in a list, and the ID of the project that tasks should be moved to. Again, the tasks in the list should all be from the same project. # Lets move two tasks: 'Read' and 'Write' that exist in a project named \"Work\" # Lets move the tasks to another project named \"Hobbies\" that already exists. hobbies_project = client . get_by_fields ( name = 'Hobbies' , search = 'projects' ) hobbies_id = hobbies_project [ 'id' ] # Id of the hobbies project read_task = client . get_by_fields ( title = 'Read' , search = 'tasks' ) write_task = client . get_by_fields ( title = 'Write' , search = 'tasks' ) move_tasks = client . task . move ([ read_task , write_task ], hobbies_id ) # Task objects in a list Result The tasks that were moved are returned in a list. [{ 'id' : '5ffff003b04b355792c799d3' , 'projectId' : '5fffeff68f08654c982c141a' , 'sortOrder' : 0 , 'title' : 'Read' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T07:19:28.595+0000' , 'etag' : 'co8jfqyn' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:17:23.000+0000' , 'creator' : 768495743 , 'kind' : 'TEXT' }, { 'id' : '5ffff004b04b355792c799d4' , 'projectId' : '5fffeff68f08654c982c141a' , 'sortOrder' : 0 , 'title' : 'Write' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T07:19:28.596+0000' , 'etag' : '5unkf7xg' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:17:24.000+0000' , 'creator' : 768495743 , 'tags' : [], 'kind' : 'TEXT' }] Before After Source code in managers/tasks.py def move ( self , obj , new : str ): \"\"\" Moves task(s) from their current project to the new project. It will move the specified tasks with `obj` to the new project. !!! important If moving multiple tasks, they must all be from the same project. Arguments: obj (dict or list): **Single Task (dict)**: Pass the single task dictionary object to move. **Multiple Tasks (list)**: Pass a list of task dictionary objects to move. new: The ID string of the project that the task(s) should be moved to. Returns: dict or list: **Single Task (dict)**: Returns the dictionary of the moved task. **Multiple Tasks (list)**: Returns a list of dictionaries for the moved tasks. Raises: TypeError: If `obj` is not a dict or list or if `new` is not a str. ValueError: For multiple tasks, if the projects are not all the same. ValueError: If the new project does not exist. RuntimeError: If the task(s) could not be successfully moved. !!! example \"Move Examples\" === \"Moving A Single Task\" Pass in the task object, and the ID of the project the task should be moved to. ```python # Lets assume that we have a task 'Read' that exists in a project named \"Work\" # Lets move that task to the inbox read_task = client.get_by_fields(title='Read', search='tasks') move_read_task = client.task.move(read_task, client.inbox_id) ``` ??? success \"Result\" The dictionary object of the moved task is returned. ```python {'id': '5fffed61b04b355792c799a8', 'projectId': 'inbox115781412', 'sortOrder': 0, 'title': 'Read', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T07:08:15.875+0000', 'etag': 'twrmcr55', 'deleted': 0, 'createdTime': '2021-01-14T07:06:09.000+0000', 'creator': 47593756, 'tags': [], 'kind': 'TEXT'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104556170-f1f96780-55f3-11eb-9a35-aecc3beea105.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104556336-46044c00-55f4-11eb-98c1-4cffcf4bd006.png) === \"Moving Multiple Tasks\" Pass in the task objects in a list, and the ID of the project that tasks should be moved to. Again, the tasks in the list should all be from the same project. ```python # Lets move two tasks: 'Read' and 'Write' that exist in a project named \"Work\" # Lets move the tasks to another project named \"Hobbies\" that already exists. hobbies_project = client.get_by_fields(name='Hobbies', search='projects') hobbies_id = hobbies_project['id'] # Id of the hobbies project read_task = client.get_by_fields(title='Read', search='tasks') write_task = client.get_by_fields(title='Write', search='tasks') move_tasks = client.task.move([read_task, write_task], hobbies_id) # Task objects in a list ``` ??? success \"Result\" The tasks that were moved are returned in a list. ```python [{'id': '5ffff003b04b355792c799d3', 'projectId': '5fffeff68f08654c982c141a', 'sortOrder': 0, 'title': 'Read', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T07:19:28.595+0000', 'etag': 'co8jfqyn', 'deleted': 0, 'createdTime': '2021-01-14T07:17:23.000+0000', 'creator': 768495743, 'kind': 'TEXT'}, {'id': '5ffff004b04b355792c799d4', 'projectId': '5fffeff68f08654c982c141a', 'sortOrder': 0, 'title': 'Write', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T07:19:28.596+0000', 'etag': '5unkf7xg', 'deleted': 0, 'createdTime': '2021-01-14T07:17:24.000+0000', 'creator': 768495743, 'tags': [], 'kind': 'TEXT'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104557103-857f6800-55f5-11eb-8b92-cf51bc159745.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104557388-063e6400-55f6-11eb-8ba4-aa64f3f739bd.png) \"\"\" # Type errors if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( 'obj should be a dict or list of dicts' ) if not isinstance ( new , str ): raise TypeError ( 'new should be a string' ) # Get the parent project if new != self . _client . inbox_id : project = self . _client . get_by_id ( new , search = 'projects' ) if not project : raise ValueError ( 'The ID for the new project does not exist' ) if isinstance ( obj , dict ): obj = [ obj ] # Go through and check that the projects are all the same move_tasks = [] project_id = obj [ 0 ][ 'projectId' ] for task in obj : if task [ 'projectId' ] != project_id : raise ValueError ( 'All the tasks must come from the same project' ) else : move_tasks . append ({ 'fromProjectId' : project_id , 'taskId' : task [ 'id' ], 'toProjectId' : new }) url = self . _client . BASE_URL + 'batch/taskProject' self . _client . http_post ( url , json = move_tasks , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () # Return the tasks in the new list ids = [ x [ 'id' ] for x in obj ] return_list = [] for i in ids : return_list . append ( self . _client . get_by_id ( i )) if len ( return_list ) == 1 : return return_list [ 0 ] else : return return_list","title":"move()"},{"location":"usage/tasks/#managers.tasks.TaskManager.move_all","text":"Moves all the tasks from the old project to the new project. Parameters: Name Type Description Default old str ID of the old project. required new str ID of the new project. required Returns: Type Description list The tasks contained in the new project. Exceptions: Type Description ValueError If either the old or new projects do not exist. RuntimeError If the movement was unsuccessful. Example Lets assume that we have a project named \"School\", and another project named \"Work\". To move all the tasks from \"School\" to \"Work\": # Get the projects school_project = client . get_by_fields ( name = 'School' , search = 'projects' ) work_project = client . get_by_fields ( name = 'Work' , search = 'projects' ) # Call the method moved_tasks = client . task . move_all ( school_project [ 'id' ], work_project [ 'id' ]) Result The tasks that were moved are returned. [{ 'id' : '5ffea9afe4b062d60dd62aef' , 'projectId' : '5ffea9afe4b062d60dd62aea' , 'sortOrder' : 0 , 'title' : 'Finish documentation for project' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-13T08:06:31.407+0000' , 'etag' : 'ogclghmd' , 'deleted' : 0 , 'createdTime' : '2021-01-13T08:05:03.901+0000' , 'creator' : 447666584 , 'kind' : 'TEXT' }, { 'id' : '5ffea9b0e4b062d60dd62af4' , 'projectId' : '5ffea9afe4b062d60dd62aea' , 'sortOrder' : 0 , 'title' : 'Call the boss man' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-13T08:06:31.409+0000' , 'etag' : '65c73q8i' , 'deleted' : 0 , 'createdTime' : '2021-01-13T08:05:04.117+0000' , 'creator' : 447666584 , 'kind' : 'TEXT' }] Before : Two tasks are contained in the \"School\" project After : The two tasks are moved to the 'Work' project Source code in managers/tasks.py def move_all ( self , old : str , new : str ) -> list : \"\"\" Moves all the tasks from the old project to the new project. Arguments: old: ID of the old project. new: ID of the new project. Returns: The tasks contained in the new project. Raises: ValueError: If either the old or new projects do not exist. RuntimeError: If the movement was unsuccessful. !!! example Lets assume that we have a project named \"School\", and another project named \"Work\". To move all the tasks from \"School\" to \"Work\": ```python # Get the projects school_project = client.get_by_fields(name='School', search='projects') work_project = client.get_by_fields(name='Work', search='projects') # Call the method moved_tasks = client.task.move_all(school_project['id'], work_project['id']) ``` ??? success \"Result\" The tasks that were moved are returned. ```python [{'id': '5ffea9afe4b062d60dd62aef', 'projectId': '5ffea9afe4b062d60dd62aea', 'sortOrder': 0, 'title': 'Finish documentation for project', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-13T08:06:31.407+0000', 'etag': 'ogclghmd', 'deleted': 0, 'createdTime': '2021-01-13T08:05:03.901+0000', 'creator': 447666584, 'kind': 'TEXT'}, {'id': '5ffea9b0e4b062d60dd62af4', 'projectId': '5ffea9afe4b062d60dd62aea', 'sortOrder': 0, 'title': 'Call the boss man', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-13T08:06:31.409+0000', 'etag': '65c73q8i', 'deleted': 0, 'createdTime': '2021-01-13T08:05:04.117+0000', 'creator': 447666584, 'kind': 'TEXT'}] ``` **Before**: Two tasks are contained in the \"School\" project ![image](https://user-images.githubusercontent.com/56806733/104423574-1e997a80-5533-11eb-9417-34c31e603d21.png) **After**: The two tasks are moved to the 'Work' project ![image](https://user-images.githubusercontent.com/56806733/104423710-4a1c6500-5533-11eb-90f3-2c3d024280af.png) \"\"\" # Make sure that old and new id's exist if old != self . _client . inbox_id : old_list = self . _client . get_by_fields ( id = old , search = 'projects' ) if not old_list : raise ValueError ( f \"Project Id ' { old } ' Does Not Exist\" ) if new != self . _client . inbox_id : new_list = self . _client . get_by_fields ( id = new , search = 'projects' ) if not new_list : raise ValueError ( f \"Project Id ' { new } ' Does Not Exist\" ) # Get the tasks from the old list tasks = self . get_from_project ( old ) if not tasks : return tasks # No tasks to move so just return the empty list task_project = [] # List containing all the tasks that will be updated for task in tasks : task_project . append ({ 'fromProjectId' : old , 'taskId' : task [ 'id' ], 'toProjectId' : new }) url = self . _client . BASE_URL + 'batch/taskProject' # Make the initial call to move the tasks self . _client . http_post ( url , json = task_project , cookies = self . _client . cookies , headers = self . headers ) self . _client . sync () # Return the tasks in the new list return self . _client . task . get_from_project ( new )","title":"move_all()"},{"location":"usage/tasks/#managers.tasks.TaskManager.update","text":"Update a task. The task should already be created. To update a task, change any field in it's dictionary directly then pass to the method. Warning Creating tasks with tags is not functional but will be implemented in a future update. Parameters: Name Type Description Default task dict Task dictionary to be updated required Returns: Type Description dict The updated task dictionary object Formatting Dates Help TickTick uses a certain syntax for their dates. To convert a datetime object to a compatible string to be used for updating dates, see convert_date_to_tick_tick_format Changing The Date # Get the task mollys_birthday = client . get_by_fields ( title = \"Molly's Birthday\" , search = \"tasks\" ) # New Date new_date = datetime ( 2027 , 5 , 6 ) # Get the new date string new_date_string = convert_date_to_tick_tick_format ( new_date , tz = client . time_zone ) # Update the task dictionary mollys_birthday [ 'startDate' ] = new_date_string # Update the task molly_updated = client . task . update ( mollys_birthday ) Original Task Result { 'id' : '60caa2278f08fe3101187002' , 'projectId' : '60caa20d8f08fe3101186f74' , 'title' : \"Molly's Birthday\" , 'content' : '' , 'timeZone' : '' , 'startDate' : '2027-05-06T07:00:00.000+0000' , 'dueDate' : '2027-05-05T07:00:00.000+0000' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'sortOrder' : - 1099511627776 , 'items' : [], 'allDay' : True } Source code in managers/tasks.py def update ( self , task ): \"\"\" Update a task. The task should already be created. To update a task, change any field in it's dictionary directly then pass to the method. !!! warning Creating tasks with tags is not functional but will be implemented in a future update. Arguments: task (dict): Task dictionary to be updated Returns: dict: The updated task dictionary object !!! tip \"Formatting Dates Help\" TickTick uses a certain syntax for their dates. To convert a datetime object to a compatible string to be used for updating dates, see [convert_date_to_tick_tick_format][helpers.time_methods.convert_date_to_tick_tick_format] !!! example \"Changing The Date\" ```python # Get the task mollys_birthday = client.get_by_fields(title=\"Molly's Birthday\", search=\"tasks\") # New Date new_date = datetime(2027, 5, 6) # Get the new date string new_date_string = convert_date_to_tick_tick_format(new_date, tz=client.time_zone) # Update the task dictionary mollys_birthday['startDate'] = new_date_string # Update the task molly_updated = client.task.update(mollys_birthday) ``` **Original Task** ![image](https://user-images.githubusercontent.com/56806733/122316205-49b43b80-ced0-11eb-8d14-61fa5bb5b10a.png) ??? success \"Result\" ```python {'id': '60caa2278f08fe3101187002', 'projectId': '60caa20d8f08fe3101186f74', 'title': \"Molly's Birthday\", 'content': '', 'timeZone': '', 'startDate': '2027-05-06T07:00:00.000+0000', 'dueDate': '2027-05-05T07:00:00.000+0000', 'reminders': [], 'priority': 0, 'status': 0, 'sortOrder': -1099511627776, 'items': [], 'allDay': True} ``` ![image](https://user-images.githubusercontent.com/56806733/122316408-ad3e6900-ced0-11eb-89f9-6d980b5cc954.png) \"\"\" # TODO: Make tags work # generate url url = self . _generate_update_url ( task [ 'id' ]) # make request response = self . _client . http_post ( url = url , json = task , headers = self . oauth_headers ) # sync local state self . _client . sync () # return response return response","title":"update()"}]}